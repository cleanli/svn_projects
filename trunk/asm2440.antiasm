
asm2440.elf:     file format elf32-littlearm

Disassembly of section .text:

30000000 <_start>:

.globl nand_read_ll
.globl main
.globl _start
_start:	b       start_code
30000000:	ea000017 	b	30000064 <start_code>
	b	_start
30000004:	eafffffd 	b	30000000 <_start>
	b	_start
30000008:	eafffffc 	b	30000000 <_start>
	b	_start
3000000c:	eafffffb 	b	30000000 <_start>
	b	_start
30000010:	eafffffa 	b	30000000 <_start>
	b	_start
30000014:	eafffff9 	b	30000000 <_start>
	b	_start
30000018:	eafffff8 	b	30000000 <_start>
	b	_start
3000001c:	eafffff7 	b	30000000 <_start>
	b	_start
30000020:	eafffff6 	b	30000000 <_start>
30000024:	deadbeef 	cdple	14, 10, cr11, cr13, cr15, {7}
30000028:	deadbeef 	cdple	14, 10, cr11, cr13, cr15, {7}
3000002c:	deadbeef 	cdple	14, 10, cr11, cr13, cr15, {7}

30000030 <mem_reg_value>:
30000030:	22111110 	andcss	r1, r1, #4	; 0x4
30000034:	00000700 	andeq	r0, r0, r0, lsl #14
30000038:	00000700 	andeq	r0, r0, r0, lsl #14
3000003c:	00000700 	andeq	r0, r0, r0, lsl #14
30000040:	00000700 	andeq	r0, r0, r0, lsl #14
30000044:	00000700 	andeq	r0, r0, r0, lsl #14
30000048:	00000700 	andeq	r0, r0, r0, lsl #14
3000004c:	00018009 	andeq	r8, r1, r9
30000050:	00018009 	andeq	r8, r1, r9
30000054:	00ac03f4 	streqd	r0, [ip], r4
30000058:	000000b2 	streqh	r0, [r0], -r2
3000005c:	00000030 	andeq	r0, r0, r0, lsr r0
30000060:	00000030 	andeq	r0, r0, r0, lsr r0

30000064 <start_code>:
	.balignl 16,0xdeadbeef
.align 4

mem_reg_value:
        .long   0x22111110
        .long   0x00000700
        .long   0x00000700
        .long   0x00000700
        .long   0x00000700
        .long   0x00000700
        .long   0x00000700
        .long   0x00018009
        .long   0x00018009
        .long   0x00ac03f4
        .long   0x000000b2
        .long   0x00000030
        .long   0x00000030
/*
 * the actual start code
 */

start_code:
	/*
	 * set the cpu to SVC32 mode
	 */
	mrs	r0,cpsr
30000064:	e10f0000 	mrs	r0, CPSR
	bic	r0,r0,#0x1f
30000068:	e3c0001f 	bic	r0, r0, #31	; 0x1f
	orr	r0,r0,#0xd3
3000006c:	e38000d3 	orr	r0, r0, #211	; 0xd3
	msr	cpsr,r0
30000070:	e129f000 	msr	CPSR_fc, r0


#  define pWTCON		0x53000000
#  define INTMSK		0x4A000008	/* Interupt-Controller base addresses */
#  define INTSUBMSK	0x4A00001C
#  define CLKDIVN	0x4C000014	/* clock divisor register */

	ldr     r0, =pWTCON
30000074:	e3a00453 	mov	r0, #1392508928	; 0x53000000
	mov     r1, #0x0
30000078:	e3a01000 	mov	r1, #0	; 0x0
	str     r1, [r0]
3000007c:	e5801000 	str	r1, [r0]

/*init sp*/
	@ldr	sp, =0x00000ff8
	ldr	sp, =0x30101000
30000080:	e59fd1c4 	ldr	sp, [pc, #452]	; 3000024c <.text+0x24c>

	/*
	 * mask all IRQs by setting all bits in the INTMR - default
	 */
	mov	r1, #0xffffffff
30000084:	e3e01000 	mvn	r1, #0	; 0x0
	ldr	r0, =INTMSK
30000088:	e59f01c0 	ldr	r0, [pc, #448]	; 30000250 <.text+0x250>
	str	r1, [r0]
3000008c:	e5801000 	str	r1, [r0]

	ldr	r1, =0x7ff
30000090:	e59f11bc 	ldr	r1, [pc, #444]	; 30000254 <.text+0x254>
	ldr	r0, =INTSUBMSK
30000094:	e59f01bc 	ldr	r0, [pc, #444]	; 30000258 <.text+0x258>
	str	r1, [r0]
30000098:	e5801000 	str	r1, [r0]

/*******************************************************************************/
#  define GPFCON                0x56000050
#  define GPFDAT                0x56000054      /*  */
#  define LOCKTIME              0x4C000000
#  define MPLLCON               0x4C000004
#  define UPLLCON               0x4C000008

        ldr     r0, =GPFCON
3000009c:	e59f01b8 	ldr	r0, [pc, #440]	; 3000025c <.text+0x25c>
        mov     r1, #0x5500
300000a0:	e3a01c55 	mov	r1, #21760	; 0x5500
        str     r1, [r0]
300000a4:	e5801000 	str	r1, [r0]

        @initialize clock
        ldr     r0, =LOCKTIME
300000a8:	e3a00313 	mov	r0, #1275068416	; 0x4c000000
        ldr     r1, =0x00ffffff
300000ac:	e3e014ff 	mvn	r1, #-16777216	; 0xff000000
        str     r1, [r0]
300000b0:	e5801000 	str	r1, [r0]
        /* FCLK:HCLK:PCLK = 1:4:8 */
        ldr     r0, =CLKDIVN
300000b4:	e59f01a4 	ldr	r0, [pc, #420]	; 30000260 <.text+0x260>
        mov     r1, #5
300000b8:	e3a01005 	mov	r1, #5	; 0x5
        str     r1, [r0]
300000bc:	e5801000 	str	r1, [r0]
        @open code cache
        mrc     p15,0,r1,c1,c0,0
300000c0:	ee111f10 	mrc	15, 0, r1, cr1, cr0, {0}
        orr     r1,r1,#0xc0000000
300000c4:	e3811103 	orr	r1, r1, #-1073741824	; 0xc0000000
        mcr     p15,0,r1,c1,c0,0
300000c8:	ee011f10 	mcr	15, 0, r1, cr1, cr0, {0}
        @UPLL setup
        ldr     r0, =UPLLCON
300000cc:	e59f0190 	ldr	r0, [pc, #400]	; 30000264 <.text+0x264>
        ldr     r1, =(0x38<<12|0x2<<4|0x2)
300000d0:	e59f1190 	ldr	r1, [pc, #400]	; 30000268 <.text+0x268>
        str     r1, [r0]
300000d4:	e5801000 	str	r1, [r0]
        nop
300000d8:	e1a00000 	nop			(mov r0,r0)
        nop
300000dc:	e1a00000 	nop			(mov r0,r0)
        nop
300000e0:	e1a00000 	nop			(mov r0,r0)
        nop
300000e4:	e1a00000 	nop			(mov r0,r0)
        nop
300000e8:	e1a00000 	nop			(mov r0,r0)
        nop
300000ec:	e1a00000 	nop			(mov r0,r0)
        nop
300000f0:	e1a00000 	nop			(mov r0,r0)

        @MPLL setup
        ldr     r0, =MPLLCON
300000f4:	e59f0170 	ldr	r0, [pc, #368]	; 3000026c <.text+0x26c>
        ldr     r1, =0x7f021
300000f8:	e59f1170 	ldr	r1, [pc, #368]	; 30000270 <.text+0x270>
        str     r1, [r0]
300000fc:	e5801000 	str	r1, [r0]
        nop
30000100:	e1a00000 	nop			(mov r0,r0)
        nop
30000104:	e1a00000 	nop			(mov r0,r0)
        nop
30000108:	e1a00000 	nop			(mov r0,r0)
        nop
3000010c:	e1a00000 	nop			(mov r0,r0)
        nop
30000110:	e1a00000 	nop			(mov r0,r0)
        nop
30000114:	e1a00000 	nop			(mov r0,r0)
        nop
30000118:	e1a00000 	nop			(mov r0,r0)

        @memsetup
        ldr     r0, =0x48000000
3000011c:	e3a00312 	mov	r0, #1207959552	; 0x48000000
        adrl    r1, mem_reg_value
30000120:	e24f10f8 	sub	r1, pc, #248	; 0xf8
30000124:	e1a00000 	nop			(mov r0,r0)
        ldr     r2, =0x48000030
30000128:	e59f2144 	ldr	r2, [pc, #324]	; 30000274 <.text+0x274>

3000012c <loop10>:
loop10:
        ldr     r4, [r1], #4
3000012c:	e4914004 	ldr	r4, [r1], #4
        str     r4, [r0], #4
30000130:	e4804004 	str	r4, [r0], #4
        cmp     r2, r0
30000134:	e1520000 	cmp	r2, r0
        bne     loop10
30000138:	1afffffb 	bne	3000012c <loop10>

        ldr     r0, =GPFDAT
3000013c:	e59f0134 	ldr	r0, [pc, #308]	; 30000278 <.text+0x278>
        mov     r1, #0x50
30000140:	e3a01050 	mov	r1, #80	; 0x50
        str     r1, [r0]
30000144:	e5801000 	str	r1, [r0]

#define GPHCON  0x56000070
#define GPHUP   0x56000078
#define ULCON0  0x50000000
#define UCCON0  0x50000004
#define UFCON0  0x50000008
#define USCON0  0x50000010
#define UTXH0   0x50000020
#define URXH0   0x50000024
#define UBRDIV0 0x50000028

/*Init serial port 0*/
        ldr     r0, =GPHCON
30000148:	e59f012c 	ldr	r0, [pc, #300]	; 3000027c <.text+0x27c>
        ldr     r1, =0xaaa0
3000014c:	e59f112c 	ldr	r1, [pc, #300]	; 30000280 <.text+0x280>
        str     r1, [r0]
30000150:	e5801000 	str	r1, [r0]
        ldr     r0, =GPHUP
30000154:	e59f0128 	ldr	r0, [pc, #296]	; 30000284 <.text+0x284>
        ldr     r1, =0x7ff
30000158:	e59f10f4 	ldr	r1, [pc, #244]	; 30000254 <.text+0x254>
        str     r1, [r0]
3000015c:	e5801000 	str	r1, [r0]
        ldr     r0, =ULCON0
30000160:	e3a00205 	mov	r0, #1342177280	; 0x50000000
        mov     r1, #0x3
30000164:	e3a01003 	mov	r1, #3	; 0x3
        str     r1, [r0]
30000168:	e5801000 	str	r1, [r0]
        ldr     r0, =UCCON0
3000016c:	e3a00245 	mov	r0, #1342177284	; 0x50000004
        mov     r1, #0x5
30000170:	e3a01005 	mov	r1, #5	; 0x5
        str     r1, [r0]
30000174:	e5801000 	str	r1, [r0]
        ldr     r0, =UBRDIV0
30000178:	e59f0108 	ldr	r0, [pc, #264]	; 30000288 <.text+0x288>
        mov     r1, #0x1b
3000017c:	e3a0101b 	mov	r1, #27	; 0x1b
        str     r1, [r0]        /*set baudrate 115200bps*/
30000180:	e5801000 	str	r1, [r0]
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
@ copy code to ram from nand
@
#define NAND_CTL_BASE   0x4e000000
#define oNFCONF         0x0
#define oNFCONT         0x4
#define oNFCMD          0x8
#define oNFSTAT         0x20

        @ reset NAND
        mov     r1, #NAND_CTL_BASE
30000184:	e3a0144e 	mov	r1, #1308622848	; 0x4e000000
        ldr     r2, =( (7<<12)|(7<<8)|(7<<4)|(0<<0) )
30000188:	e59f20fc 	ldr	r2, [pc, #252]	; 3000028c <.text+0x28c>
        str     r2, [r1, #oNFCONF]
3000018c:	e5812000 	str	r2, [r1]
        ldr     r2, [r1, #oNFCONF]
30000190:	e5912000 	ldr	r2, [r1]

        ldr     r2, =( (1<<4)|(0<<1)|(1<<0) ) @ Active low CE Control
30000194:	e3a02011 	mov	r2, #17	; 0x11
        str     r2, [r1, #oNFCONT]
30000198:	e5812004 	str	r2, [r1, #4]
        ldr     r2, [r1, #oNFCONT]
3000019c:	e5912004 	ldr	r2, [r1, #4]

        ldr     r2, =(0x6)              @ RnB Clear
300001a0:	e3a02006 	mov	r2, #6	; 0x6
        str     r2, [r1, #oNFSTAT]
300001a4:	e5812020 	str	r2, [r1, #32]
        ldr     r2, [r1, #oNFSTAT]
300001a8:	e5912020 	ldr	r2, [r1, #32]

        mov     r2, #0xff               @ RESET command
300001ac:	e3a020ff 	mov	r2, #255	; 0xff
        strb    r2, [r1, #oNFCMD]
300001b0:	e5c12008 	strb	r2, [r1, #8]
        mov     r3, #0                  @ wait
300001b4:	e3a03000 	mov	r3, #0	; 0x0
1:      add     r3, r3, #0x1
300001b8:	e2833001 	add	r3, r3, #1	; 0x1
        cmp     r3, #0xa
300001bc:	e353000a 	cmp	r3, #10	; 0xa
        blt     1b
300001c0:	bafffffc 	blt	300001b8 <loop10+0x8c>
2:      ldr     r2, [r1, #oNFSTAT]      @ wait ready
300001c4:	e5912020 	ldr	r2, [r1, #32]
        tst     r2, #0x4
300001c8:	e3120004 	tst	r2, #4	; 0x4
        beq     2b
300001cc:	0afffffc 	beq	300001c4 <loop10+0x98>

        ldr     r2, [r1, #oNFCONT]
300001d0:	e5912004 	ldr	r2, [r1, #4]
        orr     r2, r2, #0x2            @ Flash Memory Chip Disable
300001d4:	e3822002 	orr	r2, r2, #2	; 0x2
        str     r2, [r1, #oNFCONT]
300001d8:	e5812004 	str	r2, [r1, #4]
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	@judge if in steppingstone
	mov	r0, pc
300001dc:	e1a0000f 	mov	r0, pc
	cmp	r0, #0x30000000
300001e0:	e3500203 	cmp	r0, #805306368	; 0x30000000
	bgt	jump_to_ram	@not in steppingstone, already in dram, go without copying nand code
300001e4:	ca00000f 	bgt	30000228 <jump_to_ram>

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

        @ get ready to call C functions (for nand_read())
        @ldr     sp, DW_STACK_START      @ has been setuped at start
        mov     fp, #0                  @ no previous frame, so fp=0
300001e8:	e3a0b000 	mov	fp, #0	; 0x0

#define TEXT_RAM_BASE   0x30000000
#define TEXT_NAND_BASE  0x0
#define TEXT_SIZE       0x100000

        @ copy
        ldr     r0, =TEXT_RAM_BASE
300001ec:	e3a00203 	mov	r0, #805306368	; 0x30000000
        ldr     r1, =TEXT_NAND_BASE
300001f0:	e3a01000 	mov	r1, #0	; 0x0
        ldr     r2, =TEXT_SIZE
300001f4:	e3a02601 	mov	r2, #1048576	; 0x100000
        bl      nand_read_ll
300001f8:	eb000041 	bl	30000304 <nand_read_ll>

        tst     r0, #0x0
300001fc:	e3100000 	tst	r0, #0	; 0x0
        bne     bad_nand_read
30000200:	1a00000d 	bne	3000023c <bad_nand_read>

        @ verify
        mov     r0, #0
30000204:	e3a00000 	mov	r0, #0	; 0x0
        ldr     r1, =TEXT_NAND_BASE
30000208:	e3a01000 	mov	r1, #0	; 0x0
        mov     r2, #0x400      @ 4 bytes * 1024 = 4K-bytes
3000020c:	e3a02b01 	mov	r2, #1024	; 0x400

30000210 <go_next>:
go_next:
        ldr     r3, [r0], #4
30000210:	e4903004 	ldr	r3, [r0], #4
        ldr     r4, [r1], #4
30000214:	e4914004 	ldr	r4, [r1], #4
        teq     r3, r4
30000218:	e1330004 	teq	r3, r4
        bne     bad_nand_read
3000021c:	1a000006 	bne	3000023c <bad_nand_read>
        subs    r2, r2, #4
30000220:	e2522004 	subs	r2, r2, #4	; 0x4
        bne     go_next
30000224:	1afffff9 	bne	30000210 <go_next>

30000228 <jump_to_ram>:
	
	@jump to ram to run
jump_to_ram:
	ldr     r1, =here_is_ram
30000228:	e59f1060 	ldr	r1, [pc, #96]	; 30000290 <.text+0x290>
        add     pc, r1, #0
3000022c:	e281f000 	add	pc, r1, #0	; 0x0
        nop
30000230:	e1a00000 	nop			(mov r0,r0)
        nop
30000234:	e1a00000 	nop			(mov r0,r0)
        b       .              @ infinite loop
30000238:	eafffffe 	b	30000238 <jump_to_ram+0x10>

3000023c <bad_nand_read>:
bad_nand_read:
        mov    	r0, #'E'
3000023c:	e3a00045 	mov	r0, #69	; 0x45
	bl	s3c2440_serial_send_byte
30000240:	eb0001b3 	bl	30000914 <s3c2440_serial_send_byte>
	b	.
30000244:	eafffffe 	b	30000244 <bad_nand_read+0x8>

30000248 <here_is_ram>:

here_is_ram:
        b       main
30000248:	ea000457 	b	300013ac <main>
3000024c:	30101000 	andccs	r1, r0, r0
30000250:	4a000008 	bmi	30000278 <.text+0x278>
30000254:	000007ff 	streqd	r0, [r0], -pc
30000258:	4a00001c 	bmi	300002d0 <nand_reset+0x30>
3000025c:	56000050 	undefined
30000260:	4c000014 	stcmi	0, cr0, [r0], {20}
30000264:	4c000008 	stcmi	0, cr0, [r0], {8}
30000268:	00038022 	andeq	r8, r3, r2, lsr #32
3000026c:	4c000004 	stcmi	0, cr0, [r0], {4}
30000270:	0007f021 	andeq	pc, r7, r1, lsr #32
30000274:	48000030 	stmmida	r0, {r4, r5}
30000278:	56000054 	undefined
3000027c:	56000070 	undefined
30000280:	0000aaa0 	andeq	sl, r0, r0, lsr #21
30000284:	56000078 	undefined
30000288:	50000028 	andpl	r0, r0, r8, lsr #32
3000028c:	00007770 	andeq	r7, r0, r0, ror r7
30000290:	30000248 	andcc	r0, r0, r8, asr #4
30000294:	e1a00000 	nop			(mov r0,r0)
30000298:	e1a00000 	nop			(mov r0,r0)
3000029c:	e1a00000 	nop			(mov r0,r0)

300002a0 <nand_reset>:

void nand_reset()
{
	uint tmp = 10;
	NFCONF = (7<<12)|(7<<8)|(7<<4)|(0<<0);
300002a0:	e59f204c 	ldr	r2, [pc, #76]	; 300002f4 <.text+0x2f4>
300002a4:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
300002a8:	e5832000 	str	r2, [r3]
	NFCONT = (1<<4)|(0<<1)|(1<<0);
300002ac:	e59f3044 	ldr	r3, [pc, #68]	; 300002f8 <.text+0x2f8>
300002b0:	e3a02011 	mov	r2, #17	; 0x11
300002b4:	e5832000 	str	r2, [r3]
	NFSTAT = 0x4;
300002b8:	e59f303c 	ldr	r3, [pc, #60]	; 300002fc <.text+0x2fc>
300002bc:	e3a02004 	mov	r2, #4	; 0x4
300002c0:	e5c32000 	strb	r2, [r3]
	NFCMD = 0xff;
300002c4:	e59f3034 	ldr	r3, [pc, #52]	; 30000300 <.text+0x300>
300002c8:	e3e02000 	mvn	r2, #0	; 0x0
300002cc:	e5c32000 	strb	r2, [r3]
300002d0:	e3a0300a 	mov	r3, #10	; 0xa
	while(tmp--);
300002d4:	e2433001 	sub	r3, r3, #1	; 0x1
300002d8:	e3730001 	cmn	r3, #1	; 0x1
300002dc:	059f2014 	ldreq	r2, [pc, #20]	; 300002f8 <.text+0x2f8>
300002e0:	05923000 	ldreq	r3, [r2]
300002e4:	03833002 	orreq	r3, r3, #2	; 0x2
300002e8:	05823000 	streq	r3, [r2]
300002ec:	01a0f00e 	moveq	pc, lr
300002f0:	eafffff7 	b	300002d4 <nand_reset+0x34>
300002f4:	00007770 	andeq	r7, r0, r0, ror r7
300002f8:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
300002fc:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
30000300:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}

30000304 <nand_read_ll>:
        NAND_CHIP_DISABLE;
}

/* low level nand read function */
int nand_read_ll(unsigned char *buf, unsigned long start_addr, int size)
{
30000304:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
30000308:	e1a04001 	mov	r4, r1
3000030c:	e1a06000 	mov	r6, r0
30000310:	e1a05002 	mov	r5, r2
        int i, j;
	
	lprint("Copy Command:membuf=%x, nandaddr=%x, size=%x\r\n", buf, start_addr, size);
30000314:	e1a03005 	mov	r3, r5
30000318:	e59f00f8 	ldr	r0, [pc, #248]	; 30000418 <.text+0x418>
3000031c:	e1a01006 	mov	r1, r6
30000320:	e1a02004 	mov	r2, r4
30000324:	eb000485 	bl	30001540 <lprint>
        if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK)) {
30000328:	e1a03b84 	mov	r3, r4, lsl #23
3000032c:	e1a03ba3 	mov	r3, r3, lsr #23
30000330:	e3530000 	cmp	r3, #0	; 0x0
30000334:	1a000009 	bne	30000360 <nand_read_ll+0x5c>
30000338:	e1a03b85 	mov	r3, r5, lsl #23
3000033c:	e1a03ba3 	mov	r3, r3, lsr #23
30000340:	e3530000 	cmp	r3, #0	; 0x0
30000344:	1a000005 	bne	30000360 <nand_read_ll+0x5c>
                return -1;      /* invalid alignment */
        }
	if(!(NFSTAT&0x1)){
30000348:	e59f30cc 	ldr	r3, [pc, #204]	; 3000041c <.text+0x41c>
3000034c:	e5d33000 	ldrb	r3, [r3]
30000350:	e3130001 	tst	r3, #1	; 0x1
30000354:	1a000003 	bne	30000368 <nand_read_ll+0x64>
		lprint("nand flash may have some problem, quit!\r\n");
30000358:	e59f00c0 	ldr	r0, [pc, #192]	; 30000420 <.text+0x420>
3000035c:	eb000477 	bl	30001540 <lprint>
		return -1;
30000360:	e3e00000 	mvn	r0, #0	; 0x0
	}

        NAND_CHIP_ENABLE;

        for(i=start_addr; i < (start_addr + size);) {
                /* READ0 */
                NAND_CLEAR_RB;
                NFCMD = 0;

                /* Write Address */
                NFADDR = i & 0xff;
                NFADDR = (i >> 9) & 0xff;
                NFADDR = (i >> 17) & 0xff;
                NFADDR = (i >> 25) & 0xff;

                NAND_DETECT_RB;

                for(j=0; j < NAND_SECTOR_SIZE; j++, i++) {
                        *buf = (NFDATA & 0xff);
                        buf++;
                }
		if(!((i>>9) & 0x3f))
			s3c2440_serial_send_byte('>');
        }
        NAND_CHIP_DISABLE;
        return 0;
}
30000364:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30000368:	e59f20b4 	ldr	r2, [pc, #180]	; 30000424 <.text+0x424>
3000036c:	e5923000 	ldr	r3, [r2]
30000370:	e0845005 	add	r5, r4, r5
30000374:	e3c33002 	bic	r3, r3, #2	; 0x2
30000378:	e1540005 	cmp	r4, r5
3000037c:	e5823000 	str	r3, [r2]
30000380:	2a00001e 	bcs	30000400 <nand_read_ll+0xfc>
30000384:	e59f2090 	ldr	r2, [pc, #144]	; 3000041c <.text+0x41c>
30000388:	e5d23000 	ldrb	r3, [r2]
3000038c:	e3833004 	orr	r3, r3, #4	; 0x4
30000390:	e5c23000 	strb	r3, [r2]
30000394:	e59f108c 	ldr	r1, [pc, #140]	; 30000428 <.text+0x428>
30000398:	e59f308c 	ldr	r3, [pc, #140]	; 3000042c <.text+0x42c>
3000039c:	e1a004c4 	mov	r0, r4, asr #9
300003a0:	e1a0c8c4 	mov	ip, r4, asr #17
300003a4:	e1a0ecc4 	mov	lr, r4, asr #25
300003a8:	e3a02000 	mov	r2, #0	; 0x0
300003ac:	e5c32000 	strb	r2, [r3]
300003b0:	e5c14000 	strb	r4, [r1]
300003b4:	e5c10000 	strb	r0, [r1]
300003b8:	e5c1c000 	strb	ip, [r1]
300003bc:	e5c1e000 	strb	lr, [r1]
300003c0:	e59f3054 	ldr	r3, [pc, #84]	; 3000041c <.text+0x41c>
300003c4:	e5d33000 	ldrb	r3, [r3]
300003c8:	e3130004 	tst	r3, #4	; 0x4
300003cc:	0afffffb 	beq	300003c0 <nand_read_ll+0xbc>
300003d0:	e3a02c02 	mov	r2, #512	; 0x200
300003d4:	e59f3054 	ldr	r3, [pc, #84]	; 30000430 <.text+0x430>
300003d8:	e5d33000 	ldrb	r3, [r3]
300003dc:	e2522001 	subs	r2, r2, #1	; 0x1
300003e0:	e4c63001 	strb	r3, [r6], #1
300003e4:	e2844001 	add	r4, r4, #1	; 0x1
300003e8:	1afffff9 	bne	300003d4 <nand_read_ll+0xd0>
300003ec:	e3140c7e 	tst	r4, #32256	; 0x7e00
300003f0:	03a0003e 	moveq	r0, #62	; 0x3e
300003f4:	0b000146 	bleq	30000914 <s3c2440_serial_send_byte>
300003f8:	e1540005 	cmp	r4, r5
300003fc:	3affffe0 	bcc	30000384 <nand_read_ll+0x80>
30000400:	e59f201c 	ldr	r2, [pc, #28]	; 30000424 <.text+0x424>
30000404:	e5923000 	ldr	r3, [r2]
30000408:	e3a00000 	mov	r0, #0	; 0x0
3000040c:	e3833002 	orr	r3, r3, #2	; 0x2
30000410:	e5823000 	str	r3, [r2]
30000414:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30000418:	300019ec 	andcc	r1, r0, ip, ror #19
3000041c:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
30000420:	30001a1c 	andcc	r1, r0, ip, lsl sl
30000424:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
30000428:	4e00000c 	cdpmi	0, 0, cr0, cr0, cr12, {0}
3000042c:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
30000430:	4e000010 	mcrmi	0, 0, r0, cr0, cr0, {0}

30000434 <random_write_nand>:

#define ERASE_BLOCK_ADDR_MASK (512 * 32 -1)
uint random_write_nand(unsigned char c, uint addr)
{
30000434:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
        NAND_CHIP_ENABLE;
30000438:	e59f20c8 	ldr	r2, [pc, #200]	; 30000508 <.text+0x508>
3000043c:	e5923000 	ldr	r3, [r2]
30000440:	e3c33002 	bic	r3, r3, #2	; 0x2
30000444:	e5823000 	str	r3, [r2]
        NAND_CLEAR_RB;
30000448:	e59f40bc 	ldr	r4, [pc, #188]	; 3000050c <.text+0x50c>
3000044c:	e5d43000 	ldrb	r3, [r4]
	NFCMD = 0x80;
30000450:	e59f60b8 	ldr	r6, [pc, #184]	; 30000510 <.text+0x510>
30000454:	e3833004 	orr	r3, r3, #4	; 0x4
30000458:	e5c43000 	strb	r3, [r4]
3000045c:	e3e0307f 	mvn	r3, #127	; 0x7f
30000460:	e5c63000 	strb	r3, [r6]
        NFADDR = (addr) & 0xff;
30000464:	e59f20a8 	ldr	r2, [pc, #168]	; 30000514 <.text+0x514>
        NFADDR = (addr >> 9) & 0xff;
        NFADDR = (addr >> 17) & 0xff;
        NFADDR = (addr >> 25) & 0xff;
	NFDATA = c;
30000468:	e59f30a8 	ldr	r3, [pc, #168]	; 30000518 <.text+0x518>
3000046c:	e20000ff 	and	r0, r0, #255	; 0xff
30000470:	e1a05ca1 	mov	r5, r1, lsr #25
30000474:	e1a0c4a1 	mov	ip, r1, lsr #9
30000478:	e1a0e8a1 	mov	lr, r1, lsr #17
3000047c:	e5c21000 	strb	r1, [r2]
30000480:	e5c2c000 	strb	ip, [r2]
30000484:	e5c2e000 	strb	lr, [r2]
30000488:	e5c25000 	strb	r5, [r2]
3000048c:	e5c30000 	strb	r0, [r3]
	NFCMD = 0x10;
30000490:	e3a03010 	mov	r3, #16	; 0x10
30000494:	e5c63000 	strb	r3, [r6]
        NAND_DETECT_RB;
30000498:	e59f306c 	ldr	r3, [pc, #108]	; 3000050c <.text+0x50c>
3000049c:	e5d33000 	ldrb	r3, [r3]
300004a0:	e3130004 	tst	r3, #4	; 0x4
300004a4:	0afffffb 	beq	30000498 <random_write_nand+0x64>
	while(!(NFSTAT & 0x1));
300004a8:	e59f305c 	ldr	r3, [pc, #92]	; 3000050c <.text+0x50c>
300004ac:	e5d33000 	ldrb	r3, [r3]
300004b0:	e3130001 	tst	r3, #1	; 0x1
300004b4:	0afffffb 	beq	300004a8 <random_write_nand+0x74>
	NFCMD = 0x70;
300004b8:	e59f3050 	ldr	r3, [pc, #80]	; 30000510 <.text+0x510>
300004bc:	e3a02070 	mov	r2, #112	; 0x70
300004c0:	e5c32000 	strb	r2, [r3]
	if(NFDATA & 0x1){
300004c4:	e59f304c 	ldr	r3, [pc, #76]	; 30000518 <.text+0x518>
300004c8:	e5d33000 	ldrb	r3, [r3]
300004cc:	e2130001 	ands	r0, r3, #1	; 0x1
300004d0:	0a000007 	beq	300004f4 <random_write_nand+0xc0>
		lprint("program failed! may get bad.\r\n");
300004d4:	e59f0040 	ldr	r0, [pc, #64]	; 3000051c <.text+0x51c>
300004d8:	eb000418 	bl	30001540 <lprint>
        	NAND_CHIP_DISABLE;
300004dc:	e59f2024 	ldr	r2, [pc, #36]	; 30000508 <.text+0x508>
300004e0:	e5923000 	ldr	r3, [r2]
		return -1;
300004e4:	e3e00000 	mvn	r0, #0	; 0x0
300004e8:	e3833002 	orr	r3, r3, #2	; 0x2
300004ec:	e5823000 	str	r3, [r2]
	}
        NAND_CHIP_DISABLE;
	return 0;
}
300004f0:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
300004f4:	e59f200c 	ldr	r2, [pc, #12]	; 30000508 <.text+0x508>
300004f8:	e5923000 	ldr	r3, [r2]
300004fc:	e3833002 	orr	r3, r3, #2	; 0x2
30000500:	e5823000 	str	r3, [r2]
30000504:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30000508:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
3000050c:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
30000510:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
30000514:	4e00000c 	cdpmi	0, 0, cr0, cr0, cr12, {0}
30000518:	4e000010 	mcrmi	0, 0, r0, cr0, cr0, {0}
3000051c:	30001a48 	andcc	r1, r0, r8, asr #20

30000520 <random_read_nand>:
uint random_read_nand(uint spare, uint addr)
{
	uint tmd;
	if(spare) 
30000520:	e3500000 	cmp	r0, #0	; 0x0
30000524:	e92d4030 	stmdb	sp!, {r4, r5, lr}
30000528:	e1a04001 	mov	r4, r1
3000052c:	13a05050 	movne	r5, #80	; 0x50
30000530:	1a000002 	bne	30000540 <random_read_nand+0x20>
		tmd = 0x50;
	else if(addr & 0x100)
30000534:	e2113c01 	ands	r3, r1, #256	; 0x100
30000538:	01a05003 	moveq	r5, r3
3000053c:	13a05001 	movne	r5, #1	; 0x1
		tmd = 0x01;
	else	
		tmd = 0;
        NAND_CHIP_ENABLE;
30000540:	e59f2074 	ldr	r2, [pc, #116]	; 300005bc <.text+0x5bc>
30000544:	e5923000 	ldr	r3, [r2]
30000548:	e3c33002 	bic	r3, r3, #2	; 0x2
3000054c:	e5823000 	str	r3, [r2]
        NAND_CLEAR_RB;
30000550:	e59f1068 	ldr	r1, [pc, #104]	; 300005c0 <.text+0x5c0>
30000554:	e5d13000 	ldrb	r3, [r1]
30000558:	e3833004 	orr	r3, r3, #4	; 0x4
3000055c:	e5c13000 	strb	r3, [r1]
	NFCMD = tmd;
        NFADDR = (addr) & 0xff;
30000560:	e59f205c 	ldr	r2, [pc, #92]	; 300005c4 <.text+0x5c4>
30000564:	e59f305c 	ldr	r3, [pc, #92]	; 300005c8 <.text+0x5c8>
        NFADDR = (addr >> 9) & 0xff;
        NFADDR = (addr >> 17) & 0xff;
        NFADDR = (addr >> 25) & 0xff;
30000568:	e1a0eca4 	mov	lr, r4, lsr #25
3000056c:	e1a004a4 	mov	r0, r4, lsr #9
30000570:	e1a0c8a4 	mov	ip, r4, lsr #17
30000574:	e5c35000 	strb	r5, [r3]
30000578:	e5c24000 	strb	r4, [r2]
3000057c:	e5c20000 	strb	r0, [r2]
30000580:	e5c2c000 	strb	ip, [r2]
30000584:	e5c2e000 	strb	lr, [r2]
        NAND_DETECT_RB;
30000588:	e59f3030 	ldr	r3, [pc, #48]	; 300005c0 <.text+0x5c0>
3000058c:	e5d33000 	ldrb	r3, [r3]
30000590:	e3130004 	tst	r3, #4	; 0x4
30000594:	0afffffb 	beq	30000588 <random_read_nand+0x68>
	tmd =  NFDATA & 0xff;
30000598:	e59f302c 	ldr	r3, [pc, #44]	; 300005cc <.text+0x5cc>
        NAND_CHIP_DISABLE;
3000059c:	e59f1018 	ldr	r1, [pc, #24]	; 300005bc <.text+0x5bc>
300005a0:	e5d32000 	ldrb	r2, [r3]
300005a4:	e5913000 	ldr	r3, [r1]
300005a8:	e20250ff 	and	r5, r2, #255	; 0xff
300005ac:	e3833002 	orr	r3, r3, #2	; 0x2
	return tmd;
}
300005b0:	e1a00005 	mov	r0, r5
300005b4:	e5813000 	str	r3, [r1]
300005b8:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
300005bc:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
300005c0:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
300005c4:	4e00000c 	cdpmi	0, 0, cr0, cr0, cr12, {0}
300005c8:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
300005cc:	4e000010 	mcrmi	0, 0, r0, cr0, cr0, {0}

300005d0 <is_marked_bad_block>:
	
int is_marked_bad_block(uint addr)
{
300005d0:	e92d4010 	stmdb	sp!, {r4, lr}
	unsigned char a;
	uint i;

	addr &= ~ERASE_BLOCK_ADDR_MASK;
        if(!(NFSTAT&0x1)){
300005d4:	e59f3064 	ldr	r3, [pc, #100]	; 30000640 <.text+0x640>
300005d8:	e1a04000 	mov	r4, r0
300005dc:	e5d33000 	ldrb	r3, [r3]
300005e0:	e3c44dff 	bic	r4, r4, #16320	; 0x3fc0
300005e4:	e3c4403f 	bic	r4, r4, #63	; 0x3f
300005e8:	e3130001 	tst	r3, #1	; 0x1
300005ec:	e59f0050 	ldr	r0, [pc, #80]	; 30000644 <.text+0x644>
300005f0:	e2841005 	add	r1, r4, #5	; 0x5
300005f4:	1a000002 	bne	30000604 <is_marked_bad_block+0x34>
                lprint("nand flash may have some problem, quit!\r\n");
300005f8:	eb0003d0 	bl	30001540 <lprint>
                return -1;
300005fc:	e3e03000 	mvn	r3, #0	; 0x0
30000600:	ea00000c 	b	30000638 <is_marked_bad_block+0x68>
        }
	if(random_read_nand(1, addr+5) != 0xff || 
30000604:	e3a00001 	mov	r0, #1	; 0x1
30000608:	ebffffc4 	bl	30000520 <random_read_nand>
3000060c:	e1a03000 	mov	r3, r0
30000610:	e2841f81 	add	r1, r4, #516	; 0x204
30000614:	e35300ff 	cmp	r3, #255	; 0xff
30000618:	e2811001 	add	r1, r1, #1	; 0x1
3000061c:	e3a00001 	mov	r0, #1	; 0x1
30000620:	1a000003 	bne	30000634 <is_marked_bad_block+0x64>
30000624:	ebffffbd 	bl	30000520 <random_read_nand>
30000628:	e35000ff 	cmp	r0, #255	; 0xff
3000062c:	e3a03000 	mov	r3, #0	; 0x0
30000630:	0a000000 	beq	30000638 <is_marked_bad_block+0x68>
		random_read_nand(1, addr+5+512) != 0xff)
		return 1;
30000634:	e3a03001 	mov	r3, #1	; 0x1

	return 0;	
}
30000638:	e1a00003 	mov	r0, r3
3000063c:	e8bd8010 	ldmia	sp!, {r4, pc}
30000640:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
30000644:	30001a1c 	andcc	r1, r0, ip, lsl sl

30000648 <nand_erase_ll>:

#if 0
int is_marked_bad_block(uint addr)
{
	unsigned char a;
	uint i;

	addr &= ~ERASE_BLOCK_ADDR_MASK;
        if(!(NFSTAT&0x1)){
                lprint("nand flash may have some problem, quit!\r\n");
                return -1;
        }
        NAND_CHIP_ENABLE;
        NAND_CLEAR_RB;
	NFCMD = 0x50;
        NFADDR = (addr) & 0xff;
        NFADDR = (addr >> 9) & 0xff;
        NFADDR = (addr >> 17) & 0xff;
        NFADDR = (addr >> 25) & 0xff;
        NAND_DETECT_RB;
	i = 5;
	while(i--){
		a = NFDATA;
#ifdef NAND_DEBUG
		lprint("%x\r\n", a);
#endif  
	}
	a = NFDATA;
#ifdef NAND_DEBUG
	lprint("%x\r\n", a);
#endif  
	if(a != 0xff){
#ifdef NAND_DEBUG
		lprint("marded bad\r\n");
#endif  
		return 1;
	}
	i = 15;
	while(i--){
		a = NFDATA;
#ifdef NAND_DEBUG
		lprint("%x\r\n", a);
#endif  
	}
	a = NFDATA;
#ifdef NAND_DEBUG
	lprint("%x\r\n", a);
#endif  
	if(a != 0xff){
#ifdef NAND_DEBUG
		lprint("marded bad\r\n");
#endif  
		return 1;
	}
	i = 10;
	while(i--){
		a = NFDATA;
#ifdef NAND_DEBUG
		lprint("%x\r\n", a);
#endif  
	}
#ifdef NAND_DEBUG
	lprint("not marked bad\r\n");
#endif  
        NAND_CHIP_DISABLE;
	return 0;	
}
#endif /*if 0*/

int nand_erase_ll(uint addr)
{
30000648:	e92d4030 	stmdb	sp!, {r4, r5, lr}
        lprint("Erase Command:addr=%x\r\n", addr);
3000064c:	e1a01000 	mov	r1, r0
30000650:	e1a04000 	mov	r4, r0
30000654:	e59f00ec 	ldr	r0, [pc, #236]	; 30000748 <.text+0x748>
30000658:	eb0003b8 	bl	30001540 <lprint>
	if(addr & ERASE_BLOCK_ADDR_MASK){
3000065c:	e1a03904 	mov	r3, r4, lsl #18
30000660:	e1a03923 	mov	r3, r3, lsr #18
30000664:	e3530000 	cmp	r3, #0	; 0x0
30000668:	159f00dc 	ldrne	r0, [pc, #220]	; 3000074c <.text+0x74c>
3000066c:	1a000004 	bne	30000684 <nand_erase_ll+0x3c>
		lprint("erase addr not correct!\r\n");
		return -1;
	}	
        if(!(NFSTAT&0x1)){
30000670:	e59f50d8 	ldr	r5, [pc, #216]	; 30000750 <.text+0x750>
30000674:	e5d53000 	ldrb	r3, [r5]
30000678:	e3130001 	tst	r3, #1	; 0x1
3000067c:	1a000003 	bne	30000690 <nand_erase_ll+0x48>
                lprint("nand flash may have some problem, quit!\r\n");
30000680:	e59f00cc 	ldr	r0, [pc, #204]	; 30000754 <.text+0x754>
30000684:	eb0003ad 	bl	30001540 <lprint>
                return -1;
30000688:	e3e00000 	mvn	r0, #0	; 0x0
        }
/*
	if(is_marked_bad_block(addr)){
                lprint("block %x is bad block, quit!\r\n",addr);
                return -1;
	}
*/
        NAND_CHIP_ENABLE;
        NAND_CLEAR_RB;
	NFCMD = 0x60;
        NFADDR = (addr >> 9) & 0xff;
        NFADDR = (addr >> 17) & 0xff;
        NFADDR = (addr >> 25) & 0xff;
	NFCMD = 0xd0;
	while(!(NFSTAT & 0x1)){
#ifdef NAND_DEBUG
		lprint("%x\r\n", NFSTAT);
#endif	
	}
	NFCMD = 0x70;
	if(NFDATA & 0x1){
		lprint("erase failed! may get bad.\r\n");
        	NAND_CHIP_DISABLE;
		return -1;
	}
	lprint("erase successfully! \r\n");
        NAND_CHIP_DISABLE;
	return 0;
}
3000068c:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30000690:	e59f20c0 	ldr	r2, [pc, #192]	; 30000758 <.text+0x758>
30000694:	e5923000 	ldr	r3, [r2]
30000698:	e3c33002 	bic	r3, r3, #2	; 0x2
3000069c:	e5823000 	str	r3, [r2]
300006a0:	e5d53000 	ldrb	r3, [r5]
300006a4:	e59fc0b0 	ldr	ip, [pc, #176]	; 3000075c <.text+0x75c>
300006a8:	e3833004 	orr	r3, r3, #4	; 0x4
300006ac:	e5c53000 	strb	r3, [r5]
300006b0:	e59f20a8 	ldr	r2, [pc, #168]	; 30000760 <.text+0x760>
300006b4:	e3a03060 	mov	r3, #96	; 0x60
300006b8:	e5cc3000 	strb	r3, [ip]
300006bc:	e1a0eca4 	mov	lr, r4, lsr #25
300006c0:	e1a014a4 	mov	r1, r4, lsr #9
300006c4:	e1a008a4 	mov	r0, r4, lsr #17
300006c8:	e3e0302f 	mvn	r3, #47	; 0x2f
300006cc:	e5c21000 	strb	r1, [r2]
300006d0:	e5c20000 	strb	r0, [r2]
300006d4:	e5c2e000 	strb	lr, [r2]
300006d8:	e5cc3000 	strb	r3, [ip]
300006dc:	e59f306c 	ldr	r3, [pc, #108]	; 30000750 <.text+0x750>
300006e0:	e5d33000 	ldrb	r3, [r3]
300006e4:	e3130001 	tst	r3, #1	; 0x1
300006e8:	0afffffb 	beq	300006dc <nand_erase_ll+0x94>
300006ec:	e59f3068 	ldr	r3, [pc, #104]	; 3000075c <.text+0x75c>
300006f0:	e3a02070 	mov	r2, #112	; 0x70
300006f4:	e5c32000 	strb	r2, [r3]
300006f8:	e59f3064 	ldr	r3, [pc, #100]	; 30000764 <.text+0x764>
300006fc:	e5d33000 	ldrb	r3, [r3]
30000700:	e2134001 	ands	r4, r3, #1	; 0x1
30000704:	0a000007 	beq	30000728 <nand_erase_ll+0xe0>
30000708:	e59f0058 	ldr	r0, [pc, #88]	; 30000768 <.text+0x768>
3000070c:	eb00038b 	bl	30001540 <lprint>
30000710:	e59f2040 	ldr	r2, [pc, #64]	; 30000758 <.text+0x758>
30000714:	e5923000 	ldr	r3, [r2]
30000718:	e3e00000 	mvn	r0, #0	; 0x0
3000071c:	e3833002 	orr	r3, r3, #2	; 0x2
30000720:	e5823000 	str	r3, [r2]
30000724:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30000728:	e59f003c 	ldr	r0, [pc, #60]	; 3000076c <.text+0x76c>
3000072c:	eb000383 	bl	30001540 <lprint>
30000730:	e59f2020 	ldr	r2, [pc, #32]	; 30000758 <.text+0x758>
30000734:	e5923000 	ldr	r3, [r2]
30000738:	e1a00004 	mov	r0, r4
3000073c:	e3833002 	orr	r3, r3, #2	; 0x2
30000740:	e5823000 	str	r3, [r2]
30000744:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30000748:	30001a68 	andcc	r1, r0, r8, ror #20
3000074c:	30001a80 	andcc	r1, r0, r0, lsl #21
30000750:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
30000754:	30001a1c 	andcc	r1, r0, ip, lsl sl
30000758:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
3000075c:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
30000760:	4e00000c 	cdpmi	0, 0, cr0, cr0, cr12, {0}
30000764:	4e000010 	mcrmi	0, 0, r0, cr0, cr0, {0}
30000768:	30001a9c 	mulcc	r0, ip, sl
3000076c:	30001abc 	strcch	r1, [r0], -ip

30000770 <nand_write_ll>:

int nand_write_ll(unsigned char *buf, unsigned long start_addr, int size)
{
30000770:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
30000774:	e1a04001 	mov	r4, r1
30000778:	e1a06000 	mov	r6, r0
3000077c:	e1a05002 	mov	r5, r2
        uint i, j;

        lprint("Write Command:membuf=%x, nandaddr=%x, size=%x\r\n", buf, start_addr, size);
30000780:	e1a03005 	mov	r3, r5
30000784:	e59f0164 	ldr	r0, [pc, #356]	; 300008f0 <.text+0x8f0>
30000788:	e1a01006 	mov	r1, r6
3000078c:	e1a02004 	mov	r2, r4
30000790:	eb00036a 	bl	30001540 <lprint>
        if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK)) {
30000794:	e1a03b84 	mov	r3, r4, lsl #23
30000798:	e1a03ba3 	mov	r3, r3, lsr #23
3000079c:	e3530000 	cmp	r3, #0	; 0x0
300007a0:	1a000009 	bne	300007cc <nand_write_ll+0x5c>
300007a4:	e1a03b85 	mov	r3, r5, lsl #23
300007a8:	e1a03ba3 	mov	r3, r3, lsr #23
300007ac:	e3530000 	cmp	r3, #0	; 0x0
300007b0:	1a000005 	bne	300007cc <nand_write_ll+0x5c>
                return -1;      /* invalid alignment */
        }
        if(!(NFSTAT&0x1)){
300007b4:	e59f3138 	ldr	r3, [pc, #312]	; 300008f4 <.text+0x8f4>
300007b8:	e5d33000 	ldrb	r3, [r3]
300007bc:	e3130001 	tst	r3, #1	; 0x1
300007c0:	1a00000e 	bne	30000800 <nand_write_ll+0x90>
                lprint("nand flash may have some problem, quit!\r\n");
300007c4:	e59f012c 	ldr	r0, [pc, #300]	; 300008f8 <.text+0x8f8>
300007c8:	eb00035c 	bl	30001540 <lprint>
                return -1;
300007cc:	e3e00000 	mvn	r0, #0	; 0x0
        }

        NAND_CHIP_ENABLE;

        for(i=start_addr; i < (start_addr + size);) {
                /* READ0 */
                NAND_CLEAR_RB;
                NFCMD = 0x80;

                /* Write Address */
                NFADDR = i & 0xff;
                NFADDR = (i >> 9) & 0xff;
                NFADDR = (i >> 17) & 0xff;
                NFADDR = (i >> 25) & 0xff;


                for(j=0; j < NAND_SECTOR_SIZE; j++, i++) {
                        NFDATA = *buf++;
                }
		NFCMD = 0x10;
        	NAND_DETECT_RB;
		
		while(!NFSTAT&0x1);
		NFCMD = 0x70;
		if(NFDATA & 0x1){
			lprint("current block(%x)program failed! may get bad.\r\n", (i-512)&~ERASE_BLOCK_ADDR_MASK);
        		NAND_CHIP_DISABLE;
			return -1;
		}	
		
                if(!((i>>9) & 0x3f))
                        s3c2440_serial_send_byte('<');
        }
        NAND_CHIP_DISABLE;
        return 0;
}
300007d0:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
300007d4:	e2441c02 	sub	r1, r4, #512	; 0x200
300007d8:	e3c11dff 	bic	r1, r1, #16320	; 0x3fc0
300007dc:	e3c1103f 	bic	r1, r1, #63	; 0x3f
300007e0:	e59f0114 	ldr	r0, [pc, #276]	; 300008fc <.text+0x8fc>
300007e4:	eb000355 	bl	30001540 <lprint>
300007e8:	e59f2110 	ldr	r2, [pc, #272]	; 30000900 <.text+0x900>
300007ec:	e5923000 	ldr	r3, [r2]
300007f0:	e3e00000 	mvn	r0, #0	; 0x0
300007f4:	e3833002 	orr	r3, r3, #2	; 0x2
300007f8:	e5823000 	str	r3, [r2]
300007fc:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30000800:	e59f20f8 	ldr	r2, [pc, #248]	; 30000900 <.text+0x900>
30000804:	e5923000 	ldr	r3, [r2]
30000808:	e0845005 	add	r5, r4, r5
3000080c:	e3c33002 	bic	r3, r3, #2	; 0x2
30000810:	e1540005 	cmp	r4, r5
30000814:	e5823000 	str	r3, [r2]
30000818:	2a00002e 	bcs	300008d8 <nand_write_ll+0x168>
3000081c:	e59f20d0 	ldr	r2, [pc, #208]	; 300008f4 <.text+0x8f4>
30000820:	e5d23000 	ldrb	r3, [r2]
30000824:	e3833004 	orr	r3, r3, #4	; 0x4
30000828:	e5c23000 	strb	r3, [r2]
3000082c:	e59f10d0 	ldr	r1, [pc, #208]	; 30000904 <.text+0x904>
30000830:	e59f30d0 	ldr	r3, [pc, #208]	; 30000908 <.text+0x908>
30000834:	e1a004a4 	mov	r0, r4, lsr #9
30000838:	e3e0207f 	mvn	r2, #127	; 0x7f
3000083c:	e5c32000 	strb	r2, [r3]
30000840:	e1a0c8a4 	mov	ip, r4, lsr #17
30000844:	e5c14000 	strb	r4, [r1]
30000848:	e1a0eca4 	mov	lr, r4, lsr #25
3000084c:	e5c10000 	strb	r0, [r1]
30000850:	e59f00b4 	ldr	r0, [pc, #180]	; 3000090c <.text+0x90c>
30000854:	e5c1c000 	strb	ip, [r1]
30000858:	e5c1e000 	strb	lr, [r1]
3000085c:	e3a01000 	mov	r1, #0	; 0x0
30000860:	e4d62001 	ldrb	r2, [r6], #1
30000864:	e2811001 	add	r1, r1, #1	; 0x1
30000868:	e59f30a0 	ldr	r3, [pc, #160]	; 30000910 <.text+0x910>
3000086c:	e1510000 	cmp	r1, r0
30000870:	e5c32000 	strb	r2, [r3]
30000874:	e2844001 	add	r4, r4, #1	; 0x1
30000878:	9afffff8 	bls	30000860 <nand_write_ll+0xf0>
3000087c:	e59f3084 	ldr	r3, [pc, #132]	; 30000908 <.text+0x908>
30000880:	e3a02010 	mov	r2, #16	; 0x10
30000884:	e5c32000 	strb	r2, [r3]
30000888:	e59f3064 	ldr	r3, [pc, #100]	; 300008f4 <.text+0x8f4>
3000088c:	e5d33000 	ldrb	r3, [r3]
30000890:	e3130004 	tst	r3, #4	; 0x4
30000894:	0afffffb 	beq	30000888 <nand_write_ll+0x118>
30000898:	e59f3054 	ldr	r3, [pc, #84]	; 300008f4 <.text+0x8f4>
3000089c:	e5d33000 	ldrb	r3, [r3]
300008a0:	e3530000 	cmp	r3, #0	; 0x0
300008a4:	0afffffb 	beq	30000898 <nand_write_ll+0x128>
300008a8:	e59f3058 	ldr	r3, [pc, #88]	; 30000908 <.text+0x908>
300008ac:	e3a02070 	mov	r2, #112	; 0x70
300008b0:	e5c32000 	strb	r2, [r3]
300008b4:	e59f3054 	ldr	r3, [pc, #84]	; 30000910 <.text+0x910>
300008b8:	e5d33000 	ldrb	r3, [r3]
300008bc:	e3130001 	tst	r3, #1	; 0x1
300008c0:	1affffc3 	bne	300007d4 <nand_write_ll+0x64>
300008c4:	e3140c7e 	tst	r4, #32256	; 0x7e00
300008c8:	03a0003c 	moveq	r0, #60	; 0x3c
300008cc:	0b000010 	bleq	30000914 <s3c2440_serial_send_byte>
300008d0:	e1540005 	cmp	r4, r5
300008d4:	3affffd0 	bcc	3000081c <nand_write_ll+0xac>
300008d8:	e59f2020 	ldr	r2, [pc, #32]	; 30000900 <.text+0x900>
300008dc:	e5923000 	ldr	r3, [r2]
300008e0:	e3a00000 	mov	r0, #0	; 0x0
300008e4:	e3833002 	orr	r3, r3, #2	; 0x2
300008e8:	e5823000 	str	r3, [r2]
300008ec:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
300008f0:	30001ad4 	ldrccd	r1, [r0], -r4
300008f4:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
300008f8:	30001a1c 	andcc	r1, r0, ip, lsl sl
300008fc:	30001b04 	andcc	r1, r0, r4, lsl #22
30000900:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
30000904:	4e00000c 	cdpmi	0, 0, cr0, cr0, cr12, {0}
30000908:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
3000090c:	000001ff 	streqd	r0, [r0], -pc
30000910:	4e000010 	mcrmi	0, 0, r0, cr0, cr0, {0}

30000914 <s3c2440_serial_send_byte>:
                    

/*
void s3c2440_serial_init(){
	GPHCON = 0xaaa0;
	GPHUP = 0x7ff;
	ULCON0 = 0x3;
	UCCON0 = 0x5;
	UBRDIV0 = 18;//set bautrate 9600bps
}
*/
void s3c2440_serial_send_byte(unsigned char c)
{
30000914:	e20000ff 	and	r0, r0, #255	; 0xff
        while(!(USCON0 & 0x2));
30000918:	e59f3014 	ldr	r3, [pc, #20]	; 30000934 <.text+0x934>
3000091c:	e5933000 	ldr	r3, [r3]
30000920:	e3130002 	tst	r3, #2	; 0x2
30000924:	159f300c 	ldrne	r3, [pc, #12]	; 30000938 <.text+0x938>
30000928:	15830000 	strne	r0, [r3]
3000092c:	11a0f00e 	movne	pc, lr
30000930:	eafffff8 	b	30000918 <s3c2440_serial_send_byte+0x4>
30000934:	50000010 	andpl	r0, r0, r0, lsl r0
30000938:	50000020 	andpl	r0, r0, r0, lsr #32

3000093c <s3c2440_serial_recv_byte>:
        UTXH0 = c;
}

unsigned char s3c2440_serial_recv_byte()
{
        while(!(USCON0 & 0x1));
3000093c:	e59f3018 	ldr	r3, [pc, #24]	; 3000095c <.text+0x95c>
30000940:	e5933000 	ldr	r3, [r3]
30000944:	e3130001 	tst	r3, #1	; 0x1
30000948:	159f3010 	ldrne	r3, [pc, #16]	; 30000960 <.text+0x960>
3000094c:	15930000 	ldrne	r0, [r3]
30000950:	120000ff 	andne	r0, r0, #255	; 0xff
        return URXH0;
}
30000954:	11a0f00e 	movne	pc, lr
30000958:	eafffff7 	b	3000093c <s3c2440_serial_recv_byte>
3000095c:	50000010 	andpl	r0, r0, r0, lsl r0
30000960:	50000024 	andpl	r0, r0, r4, lsr #32

30000964 <s3c2440_is_serial_recv>:

uint s3c2440_is_serial_recv()
{
	return (USCON0 & 0x1);
30000964:	e59f3008 	ldr	r3, [pc, #8]	; 30000974 <.text+0x974>
30000968:	e5930000 	ldr	r0, [r3]
3000096c:	e2000001 	and	r0, r0, #1	; 0x1
}
30000970:	e1a0f00e 	mov	pc, lr
30000974:	50000010 	andpl	r0, r0, r0, lsl r0

30000978 <ndchkbb>:
};
static uint * mrw_addr = 0x0;

void ndchkbb(unsigned char *para)
{
30000978:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
	uint i, addr, marked_bad = 0, addr_list[16];
	lprint("I will check all block(0 - 0x%x) on current K9f1208 and find out all marked bad block, please wait!\r\n", 0x4000 * 4096);
3000097c:	e59f0090 	ldr	r0, [pc, #144]	; 30000a14 <.text+0xa14>
30000980:	e24dd040 	sub	sp, sp, #64	; 0x40
30000984:	e3a01301 	mov	r1, #67108864	; 0x4000000
30000988:	eb0002ec 	bl	30001540 <lprint>
3000098c:	e3a04000 	mov	r4, #0	; 0x0
	i = 4096;
	addr = 0;
	while(i--){
30000990:	e59f6080 	ldr	r6, [pc, #128]	; 30000a18 <.text+0xa18>
30000994:	e1a05004 	mov	r5, r4
		if(is_marked_bad_block(addr)){
30000998:	e1a00005 	mov	r0, r5
3000099c:	ebffff0b 	bl	300005d0 <is_marked_bad_block>
300009a0:	e28d1040 	add	r1, sp, #64	; 0x40
300009a4:	e1a03000 	mov	r3, r0
300009a8:	e3530000 	cmp	r3, #0	; 0x0
300009ac:	e0812104 	add	r2, r1, r4, lsl #2
			addr_list[marked_bad++] = addr;
300009b0:	15025040 	strne	r5, [r2, #-64]
300009b4:	e3a00058 	mov	r0, #88	; 0x58
			con_send('X');
		}
		else
			con_send('O');
		addr += 0x4000;
300009b8:	e2466001 	sub	r6, r6, #1	; 0x1
300009bc:	03a0004f 	moveq	r0, #79	; 0x4f
300009c0:	12844001 	addne	r4, r4, #1	; 0x1
300009c4:	ebffffd2 	bl	30000914 <s3c2440_serial_send_byte>
300009c8:	e3760001 	cmn	r6, #1	; 0x1
300009cc:	e2855901 	add	r5, r5, #16384	; 0x4000
300009d0:	1afffff0 	bne	30000998 <ndchkbb+0x20>
	}	
	lprint("\r\ncheck over! %x blocks bad.\r\n", marked_bad);
300009d4:	e1a01004 	mov	r1, r4
300009d8:	e59f003c 	ldr	r0, [pc, #60]	; 30000a1c <.text+0xa1c>
	i = 0;
	while(marked_bad--)
300009dc:	e2444001 	sub	r4, r4, #1	; 0x1
300009e0:	eb0002d6 	bl	30001540 <lprint>
300009e4:	e3740001 	cmn	r4, #1	; 0x1
300009e8:	0a000007 	beq	30000a0c <ndchkbb+0x94>
300009ec:	e28d5040 	add	r5, sp, #64	; 0x40
		lprint("%x\r\n", addr_list[i++]); 
300009f0:	e5151040 	ldr	r1, [r5, #-64]
300009f4:	e59f0024 	ldr	r0, [pc, #36]	; 30000a20 <.text+0xa20>
300009f8:	e2444001 	sub	r4, r4, #1	; 0x1
300009fc:	eb0002cf 	bl	30001540 <lprint>
30000a00:	e3740001 	cmn	r4, #1	; 0x1
30000a04:	e2855004 	add	r5, r5, #4	; 0x4
30000a08:	1afffff8 	bne	300009f0 <ndchkbb+0x78>
30000a0c:	e28dd040 	add	sp, sp, #64	; 0x40
30000a10:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30000a14:	30001d48 	andcc	r1, r0, r8, asr #26
30000a18:	00000fff 	streqd	r0, [r0], -pc
30000a1c:	30001db0 	strcch	r1, [r0], -r0
30000a20:	30002180 	andcc	r2, r0, r0, lsl #3

30000a24 <go>:
}

void go(unsigned char *para)
{
30000a24:	e52de004 	str	lr, [sp, #-4]!
	lprint("This will go at the addr you just used with the 'r' cmd. Any problem please check!\r\n");
30000a28:	e59f0010 	ldr	r0, [pc, #16]	; 30000a40 <.text+0xa40>
30000a2c:	eb0002c3 	bl	30001540 <lprint>
	(*((void (*)())mrw_addr))();
30000a30:	e59f300c 	ldr	r3, [pc, #12]	; 30000a44 <.text+0xa44>
30000a34:	e1a0e00f 	mov	lr, pc
30000a38:	e593f000 	ldr	pc, [r3]
30000a3c:	e49df004 	ldr	pc, [sp], #4
30000a40:	30001dd0 	ldrccd	r1, [r0], -r0
30000a44:	30002450 	andcc	r2, r0, r0, asr r4

30000a48 <put_file_by_serial>:
}

void put_file_by_serial(unsigned char *p)
{
30000a48:	e92d4010 	stmdb	sp!, {r4, lr}
    uint length = 0x80, tmp, i;
30000a4c:	e3a03080 	mov	r3, #128	; 0x80
30000a50:	e24dd004 	sub	sp, sp, #4	; 0x4
30000a54:	e58d3000 	str	r3, [sp]
30000a58:	e1a04000 	mov	r4, r0

    tmp = get_howmany_para(p);
30000a5c:	eb000053 	bl	30000bb0 <get_howmany_para>
    if( tmp > 1)
30000a60:	e3500001 	cmp	r0, #1	; 0x1
30000a64:	e1a03000 	mov	r3, r0
30000a68:	8a00000e 	bhi	30000aa8 <put_file_by_serial+0x60>
        goto error;
    if(tmp == 0)
30000a6c:	e3530000 	cmp	r3, #0	; 0x0
30000a70:	e1a00004 	mov	r0, r4
30000a74:	e1a0100d 	mov	r1, sp
30000a78:	0a000005 	beq	30000a94 <put_file_by_serial+0x4c>
        goto modemsend;
    str_to_hex(p, &length);
30000a7c:	eb000061 	bl	30000c08 <str_to_hex>
    length >>= 7;
30000a80:	e59d3000 	ldr	r3, [sp]
30000a84:	e1a033a3 	mov	r3, r3, lsr #7
    if(!length)
30000a88:	e3530000 	cmp	r3, #0	; 0x0
30000a8c:	e58d3000 	str	r3, [sp]
30000a90:	0a000004 	beq	30000aa8 <put_file_by_serial+0x60>
	goto error;
modemsend:
	xmodem_1k_send((unsigned char*)mrw_addr, length);
30000a94:	e59f301c 	ldr	r3, [pc, #28]	; 30000ab8 <.text+0xab8>
30000a98:	e59d1000 	ldr	r1, [sp]
30000a9c:	e5930000 	ldr	r0, [r3]
30000aa0:	eb000355 	bl	300017fc <xmodem_1k_send>
	return;
30000aa4:	ea000001 	b	30000ab0 <put_file_by_serial+0x68>
error:
    lprint("Error para!\r\npfbs [length(0x80bytes x n)](default 0x80(16k) if no this argu)\r\n");
30000aa8:	e59f000c 	ldr	r0, [pc, #12]	; 30000abc <.text+0xabc>
30000aac:	eb0002a3 	bl	30001540 <lprint>
} 
30000ab0:	e28dd004 	add	sp, sp, #4	; 0x4
30000ab4:	e8bd8010 	ldmia	sp!, {r4, pc}
30000ab8:	30002450 	andcc	r2, r0, r0, asr r4
30000abc:	30001e28 	andcc	r1, r0, r8, lsr #28

30000ac0 <get_file_by_serial>:

void get_file_by_serial(unsigned char *para)
{
30000ac0:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
30000ac4:	e1a05000 	mov	r5, r0
	uint tmp;
	lprint("if any other para after 'go', the file will auto go 15s later or any key!\r\n");
30000ac8:	e59f0038 	ldr	r0, [pc, #56]	; 30000b08 <.text+0xb08>
30000acc:	eb00029b 	bl	30001540 <lprint>
    	tmp = get_howmany_para(para);
30000ad0:	e1a00005 	mov	r0, r5
30000ad4:	eb000035 	bl	30000bb0 <get_howmany_para>
	xmodem_1k_recv((unsigned char*)mrw_addr);
30000ad8:	e59f602c 	ldr	r6, [pc, #44]	; 30000b0c <.text+0xb0c>
30000adc:	e1a04000 	mov	r4, r0
30000ae0:	e5960000 	ldr	r0, [r6]
30000ae4:	eb0002ed 	bl	300016a0 <xmodem_1k_recv>
	if(tmp != 0){
30000ae8:	e3540000 	cmp	r4, #0	; 0x0
30000aec:	e1a01005 	mov	r1, r5
30000af0:	e3a00503 	mov	r0, #12582912	; 0xc00000
30000af4:	08bd8070 	ldmeqia	sp!, {r4, r5, r6, pc}
                time_limit_recv_byte(0xc00000, para);
30000af8:	eb0002d6 	bl	30001658 <time_limit_recv_byte>
		(*((void (*)())mrw_addr))();
30000afc:	e1a0e00f 	mov	lr, pc
30000b00:	e596f000 	ldr	pc, [r6]
	}
		

/*
	uint i = 1028, tmp = 0x20000, repeat = 36;
	unsigned char *c = (unsigned char*const)0xbf4;

	lprint("\r\nNow start(*0xbf4 = 0 will be test):\r\n\r\n");
	if(*c)
		con_send(0x15);
	else
		lprint("\r\nTest, time is up!\r\n");
	while(tmp--)
		if(is_con_recv())
			break;
	while(i--)
		*c++ = con_recv();
	con_send(0x06);
	*c++ = con_recv();
	con_send(0x06);
*/
}
30000b04:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30000b08:	30001e78 	andcc	r1, r0, r8, ror lr
30000b0c:	30002450 	andcc	r2, r0, r0, asr r4

30000b10 <print_help>:

void print_help(unsigned char *para)
{
30000b10:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    uint i = 0;
    lprint("Clean Boot V%s\r\nAvailable cmd is:\r\n\r\n", CLEAN_BOOT_VERSION);
30000b14:	e59f0044 	ldr	r0, [pc, #68]	; 30000b60 <.text+0xb60>
30000b18:	e59f1044 	ldr	r1, [pc, #68]	; 30000b64 <.text+0xb64>
30000b1c:	eb000287 	bl	30001540 <lprint>
    while(1){
30000b20:	e59f5040 	ldr	r5, [pc, #64]	; 30000b68 <.text+0xb68>
30000b24:	e3a04000 	mov	r4, #0	; 0x0
            if(cmd_list[i].cmd_name == NULL)
30000b28:	e59f3038 	ldr	r3, [pc, #56]	; 30000b68 <.text+0xb68>
30000b2c:	e7943003 	ldr	r3, [r4, r3]
30000b30:	e3530000 	cmp	r3, #0	; 0x0
30000b34:	e59f0030 	ldr	r0, [pc, #48]	; 30000b6c <.text+0xb6c>
30000b38:	e1a01003 	mov	r1, r3
30000b3c:	e284400c 	add	r4, r4, #12	; 0xc
30000b40:	0a000003 	beq	30000b54 <print_help+0x44>
                    break;
	    lprint("--%s: %s\r\n", cmd_list[i].cmd_name, cmd_list[i].cmd_des);
30000b44:	e5952008 	ldr	r2, [r5, #8]
	    //lprint("--%s\r\n\t%s\r\n", cmd_list[i].cmd_name, cmd_list[i].cmd_des);
            i++;
30000b48:	e285500c 	add	r5, r5, #12	; 0xc
30000b4c:	eb00027b 	bl	30001540 <lprint>
30000b50:	eafffff4 	b	30000b28 <print_help+0x18>
    }
    lprint("\r\n'r' is a special command, if a address followed, it will be set as a memory base for many other command, such as 'pm', and so on\r\nESC will cancel current command\r\n");
30000b54:	e59f0014 	ldr	r0, [pc, #20]	; 30000b70 <.text+0xb70>
30000b58:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
30000b5c:	ea000277 	b	30001540 <lprint>
30000b60:	30001ec4 	andcc	r1, r0, r4, asr #29
30000b64:	30001eec 	andcc	r1, r0, ip, ror #29
30000b68:	3000192c 	andcc	r1, r0, ip, lsr #18
30000b6c:	30001f8c 	andcc	r1, r0, ip, lsl #31
30000b70:	30001f98 	mulcc	r0, r8, pc

30000b74 <asc_to_hex>:
}

uint asc_to_hex(unsigned char c)
{
30000b74:	e20000ff 	and	r0, r0, #255	; 0xff
	uint v;

	if(c >= '0' && c <= '9')
30000b78:	e2402030 	sub	r2, r0, #48	; 0x30
30000b7c:	e20230ff 	and	r3, r2, #255	; 0xff
30000b80:	e3530009 	cmp	r3, #9	; 0x9
30000b84:	e2401041 	sub	r1, r0, #65	; 0x41
30000b88:	9a000006 	bls	30000ba8 <asc_to_hex+0x34>
		return c - '0';	
	if(c >= 'A' && c <= 'F')
30000b8c:	e3510005 	cmp	r1, #5	; 0x5
30000b90:	e2403061 	sub	r3, r0, #97	; 0x61
30000b94:	e2402037 	sub	r2, r0, #55	; 0x37
30000b98:	9a000002 	bls	30000ba8 <asc_to_hex+0x34>
		return c - 'A' + 10;
	if(c >= 'a' && c <= 'f')
30000b9c:	e3530005 	cmp	r3, #5	; 0x5
30000ba0:	e2402057 	sub	r2, r0, #87	; 0x57
		return c - 'a' + 10;
	return 0;
30000ba4:	83a02000 	movhi	r2, #0	; 0x0
}
30000ba8:	e1a00002 	mov	r0, r2
30000bac:	e1a0f00e 	mov	pc, lr

30000bb0 <get_howmany_para>:

uint get_howmany_para(unsigned char *s)
{
	uint tmp = 0;
30000bb0:	e3a02000 	mov	r2, #0	; 0x0
	while(1){
		while(*s == ' ')
30000bb4:	e5d03000 	ldrb	r3, [r0]
30000bb8:	e3530020 	cmp	r3, #32	; 0x20
30000bbc:	1a000002 	bne	30000bcc <get_howmany_para+0x1c>
			s++;
30000bc0:	e5f03001 	ldrb	r3, [r0, #1]!
30000bc4:	e3530020 	cmp	r3, #32	; 0x20
30000bc8:	0afffffc 	beq	30000bc0 <get_howmany_para+0x10>
		if(*s)
30000bcc:	e5d03000 	ldrb	r3, [r0]
30000bd0:	e3530000 	cmp	r3, #0	; 0x0
			tmp++;
30000bd4:	12822001 	addne	r2, r2, #1	; 0x1
		while(*s != ' ' && *s)
30000bd8:	e3530020 	cmp	r3, #32	; 0x20
30000bdc:	13530000 	cmpne	r3, #0	; 0x0
30000be0:	0a000003 	beq	30000bf4 <get_howmany_para+0x44>
			s++;
30000be4:	e5f03001 	ldrb	r3, [r0, #1]!
30000be8:	e3530020 	cmp	r3, #32	; 0x20
30000bec:	13530000 	cmpne	r3, #0	; 0x0
30000bf0:	1afffffb 	bne	30000be4 <get_howmany_para+0x34>
		if(!*s)
30000bf4:	e5d03000 	ldrb	r3, [r0]
30000bf8:	e3530000 	cmp	r3, #0	; 0x0
30000bfc:	01a00002 	moveq	r0, r2
30000c00:	01a0f00e 	moveq	pc, lr
30000c04:	eaffffea 	b	30000bb4 <get_howmany_para+0x4>

30000c08 <str_to_hex>:
			return tmp;
	}
}

unsigned char * str_to_hex(unsigned char *s, uint * result)
{
30000c08:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
	uint  i = 0;
30000c0c:	e3a07000 	mov	r7, #0	; 0x0

	*result = 0;
30000c10:	e5817000 	str	r7, [r1]
	while(*s == ' ')s++;
30000c14:	e5d03000 	ldrb	r3, [r0]
30000c18:	e3530020 	cmp	r3, #32	; 0x20
30000c1c:	e1a06001 	mov	r6, r1
30000c20:	e1a05000 	mov	r5, r0
30000c24:	1a000002 	bne	30000c34 <str_to_hex+0x2c>
30000c28:	e5f53001 	ldrb	r3, [r5, #1]!
30000c2c:	e3530020 	cmp	r3, #32	; 0x20
30000c30:	0afffffc 	beq	30000c28 <str_to_hex+0x20>
	for(i=0;i<8;i++){
30000c34:	e3a07000 	mov	r7, #0	; 0x0
		if(*s == ' ' || *s == 0)
30000c38:	e5d53000 	ldrb	r3, [r5]
30000c3c:	e3530000 	cmp	r3, #0	; 0x0
30000c40:	13530020 	cmpne	r3, #32	; 0x20
30000c44:	e1a00003 	mov	r0, r3
30000c48:	e2877001 	add	r7, r7, #1	; 0x1
30000c4c:	0a000007 	beq	30000c70 <str_to_hex+0x68>
			break;
		*result = *result*16 + asc_to_hex(*s++);
30000c50:	ebffffc7 	bl	30000b74 <asc_to_hex>
30000c54:	e5964000 	ldr	r4, [r6]
30000c58:	e1a04204 	mov	r4, r4, lsl #4
30000c5c:	e0844000 	add	r4, r4, r0
30000c60:	e3570007 	cmp	r7, #7	; 0x7
30000c64:	e2855001 	add	r5, r5, #1	; 0x1
30000c68:	e5864000 	str	r4, [r6]
30000c6c:	9afffff1 	bls	30000c38 <str_to_hex+0x30>
	}
	while(*s == ' ')s++;
30000c70:	e5d53000 	ldrb	r3, [r5]
30000c74:	e3530020 	cmp	r3, #32	; 0x20
30000c78:	1a000002 	bne	30000c88 <str_to_hex+0x80>
30000c7c:	e5f53001 	ldrb	r3, [r5, #1]!
30000c80:	e3530020 	cmp	r3, #32	; 0x20
30000c84:	0afffffc 	beq	30000c7c <str_to_hex+0x74>
	return s;
}
30000c88:	e1a00005 	mov	r0, r5
30000c8c:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}

30000c90 <print_mem>:

void print_mem(unsigned char *cp, uint length)
{
30000c90:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    uint i;

    cp = (unsigned char *)((uint)cp & (~0x3));
30000c94:	e3c04003 	bic	r4, r0, #3	; 0x3
30000c98:	e1a05001 	mov	r5, r1
    lprint("Start print 0x%x mem content @%x:\r\n", length, (uint)cp);
30000c9c:	e59f004c 	ldr	r0, [pc, #76]	; 30000cf0 <.text+0xcf0>
30000ca0:	e1a02004 	mov	r2, r4
30000ca4:	eb000225 	bl	30001540 <lprint>
    while(length){
30000ca8:	e3550000 	cmp	r5, #0	; 0x0
30000cac:	0a00000b 	beq	30000ce0 <print_mem+0x50>
	lprint("\r\n");
30000cb0:	e59f003c 	ldr	r0, [pc, #60]	; 30000cf4 <.text+0xcf4>
30000cb4:	eb000221 	bl	30001540 <lprint>
	for(i=0;i<8;i++){
30000cb8:	e3a06000 	mov	r6, #0	; 0x0
		length--;
		lprint("%x\t", *cp++);
30000cbc:	e4d41001 	ldrb	r1, [r4], #1
30000cc0:	e59f0030 	ldr	r0, [pc, #48]	; 30000cf8 <.text+0xcf8>
30000cc4:	e2866001 	add	r6, r6, #1	; 0x1
30000cc8:	eb00021c 	bl	30001540 <lprint>
30000ccc:	e3560007 	cmp	r6, #7	; 0x7
30000cd0:	e2455001 	sub	r5, r5, #1	; 0x1
30000cd4:	9afffff8 	bls	30000cbc <print_mem+0x2c>
30000cd8:	e3550000 	cmp	r5, #0	; 0x0
30000cdc:	1afffff3 	bne	30000cb0 <print_mem+0x20>
	}
    }
    lprint("\r\nPrint end @%x.\r\n", (uint)cp);
30000ce0:	e59f0014 	ldr	r0, [pc, #20]	; 30000cfc <.text+0xcfc>
30000ce4:	e1a01004 	mov	r1, r4
30000ce8:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
30000cec:	ea000213 	b	30001540 <lprint>
30000cf0:	30002040 	andcc	r2, r0, r0, asr #32
30000cf4:	30001ad0 	ldrccd	r1, [r0], -r0
30000cf8:	30002064 	andcc	r2, r0, r4, rrx
30000cfc:	30002068 	andcc	r2, r0, r8, rrx

30000d00 <pm>:
}

void pm(unsigned char *p)
{
30000d00:	e92d4010 	stmdb	sp!, {r4, lr}
    uint length = 0x80, tmp, i;
30000d04:	e3a03080 	mov	r3, #128	; 0x80
30000d08:	e24dd004 	sub	sp, sp, #4	; 0x4
30000d0c:	e58d3000 	str	r3, [sp]
30000d10:	e1a04000 	mov	r4, r0

    tmp = get_howmany_para(p);
30000d14:	ebffffa5 	bl	30000bb0 <get_howmany_para>
30000d18:	e1a03000 	mov	r3, r0
    if( tmp > 1)
30000d1c:	e3530001 	cmp	r3, #1	; 0x1
30000d20:	e59f0030 	ldr	r0, [pc, #48]	; 30000d58 <.text+0xd58>
30000d24:	8a000008 	bhi	30000d4c <pm+0x4c>
        goto error;
    if(tmp == 0)
30000d28:	e3530000 	cmp	r3, #0	; 0x0
30000d2c:	e1a00004 	mov	r0, r4
30000d30:	e1a0100d 	mov	r1, sp
        goto print;
    str_to_hex(p, &length);
30000d34:	1bffffb3 	blne	30000c08 <str_to_hex>
print:
    print_mem((unsigned char*)mrw_addr, length);
30000d38:	e59f301c 	ldr	r3, [pc, #28]	; 30000d5c <.text+0xd5c>
30000d3c:	e59d1000 	ldr	r1, [sp]
30000d40:	e5930000 	ldr	r0, [r3]
30000d44:	ebffffd1 	bl	30000c90 <print_mem>
    return;
30000d48:	ea000000 	b	30000d50 <pm+0x50>

error:
    lprint("Error para!\r\npm [length](default 0x80 if no this argu)\r\n");
30000d4c:	eb0001fb 	bl	30001540 <lprint>

}
30000d50:	e28dd004 	add	sp, sp, #4	; 0x4
30000d54:	e8bd8010 	ldmia	sp!, {r4, pc}
30000d58:	3000207c 	andcc	r2, r0, ip, ror r0
30000d5c:	30002450 	andcc	r2, r0, r0, asr r4

30000d60 <ndbb>:


void ndbb(unsigned char *p)
{
30000d60:	e92d4010 	stmdb	sp!, {r4, lr}
30000d64:	e24dd004 	sub	sp, sp, #4	; 0x4
30000d68:	e1a04000 	mov	r4, r0
    uint addr, tmp;

    tmp = get_howmany_para(p);
30000d6c:	ebffff8f 	bl	30000bb0 <get_howmany_para>
30000d70:	e1a03000 	mov	r3, r0
    if(tmp != 1)
30000d74:	e3530001 	cmp	r3, #1	; 0x1
30000d78:	e59f0040 	ldr	r0, [pc, #64]	; 30000dc0 <.text+0xdc0>
30000d7c:	e1a0100d 	mov	r1, sp
30000d80:	1a00000b 	bne	30000db4 <ndbb+0x54>
        goto error;
    p = str_to_hex(p, &addr);
30000d84:	e1a00004 	mov	r0, r4
30000d88:	ebffff9e 	bl	30000c08 <str_to_hex>
cp:
    lprint("block %x ", addr);
30000d8c:	e59d1000 	ldr	r1, [sp]
30000d90:	e59f002c 	ldr	r0, [pc, #44]	; 30000dc4 <.text+0xdc4>
30000d94:	eb0001e9 	bl	30001540 <lprint>
    nand_reset();
30000d98:	ebfffd40 	bl	300002a0 <nand_reset>
    if(is_marked_bad_block(addr))
30000d9c:	e59d0000 	ldr	r0, [sp]
30000da0:	ebfffe0a 	bl	300005d0 <is_marked_bad_block>
30000da4:	e1a03000 	mov	r3, r0
30000da8:	e3530000 	cmp	r3, #0	; 0x0
30000dac:	e59f0014 	ldr	r0, [pc, #20]	; 30000dc8 <.text+0xdc8>
	lprint("is Marked bad.\r\n");
    else
    	lprint("is not marked bad!\r\n");
30000db0:	059f0014 	ldreq	r0, [pc, #20]	; 30000dcc <.text+0xdcc>
    return;

error:
    lprint("Error para!\r\nnander (hex block addr)\r\n");
30000db4:	eb0001e1 	bl	30001540 <lprint>

}
30000db8:	e28dd004 	add	sp, sp, #4	; 0x4
30000dbc:	e8bd8010 	ldmia	sp!, {r4, pc}
30000dc0:	300020b8 	strcch	r2, [r0], -r8
30000dc4:	300020e0 	andcc	r2, r0, r0, ror #1
30000dc8:	300020ec 	andcc	r2, r0, ip, ror #1
30000dcc:	30002100 	andcc	r2, r0, r0, lsl #2

30000dd0 <nandspr>:

void nandspr(unsigned char *p)
{
30000dd0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
30000dd4:	e24dd004 	sub	sp, sp, #4	; 0x4
30000dd8:	e1a04000 	mov	r4, r0
    uint addr, tmp;

    tmp = get_howmany_para(p);
30000ddc:	ebffff73 	bl	30000bb0 <get_howmany_para>
30000de0:	e1a05000 	mov	r5, r0
    if(tmp != 1)
30000de4:	e3550001 	cmp	r5, #1	; 0x1
30000de8:	e1a0100d 	mov	r1, sp
30000dec:	e1a00004 	mov	r0, r4
30000df0:	1a000009 	bne	30000e1c <nandspr+0x4c>
        goto error;
    p = str_to_hex(p, &addr);
30000df4:	ebffff83 	bl	30000c08 <str_to_hex>
cp:
    nand_reset();
30000df8:	ebfffd28 	bl	300002a0 <nand_reset>
    lprint("%x at nand spare addr %x\r\n", random_read_nand(1, addr), addr);
30000dfc:	e59d1000 	ldr	r1, [sp]
30000e00:	e1a00005 	mov	r0, r5
30000e04:	ebfffdc5 	bl	30000520 <random_read_nand>
30000e08:	e59d2000 	ldr	r2, [sp]
30000e0c:	e1a01000 	mov	r1, r0
30000e10:	e59f0014 	ldr	r0, [pc, #20]	; 30000e2c <.text+0xe2c>
30000e14:	eb0001c9 	bl	30001540 <lprint>
    return;
30000e18:	ea000001 	b	30000e24 <nandspr+0x54>

error:
    lprint("Error para!\r\nnandspr (hex addr) random read nand spare\r\n");
30000e1c:	e59f000c 	ldr	r0, [pc, #12]	; 30000e30 <.text+0xe30>
30000e20:	eb0001c6 	bl	30001540 <lprint>

}
30000e24:	e28dd004 	add	sp, sp, #4	; 0x4
30000e28:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30000e2c:	30002118 	andcc	r2, r0, r8, lsl r1
30000e30:	30002134 	andcc	r2, r0, r4, lsr r1

30000e34 <nandr>:

void nandr(unsigned char *p)
{
30000e34:	e92d4010 	stmdb	sp!, {r4, lr}
30000e38:	e24dd004 	sub	sp, sp, #4	; 0x4
30000e3c:	e1a04000 	mov	r4, r0
    uint addr, tmp;

    tmp = get_howmany_para(p);
30000e40:	ebffff5a 	bl	30000bb0 <get_howmany_para>
30000e44:	e1a03000 	mov	r3, r0
    if(tmp != 1)
30000e48:	e3530001 	cmp	r3, #1	; 0x1
30000e4c:	e1a0100d 	mov	r1, sp
30000e50:	e1a00004 	mov	r0, r4
30000e54:	1a000009 	bne	30000e80 <nandr+0x4c>
        goto error;
    p = str_to_hex(p, &addr);
30000e58:	ebffff6a 	bl	30000c08 <str_to_hex>
cp:
    nand_reset();
30000e5c:	ebfffd0f 	bl	300002a0 <nand_reset>
    lprint("%x at nand addr %x\r\n", random_read_nand(0, addr), addr);
30000e60:	e59d1000 	ldr	r1, [sp]
30000e64:	e3a00000 	mov	r0, #0	; 0x0
30000e68:	ebfffdac 	bl	30000520 <random_read_nand>
30000e6c:	e59d2000 	ldr	r2, [sp]
30000e70:	e1a01000 	mov	r1, r0
30000e74:	e59f0014 	ldr	r0, [pc, #20]	; 30000e90 <.text+0xe90>
30000e78:	eb0001b0 	bl	30001540 <lprint>
    return;
30000e7c:	ea000001 	b	30000e88 <nandr+0x54>

error:
    lprint("Error para!\r\nnandr (hex addr) random read nand\r\n");
30000e80:	e59f000c 	ldr	r0, [pc, #12]	; 30000e94 <.text+0xe94>
30000e84:	eb0001ad 	bl	30001540 <lprint>

}
30000e88:	e28dd004 	add	sp, sp, #4	; 0x4
30000e8c:	e8bd8010 	ldmia	sp!, {r4, pc}
30000e90:	30002170 	andcc	r2, r0, r0, ror r1
30000e94:	30002188 	andcc	r2, r0, r8, lsl #3

30000e98 <nandwb>:

void nandwb(unsigned char *p)
{
30000e98:	e92d4010 	stmdb	sp!, {r4, lr}
30000e9c:	e24dd008 	sub	sp, sp, #8	; 0x8
30000ea0:	e1a04000 	mov	r4, r0
    uint addr, tmp, c;

    tmp = get_howmany_para(p);
30000ea4:	ebffff41 	bl	30000bb0 <get_howmany_para>
30000ea8:	e1a03000 	mov	r3, r0
    if(tmp != 2)
30000eac:	e3530002 	cmp	r3, #2	; 0x2
30000eb0:	e59f0044 	ldr	r0, [pc, #68]	; 30000efc <.text+0xefc>
30000eb4:	e28d1004 	add	r1, sp, #4	; 0x4
30000eb8:	1a00000c 	bne	30000ef0 <nandwb+0x58>
        goto error;
    p = str_to_hex(p, &c);
30000ebc:	e1a00004 	mov	r0, r4
30000ec0:	ebffff50 	bl	30000c08 <str_to_hex>
    p = str_to_hex(p, &addr);
30000ec4:	e1a0100d 	mov	r1, sp
30000ec8:	ebffff4e 	bl	30000c08 <str_to_hex>

    c &= 0xff;
30000ecc:	e5dd3004 	ldrb	r3, [sp, #4]
30000ed0:	e58d3004 	str	r3, [sp, #4]
    if(random_write_nand((unsigned char)c, addr) == 0)
30000ed4:	e59d1000 	ldr	r1, [sp]
30000ed8:	e5dd0004 	ldrb	r0, [sp, #4]
30000edc:	ebfffd54 	bl	30000434 <random_write_nand>
30000ee0:	e1a03000 	mov	r3, r0
30000ee4:	e3530000 	cmp	r3, #0	; 0x0
30000ee8:	e59f0010 	ldr	r0, [pc, #16]	; 30000f00 <.text+0xf00>
30000eec:	1a000000 	bne	30000ef4 <nandwb+0x5c>
    	lprint("successfully\r\n");
    return;

error:
    lprint("Error para!\r\nnandwb (hex char)(hex addr) random write nand\r\n");
30000ef0:	eb000192 	bl	30001540 <lprint>

}
30000ef4:	e28dd008 	add	sp, sp, #8	; 0x8
30000ef8:	e8bd8010 	ldmia	sp!, {r4, pc}
30000efc:	300021bc 	strcch	r2, [r0], -ip
30000f00:	300021fc 	strccd	r2, [r0], -ip

30000f04 <nander>:

void nander(unsigned char *p)
{
30000f04:	e92d4010 	stmdb	sp!, {r4, lr}
30000f08:	e24dd004 	sub	sp, sp, #4	; 0x4
30000f0c:	e1a04000 	mov	r4, r0
    uint addr, tmp;

    tmp = get_howmany_para(p);
30000f10:	ebffff26 	bl	30000bb0 <get_howmany_para>
30000f14:	e1a03000 	mov	r3, r0
    if(tmp != 1)
30000f18:	e3530001 	cmp	r3, #1	; 0x1
30000f1c:	e59f0044 	ldr	r0, [pc, #68]	; 30000f68 <.text+0xf68>
30000f20:	e1a0100d 	mov	r1, sp
30000f24:	1a00000c 	bne	30000f5c <nander+0x58>
        goto error;
    p = str_to_hex(p, &addr);
30000f28:	e1a00004 	mov	r0, r4
30000f2c:	ebffff35 	bl	30000c08 <str_to_hex>
cp:
    nand_reset();
30000f30:	ebfffcda 	bl	300002a0 <nand_reset>
    if(nand_erase_ll(addr))
30000f34:	e59d0000 	ldr	r0, [sp]
30000f38:	ebfffdc2 	bl	30000648 <nand_erase_ll>
30000f3c:	e1a03000 	mov	r3, r0
30000f40:	e3530000 	cmp	r3, #0	; 0x0
30000f44:	e59f0020 	ldr	r0, [pc, #32]	; 30000f6c <.text+0xf6c>
30000f48:	1a000003 	bne	30000f5c <nander+0x58>
	lprint("erase error\r\n");
    else
    	lprint("erase nand block 0x%x done!\r\n",addr);
30000f4c:	e59f001c 	ldr	r0, [pc, #28]	; 30000f70 <.text+0xf70>
30000f50:	e59d1000 	ldr	r1, [sp]
30000f54:	eb000179 	bl	30001540 <lprint>
    return;
30000f58:	ea000000 	b	30000f60 <nander+0x5c>

error:
    lprint("Error para!\r\nnander (hex block addr)\r\n");
30000f5c:	eb000177 	bl	30001540 <lprint>

}
30000f60:	e28dd004 	add	sp, sp, #4	; 0x4
30000f64:	e8bd8010 	ldmia	sp!, {r4, pc}
30000f68:	300020b8 	strcch	r2, [r0], -r8
30000f6c:	3000220c 	andcc	r2, r0, ip, lsl #4
30000f70:	3000221c 	andcc	r2, r0, ip, lsl r2

30000f74 <nandpp>:

void nandpp(unsigned char *p)
{
30000f74:	e92d4030 	stmdb	sp!, {r4, r5, lr}
30000f78:	e24dd008 	sub	sp, sp, #8	; 0x8
30000f7c:	e1a04000 	mov	r4, r0
    uint addr, pages, tmp;

    tmp = get_howmany_para(p);
30000f80:	ebffff0a 	bl	30000bb0 <get_howmany_para>
30000f84:	e1a03000 	mov	r3, r0
    if(tmp != 2)
30000f88:	e3530002 	cmp	r3, #2	; 0x2
30000f8c:	e59f5070 	ldr	r5, [pc, #112]	; 30001004 <.text+0x1004>
30000f90:	e59f0070 	ldr	r0, [pc, #112]	; 30001008 <.text+0x1008>
30000f94:	e28d1004 	add	r1, sp, #4	; 0x4
30000f98:	1a000016 	bne	30000ff8 <nandpp+0x84>
        goto error;
    p = str_to_hex(p, &addr);
30000f9c:	e1a00004 	mov	r0, r4
30000fa0:	ebffff18 	bl	30000c08 <str_to_hex>
    str_to_hex(p, &pages);
30000fa4:	e1a0100d 	mov	r1, sp
30000fa8:	ebffff16 	bl	30000c08 <str_to_hex>
    addr = addr & 0xfffffe00;
30000fac:	e59d3004 	ldr	r3, [sp, #4]
30000fb0:	e3c33f7f 	bic	r3, r3, #508	; 0x1fc
30000fb4:	e3c33003 	bic	r3, r3, #3	; 0x3
30000fb8:	e58d3004 	str	r3, [sp, #4]

    nand_reset();
30000fbc:	ebfffcb7 	bl	300002a0 <nand_reset>
    if(nand_write_ll(mrw_addr, addr, 512 * pages)){
30000fc0:	e59d2000 	ldr	r2, [sp]
30000fc4:	e5950000 	ldr	r0, [r5]
30000fc8:	e1a02482 	mov	r2, r2, lsl #9
30000fcc:	e59d1004 	ldr	r1, [sp, #4]
30000fd0:	ebfffde6 	bl	30000770 <nand_write_ll>
30000fd4:	e1a03000 	mov	r3, r0
30000fd8:	e3530000 	cmp	r3, #0	; 0x0
30000fdc:	e59f0028 	ldr	r0, [pc, #40]	; 3000100c <.text+0x100c>
30000fe0:	1a000004 	bne	30000ff8 <nandpp+0x84>
	lprint("failed\r\n");
	return;
    }
    lprint("program 0x%x pages from memory 0x%x to nand addr %x done!\r\n",pages,mrw_addr,addr);
30000fe4:	e5952000 	ldr	r2, [r5]
30000fe8:	e59f0020 	ldr	r0, [pc, #32]	; 30001010 <.text+0x1010>
30000fec:	e89d000a 	ldmia	sp, {r1, r3}
30000ff0:	eb000152 	bl	30001540 <lprint>
    return;
30000ff4:	ea000000 	b	30000ffc <nandpp+0x88>

error:
    lprint("Error para!\r\nnandcp (hex addr) (hex pages)\r\n");
30000ff8:	eb000150 	bl	30001540 <lprint>

}
30000ffc:	e28dd008 	add	sp, sp, #8	; 0x8
30001000:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30001004:	30002450 	andcc	r2, r0, r0, asr r4
30001008:	3000223c 	andcc	r2, r0, ip, lsr r2
3000100c:	3000226c 	andcc	r2, r0, ip, ror #4
30001010:	30002278 	andcc	r2, r0, r8, ror r2

30001014 <nandcp>:

void nandcp(unsigned char *p)
{
30001014:	e92d4030 	stmdb	sp!, {r4, r5, lr}
30001018:	e24dd008 	sub	sp, sp, #8	; 0x8
3000101c:	e1a04000 	mov	r4, r0
    uint addr, pages, tmp;

    tmp = get_howmany_para(p);
30001020:	ebfffee2 	bl	30000bb0 <get_howmany_para>
30001024:	e1a03000 	mov	r3, r0
    if(tmp != 2)
30001028:	e3530002 	cmp	r3, #2	; 0x2
3000102c:	e59f5060 	ldr	r5, [pc, #96]	; 30001094 <.text+0x1094>
30001030:	e28d1004 	add	r1, sp, #4	; 0x4
30001034:	e1a00004 	mov	r0, r4
30001038:	1a000011 	bne	30001084 <nandcp+0x70>
        goto error;
    p = str_to_hex(p, &addr);
3000103c:	ebfffef1 	bl	30000c08 <str_to_hex>
    str_to_hex(p, &pages);
30001040:	e1a0100d 	mov	r1, sp
30001044:	ebfffeef 	bl	30000c08 <str_to_hex>
    addr = addr & 0xfffffe00;
30001048:	e59d3004 	ldr	r3, [sp, #4]
3000104c:	e3c33f7f 	bic	r3, r3, #508	; 0x1fc
30001050:	e3c33003 	bic	r3, r3, #3	; 0x3
30001054:	e58d3004 	str	r3, [sp, #4]
cp:
    nand_reset();
30001058:	ebfffc90 	bl	300002a0 <nand_reset>
    nand_read_ll(mrw_addr, addr, 512 * pages);
3000105c:	e59d2000 	ldr	r2, [sp]
30001060:	e59d1004 	ldr	r1, [sp, #4]
30001064:	e5950000 	ldr	r0, [r5]
30001068:	e1a02482 	mov	r2, r2, lsl #9
3000106c:	ebfffca4 	bl	30000304 <nand_read_ll>
    lprint("cp 0x%x pages from nand addr %x to memory 0x%x done!\r\n",pages,addr,mrw_addr);
30001070:	e5953000 	ldr	r3, [r5]
30001074:	e89d0006 	ldmia	sp, {r1, r2}
30001078:	e59f0018 	ldr	r0, [pc, #24]	; 30001098 <.text+0x1098>
3000107c:	eb00012f 	bl	30001540 <lprint>
    return;
30001080:	ea000001 	b	3000108c <nandcp+0x78>

error:
    lprint("Error para!\r\nnandcp (hex addr) (hex pages)\r\n");
30001084:	e59f0010 	ldr	r0, [pc, #16]	; 3000109c <.text+0x109c>
30001088:	eb00012c 	bl	30001540 <lprint>

}
3000108c:	e28dd008 	add	sp, sp, #8	; 0x8
30001090:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30001094:	30002450 	andcc	r2, r0, r0, asr r4
30001098:	300022b4 	strcch	r2, [r0], -r4
3000109c:	3000223c 	andcc	r2, r0, ip, lsr r2

300010a0 <write_mem>:

void write_mem(unsigned char *p)
{
300010a0:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
300010a4:	e24dd004 	sub	sp, sp, #4	; 0x4
300010a8:	e1a06000 	mov	r6, r0
    uint value, tmp;

    tmp = get_howmany_para(p);
300010ac:	ebfffebf 	bl	30000bb0 <get_howmany_para>
300010b0:	e1a05000 	mov	r5, r0
    if(tmp == 0 || tmp > 2)
300010b4:	e2453001 	sub	r3, r5, #1	; 0x1
300010b8:	e3530001 	cmp	r3, #1	; 0x1
300010bc:	e59f005c 	ldr	r0, [pc, #92]	; 30001120 <.text+0x1120>
300010c0:	e1a0100d 	mov	r1, sp
300010c4:	8a000012 	bhi	30001114 <write_mem+0x74>
	goto error;
    p = str_to_hex(p, &value);
300010c8:	e59f4054 	ldr	r4, [pc, #84]	; 30001124 <.text+0x1124>
300010cc:	e1a00006 	mov	r0, r6
300010d0:	ebfffecc 	bl	30000c08 <str_to_hex>
    if(tmp == 1)
300010d4:	e3550001 	cmp	r5, #1	; 0x1
300010d8:	e1a01004 	mov	r1, r4
300010dc:	0a000003 	beq	300010f0 <write_mem+0x50>
        goto write;
    str_to_hex(p, (uint*)&mrw_addr);
300010e0:	ebfffec8 	bl	30000c08 <str_to_hex>
    mrw_addr = (uint*)((uint)mrw_addr & 0xfffffffc);
300010e4:	e5943000 	ldr	r3, [r4]
300010e8:	e3c33003 	bic	r3, r3, #3	; 0x3
300010ec:	e5843000 	str	r3, [r4]
write:
    *(uint*)mrw_addr = value;
300010f0:	e59f102c 	ldr	r1, [pc, #44]	; 30001124 <.text+0x1124>
300010f4:	e59d3000 	ldr	r3, [sp]
300010f8:	e5912000 	ldr	r2, [r1]
300010fc:	e5823000 	str	r3, [r2]
    lprint("Write 0x%x to memory 0x%x done!\r\n",value,mrw_addr);
30001100:	e59f0020 	ldr	r0, [pc, #32]	; 30001128 <.text+0x1128>
30001104:	e5912000 	ldr	r2, [r1]
30001108:	e59d1000 	ldr	r1, [sp]
3000110c:	eb00010b 	bl	30001540 <lprint>
    return;
30001110:	ea000000 	b	30001118 <write_mem+0x78>

error:
    lprint("Error para!\r\nw (hex value) [(hex addr)](last addr if no this argu)\r\n");
30001114:	eb000109 	bl	30001540 <lprint>

}
30001118:	e28dd004 	add	sp, sp, #4	; 0x4
3000111c:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30001120:	300022ec 	andcc	r2, r0, ip, ror #5
30001124:	30002450 	andcc	r2, r0, r0, asr r4
30001128:	30002334 	andcc	r2, r0, r4, lsr r3

3000112c <read_mem>:


void read_mem(unsigned char *p)
{
3000112c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
30001130:	e1a05000 	mov	r5, r0
    uint value, tmp;

    tmp = get_howmany_para(p);
30001134:	ebfffe9d 	bl	30000bb0 <get_howmany_para>
30001138:	e1a03000 	mov	r3, r0
    if( tmp > 1)
3000113c:	e3530001 	cmp	r3, #1	; 0x1
30001140:	e59f0044 	ldr	r0, [pc, #68]	; 3000118c <.text+0x118c>
30001144:	8a00000e 	bhi	30001184 <read_mem+0x58>
	goto error;
    if(tmp == 0)
30001148:	e59f4040 	ldr	r4, [pc, #64]	; 30001190 <.text+0x1190>
3000114c:	e3530000 	cmp	r3, #0	; 0x0
30001150:	e1a00005 	mov	r0, r5
30001154:	e1a01004 	mov	r1, r4
30001158:	0a000003 	beq	3000116c <read_mem+0x40>
    	goto read;
    str_to_hex(p, (uint*)&mrw_addr);
3000115c:	ebfffea9 	bl	30000c08 <str_to_hex>
    mrw_addr = (uint*)((uint)mrw_addr & 0xfffffffc);
30001160:	e5943000 	ldr	r3, [r4]
30001164:	e3c33003 	bic	r3, r3, #3	; 0x3
30001168:	e5843000 	str	r3, [r4]
read:
    value = *(uint*)mrw_addr;
3000116c:	e59f301c 	ldr	r3, [pc, #28]	; 30001190 <.text+0x1190>
30001170:	e5932000 	ldr	r2, [r3]
    lprint("Read 0x%x at memory 0x%x\r\n",value,mrw_addr);
30001174:	e59f0018 	ldr	r0, [pc, #24]	; 30001194 <.text+0x1194>
30001178:	e5921000 	ldr	r1, [r2]
3000117c:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
30001180:	ea0000ee 	b	30001540 <lprint>

    return;

error:
    lprint("Error para!\r\nr [(hex addr)](last addr if no this argu)\r\n");
30001184:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
30001188:	ea0000ec 	b	30001540 <lprint>
3000118c:	30002358 	andcc	r2, r0, r8, asr r3
30001190:	30002450 	andcc	r2, r0, r0, asr r4
30001194:	30002394 	mulcc	r0, r4, r3

30001198 <lmemcpy>:

}


unsigned char* lmemcpy(unsigned char *d,unsigned char*s,uint n)
{
	unsigned char *p=d;
	while(n--)*d++=*s++;
30001198:	e2422001 	sub	r2, r2, #1	; 0x1
3000119c:	e3720001 	cmn	r2, #1	; 0x1
300011a0:	e1a0c000 	mov	ip, r0
300011a4:	0a000004 	beq	300011bc <lmemcpy+0x24>
300011a8:	e4d13001 	ldrb	r3, [r1], #1
300011ac:	e2422001 	sub	r2, r2, #1	; 0x1
300011b0:	e3720001 	cmn	r2, #1	; 0x1
300011b4:	e4c03001 	strb	r3, [r0], #1
300011b8:	1afffffa 	bne	300011a8 <lmemcpy+0x10>
	return p;
}
300011bc:	e1a0000c 	mov	r0, ip
300011c0:	e1a0f00e 	mov	pc, lr

300011c4 <lmemset>:

void lmemset(unsigned char *d,unsigned char v,unsigned int n)
{
	while(n--)*d++=v;
300011c4:	e2422001 	sub	r2, r2, #1	; 0x1
300011c8:	e3720001 	cmn	r2, #1	; 0x1
300011cc:	e20110ff 	and	r1, r1, #255	; 0xff
300011d0:	01a0f00e 	moveq	pc, lr
300011d4:	e2422001 	sub	r2, r2, #1	; 0x1
300011d8:	e3720001 	cmn	r2, #1	; 0x1
300011dc:	e4c01001 	strb	r1, [r0], #1
300011e0:	01a0f00e 	moveq	pc, lr
300011e4:	eafffffa 	b	300011d4 <lmemset+0x10>

300011e8 <handle_cmd>:
}

void handle_cmd()
{
300011e8:	e92d4010 	stmdb	sp!, {r4, lr}
    unsigned char i = 0, *p_cmd, *p_buf;

    lprint("\r\n");
300011ec:	e59f00a8 	ldr	r0, [pc, #168]	; 3000129c <.text+0x129c>
300011f0:	eb0000d2 	bl	30001540 <lprint>
    if(!cmd_buf[0])
300011f4:	e59f30a4 	ldr	r3, [pc, #164]	; 300012a0 <.text+0x12a0>
300011f8:	e5d33000 	ldrb	r3, [r3]
300011fc:	e3530000 	cmp	r3, #0	; 0x0
30001200:	e3a0c000 	mov	ip, #0	; 0x0
30001204:	08bd8010 	ldmeqia	sp!, {r4, pc}
	return;
    while(1){
	    if(cmd_list[i].cmd_name == NULL)
30001208:	e59f4094 	ldr	r4, [pc, #148]	; 300012a4 <.text+0x12a4>
3000120c:	e1a0e08c 	mov	lr, ip, lsl #1
30001210:	e08e300c 	add	r3, lr, ip
30001214:	e7943103 	ldr	r3, [r4, r3, lsl #2]
30001218:	e3530000 	cmp	r3, #0	; 0x0
3000121c:	0a000015 	beq	30001278 <handle_cmd+0x90>
		    break;
	    p_cmd=cmd_list[i].cmd_name;
	    p_buf=cmd_buf;
	    while(*p_cmd){
30001220:	e5d32000 	ldrb	r2, [r3]
30001224:	e3520000 	cmp	r2, #0	; 0x0
30001228:	e1a01003 	mov	r1, r3
3000122c:	e59f006c 	ldr	r0, [pc, #108]	; 300012a0 <.text+0x12a0>
30001230:	0a000009 	beq	3000125c <handle_cmd+0x74>
		    if(*p_buf != *p_cmd)
30001234:	e5d03000 	ldrb	r3, [r0]
30001238:	e1530002 	cmp	r3, r2
3000123c:	1a000003 	bne	30001250 <handle_cmd+0x68>
			    break;
		    p_buf++;
		    p_cmd++;
30001240:	e5f12001 	ldrb	r2, [r1, #1]!
30001244:	e3520000 	cmp	r2, #0	; 0x0
30001248:	e2800001 	add	r0, r0, #1	; 0x1
3000124c:	1afffff8 	bne	30001234 <handle_cmd+0x4c>
	    }
	    if(!(*p_cmd) && (*p_buf == ' ' || !(*p_buf))){
30001250:	e5d13000 	ldrb	r3, [r1]
30001254:	e3530000 	cmp	r3, #0	; 0x0
30001258:	1a000003 	bne	3000126c <handle_cmd+0x84>
3000125c:	e5d03000 	ldrb	r3, [r0]
30001260:	e3530000 	cmp	r3, #0	; 0x0
30001264:	13530020 	cmpne	r3, #32	; 0x20
30001268:	0a000006 	beq	30001288 <handle_cmd+0xa0>
            	    cmd_list[i].cmd_fun(p_buf);
            	    return;
       	    }
	    i++;
3000126c:	e28c3001 	add	r3, ip, #1	; 0x1
30001270:	e203c0ff 	and	ip, r3, #255	; 0xff
30001274:	eaffffe3 	b	30001208 <handle_cmd+0x20>
    }
    lprint("Unknow command:%s\r\n",cmd_buf);
30001278:	e59f0028 	ldr	r0, [pc, #40]	; 300012a8 <.text+0x12a8>
3000127c:	e59f101c 	ldr	r1, [pc, #28]	; 300012a0 <.text+0x12a0>
30001280:	e8bd4010 	ldmia	sp!, {r4, lr}
30001284:	ea0000ad 	b	30001540 <lprint>
30001288:	e08e300c 	add	r3, lr, ip
3000128c:	e0843103 	add	r3, r4, r3, lsl #2
30001290:	e1a0e00f 	mov	lr, pc
30001294:	e593f004 	ldr	pc, [r3, #4]
}
30001298:	e8bd8010 	ldmia	sp!, {r4, pc}
3000129c:	30001ad0 	ldrccd	r1, [r0], -r0
300012a0:	30002454 	andcc	r2, r0, r4, asr r4
300012a4:	3000192c 	andcc	r1, r0, ip, lsr #18
300012a8:	300023b0 	strcch	r2, [r0], -r0

300012ac <run_clean_boot>:

void run_clean_boot()
{
	unsigned char c;
	
	mrw_addr = 0;
300012ac:	e59fc0d4 	ldr	ip, [pc, #212]	; 30001388 <.text+0x1388>
300012b0:	e92d4010 	stmdb	sp!, {r4, lr}
300012b4:	e3a04000 	mov	r4, #0	; 0x0
	lprint("\r\n\r\nHello, this is clean_boot v%sbuild on %s %s.\r\n", CLEAN_BOOT_VERSION,__DATE__,__TIME__);
300012b8:	e59f30cc 	ldr	r3, [pc, #204]	; 3000138c <.text+0x138c>
300012bc:	e59f00cc 	ldr	r0, [pc, #204]	; 30001390 <.text+0x1390>
300012c0:	e59f10cc 	ldr	r1, [pc, #204]	; 30001394 <.text+0x1394>
300012c4:	e59f20cc 	ldr	r2, [pc, #204]	; 30001398 <.text+0x1398>
300012c8:	e58c4000 	str	r4, [ip]
300012cc:	eb00009b 	bl	30001540 <lprint>
	lmemset(cmd_buf, 0, COM_MAX_LEN);
300012d0:	e59f00c4 	ldr	r0, [pc, #196]	; 3000139c <.text+0x139c>
300012d4:	e1a01004 	mov	r1, r4
300012d8:	e3a02020 	mov	r2, #32	; 0x20
300012dc:	ebffffb8 	bl	300011c4 <lmemset>
	cmd_buf_p = 0;
300012e0:	e59f30b8 	ldr	r3, [pc, #184]	; 300013a0 <.text+0x13a0>
	lprint("\r\nCleanBoot@%s>", PLATFORM);
300012e4:	e59f00b8 	ldr	r0, [pc, #184]	; 300013a4 <.text+0x13a4>
300012e8:	e59f10b8 	ldr	r1, [pc, #184]	; 300013a8 <.text+0x13a8>
300012ec:	e5834000 	str	r4, [r3]
300012f0:	eb000092 	bl	30001540 <lprint>
	while(1){
		c = con_recv();
300012f4:	ebfffd90 	bl	3000093c <s3c2440_serial_recv_byte>
300012f8:	e200c0ff 	and	ip, r0, #255	; 0xff
		if(c == ENTER_CHAR){
300012fc:	e35c000d 	cmp	ip, #13	; 0xd
30001300:	1a00000a 	bne	30001330 <run_clean_boot+0x84>
			handle_cmd();
30001304:	ebffffb7 	bl	300011e8 <handle_cmd>
			lmemset(cmd_buf, 0, COM_MAX_LEN);
30001308:	e59f008c 	ldr	r0, [pc, #140]	; 3000139c <.text+0x139c>
3000130c:	e3a01000 	mov	r1, #0	; 0x0
30001310:	e3a02020 	mov	r2, #32	; 0x20
30001314:	ebffffaa 	bl	300011c4 <lmemset>
			cmd_buf_p = 0;
30001318:	e59f3080 	ldr	r3, [pc, #128]	; 300013a0 <.text+0x13a0>
			lprint("\r\nCleanBoot@%s>", PLATFORM);
3000131c:	e59f0080 	ldr	r0, [pc, #128]	; 300013a4 <.text+0x13a4>
30001320:	e59f1080 	ldr	r1, [pc, #128]	; 300013a8 <.text+0x13a8>
30001324:	e3a02000 	mov	r2, #0	; 0x0
30001328:	e5832000 	str	r2, [r3]
3000132c:	eaffffef 	b	300012f0 <run_clean_boot+0x44>
		}else if(c == 0x1b){
30001330:	e35c001b 	cmp	ip, #27	; 0x1b
30001334:	e59f0060 	ldr	r0, [pc, #96]	; 3000139c <.text+0x139c>
30001338:	e3a01000 	mov	r1, #0	; 0x0
3000133c:	e3a02020 	mov	r2, #32	; 0x20
30001340:	e59f4058 	ldr	r4, [pc, #88]	; 300013a0 <.text+0x13a0>
30001344:	1a000005 	bne	30001360 <run_clean_boot+0xb4>
			lmemset(cmd_buf, 0, COM_MAX_LEN);
30001348:	ebffff9d 	bl	300011c4 <lmemset>
			cmd_buf_p = 0;
			lprint("\r\nCleanBoot@%s>", PLATFORM);
3000134c:	e59f0050 	ldr	r0, [pc, #80]	; 300013a4 <.text+0x13a4>
30001350:	e59f1050 	ldr	r1, [pc, #80]	; 300013a8 <.text+0x13a8>
30001354:	e3a03000 	mov	r3, #0	; 0x0
30001358:	e5843000 	str	r3, [r4]
3000135c:	eaffffe3 	b	300012f0 <run_clean_boot+0x44>
		}else{
			if(cmd_buf_p < (COM_MAX_LEN - 1)){
30001360:	e5942000 	ldr	r2, [r4]
30001364:	e352001e 	cmp	r2, #30	; 0x1e
30001368:	e1a0000c 	mov	r0, ip
3000136c:	e2823001 	add	r3, r2, #1	; 0x1
30001370:	8affffdf 	bhi	300012f4 <run_clean_boot+0x48>
				cmd_buf[cmd_buf_p++] = c;
30001374:	e5843000 	str	r3, [r4]
30001378:	e59f301c 	ldr	r3, [pc, #28]	; 3000139c <.text+0x139c>
3000137c:	e7c2c003 	strb	ip, [r2, r3]
				con_send(c);
30001380:	ebfffd63 	bl	30000914 <s3c2440_serial_send_byte>
30001384:	eaffffda 	b	300012f4 <run_clean_boot+0x48>
30001388:	30002450 	andcc	r2, r0, r0, asr r4
3000138c:	300023c4 	andcc	r2, r0, r4, asr #7
30001390:	300023d0 	ldrccd	r2, [r0], -r0
30001394:	30001eec 	andcc	r1, r0, ip, ror #29
30001398:	30002404 	andcc	r2, r0, r4, lsl #8
3000139c:	30002454 	andcc	r2, r0, r4, asr r4
300013a0:	3000244c 	andcc	r2, r0, ip, asr #8
300013a4:	30002410 	andcc	r2, r0, r0, lsl r4
300013a8:	30002420 	andcc	r2, r0, r0, lsr #8

300013ac <main>:
#include "print.h"

void main()
{
	run_clean_boot();
300013ac:	eaffffbe 	b	300012ac <run_clean_boot>

300013b0 <print_string>:
#include "debug.h"
#include "print.h"

void print_string(unsigned char *s)
{
300013b0:	e92d4010 	stmdb	sp!, {r4, lr}
300013b4:	e1a04000 	mov	r4, r0
        unsigned char c;
        while(1){
                if(!(c = *s++))
300013b8:	e4d43001 	ldrb	r3, [r4], #1
300013bc:	e2530000 	subs	r0, r3, #0	; 0x0
300013c0:	08bd8010 	ldmeqia	sp!, {r4, pc}
                        break;
                con_send(c);
300013c4:	ebfffd52 	bl	30000914 <s3c2440_serial_send_byte>
300013c8:	eafffffa 	b	300013b8 <print_string+0x8>

300013cc <halfbyte2char>:
        }
        return;

}

unsigned char halfbyte2char(unsigned char c)
{
        return ((c & 0x0f) < 0x0a)?(0x30 + c):('A' + c - 0x0a);
300013cc:	e200300f 	and	r3, r0, #15	; 0xf
300013d0:	e20000ff 	and	r0, r0, #255	; 0xff
300013d4:	e3530009 	cmp	r3, #9	; 0x9
300013d8:	e2803030 	add	r3, r0, #48	; 0x30
300013dc:	e2800037 	add	r0, r0, #55	; 0x37
300013e0:	e20330ff 	and	r3, r3, #255	; 0xff
300013e4:	c20030ff 	andgt	r3, r0, #255	; 0xff
}
300013e8:	e1a00003 	mov	r0, r3
300013ec:	e1a0f00e 	mov	pc, lr

300013f0 <div>:

uint div(uint beichushu, uint chushu)
{
    uint shang = 0, tmp = 0;
300013f0:	e3a0c000 	mov	ip, #0	; 0x0
300013f4:	e52de004 	str	lr, [sp, #-4]!
300013f8:	e1a0200c 	mov	r2, ip
    const unsigned char bit_of_uint = 8 * sizeof(uint);
    unsigned char n = bit_of_uint;

    while(n--){
300013fc:	e3a0e01f 	mov	lr, #31	; 0x1f
        tmp = (tmp<<1) + (beichushu>>(bit_of_uint - 1));
30001400:	e24e3001 	sub	r3, lr, #1	; 0x1
30001404:	e203e0ff 	and	lr, r3, #255	; 0xff
30001408:	e1a03fa0 	mov	r3, r0, lsr #31
3000140c:	e0832082 	add	r2, r3, r2, lsl #1
        beichushu<<=1;
        shang = shang<<1;
        if(tmp >= chushu){
30001410:	e1520001 	cmp	r2, r1
30001414:	e1a0c08c 	mov	ip, ip, lsl #1
                tmp = tmp - chushu;
                shang++;
30001418:	228cc001 	addcs	ip, ip, #1	; 0x1
3000141c:	20612002 	rsbcs	r2, r1, r2
30001420:	e35e00ff 	cmp	lr, #255	; 0xff
30001424:	e1a00080 	mov	r0, r0, lsl #1
30001428:	01a0000c 	moveq	r0, ip
3000142c:	049df004 	ldreq	pc, [sp], #4
30001430:	eafffff2 	b	30001400 <div+0x10>

30001434 <num2str>:
        }
    }
    return shang;
}

unsigned char * num2str(uint jt, unsigned char * s, unsigned char n)
{
30001434:	e92d4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
30001438:	e20290ff 	and	r9, r2, #255	; 0xff
        unsigned char * st, k = 1, j;
        uint tmp;

        st = s;
        if(n > 16 || n < 2){
3000143c:	e2493002 	sub	r3, r9, #2	; 0x2
30001440:	e353000e 	cmp	r3, #14	; 0xe
                *st++ = 0x30;
30001444:	83a03030 	movhi	r3, #48	; 0x30
30001448:	85c13000 	strhib	r3, [r1]
                *st = 0;
3000144c:	83a03000 	movhi	r3, #0	; 0x0
30001450:	e1a0b001 	mov	fp, r1
30001454:	e1a07000 	mov	r7, r0
30001458:	e3a05001 	mov	r5, #1	; 0x1
3000145c:	e1a0a001 	mov	sl, r1
30001460:	85c13001 	strhib	r3, [r1, #1]
                return s;
30001464:	8a00001f 	bhi	300014e8 <num2str+0xb4>
        }
        tmp = 1;
30001468:	e1a06005 	mov	r6, r5
        while(div(jt, tmp) >= n){
                k++;
                tmp *= n;
3000146c:	e1a01006 	mov	r1, r6
30001470:	e1a00007 	mov	r0, r7
30001474:	ebffffdd 	bl	300013f0 <div>
30001478:	e2853001 	add	r3, r5, #1	; 0x1
3000147c:	e1500009 	cmp	r0, r9
30001480:	20060699 	mulcs	r6, r9, r6
30001484:	220350ff 	andcs	r5, r3, #255	; 0xff
30001488:	2afffff7 	bcs	3000146c <num2str+0x38>
        }

        while(k--){
3000148c:	e2453001 	sub	r3, r5, #1	; 0x1
30001490:	e20350ff 	and	r5, r3, #255	; 0xff
30001494:	e35500ff 	cmp	r5, #255	; 0xff
30001498:	0a000010 	beq	300014e0 <num2str+0xac>
                j = div(jt, tmp);
3000149c:	e1a01006 	mov	r1, r6
300014a0:	e1a00007 	mov	r0, r7
300014a4:	ebffffd1 	bl	300013f0 <div>
300014a8:	e20040ff 	and	r4, r0, #255	; 0xff
                *st++ = halfbyte2char(j);
300014ac:	e1a00004 	mov	r0, r4
300014b0:	ebffffc5 	bl	300013cc <halfbyte2char>
                jt -= tmp * j;
300014b4:	e0030694 	mul	r3, r4, r6
300014b8:	e4ca0001 	strb	r0, [sl], #1
                tmp = div(tmp, n);
300014bc:	e1a01009 	mov	r1, r9
300014c0:	e1a00006 	mov	r0, r6
300014c4:	e0637007 	rsb	r7, r3, r7
300014c8:	ebffffc8 	bl	300013f0 <div>
300014cc:	e2453001 	sub	r3, r5, #1	; 0x1
300014d0:	e20350ff 	and	r5, r3, #255	; 0xff
300014d4:	e35500ff 	cmp	r5, #255	; 0xff
300014d8:	e1a06000 	mov	r6, r0
300014dc:	1affffee 	bne	3000149c <num2str+0x68>
        }
        *st = 0;
300014e0:	e3a03000 	mov	r3, #0	; 0x0
300014e4:	e5ca3000 	strb	r3, [sl]
        return s;
}
300014e8:	e1a0000b 	mov	r0, fp
300014ec:	e8bd8ef0 	ldmia	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}

300014f0 <print_uint>:

void print_uint(uint num)
{
300014f0:	e92d4010 	stmdb	sp!, {r4, lr}
300014f4:	e24dd00c 	sub	sp, sp, #12	; 0xc
        unsigned char nc[11];
        num2str(num, nc, 10);
300014f8:	e1a0100d 	mov	r1, sp
300014fc:	e3a0200a 	mov	r2, #10	; 0xa
30001500:	ebffffcb 	bl	30001434 <num2str>
        print_string(nc);
30001504:	e1a0000d 	mov	r0, sp
30001508:	e1a0400d 	mov	r4, sp
3000150c:	ebffffa7 	bl	300013b0 <print_string>
30001510:	e28dd00c 	add	sp, sp, #12	; 0xc
30001514:	e8bd8010 	ldmia	sp!, {r4, pc}

30001518 <print_hex>:
}

void print_hex(uint num)
{
30001518:	e92d4010 	stmdb	sp!, {r4, lr}
3000151c:	e24dd00c 	sub	sp, sp, #12	; 0xc
        unsigned char nc[9];
        num2str(num, nc, 16);
30001520:	e1a0100d 	mov	r1, sp
30001524:	e3a02010 	mov	r2, #16	; 0x10
30001528:	ebffffc1 	bl	30001434 <num2str>
        print_string(nc);
3000152c:	e1a0000d 	mov	r0, sp
30001530:	e1a0400d 	mov	r4, sp
30001534:	ebffff9d 	bl	300013b0 <print_string>
30001538:	e28dd00c 	add	sp, sp, #12	; 0xc
3000153c:	e8bd8010 	ldmia	sp!, {r4, pc}

30001540 <lprint>:
}

void lprint(const unsigned char * fmt, ...)
{
30001540:	e92d000f 	stmdb	sp!, {r0, r1, r2, r3}
30001544:	e92d4030 	stmdb	sp!, {r4, r5, lr}
30001548:	e59d400c 	ldr	r4, [sp, #12]
    const unsigned char *s;
    uint d;
    va_list ap;

    va_start(ap, fmt);
    while (*fmt) {
3000154c:	e5d40000 	ldrb	r0, [r4]
30001550:	e3500000 	cmp	r0, #0	; 0x0
30001554:	e28d5010 	add	r5, sp, #16	; 0x10
30001558:	0a000022 	beq	300015e8 <lprint+0xa8>
        if (*fmt != '%') {
3000155c:	e20000ff 	and	r0, r0, #255	; 0xff
30001560:	e3500025 	cmp	r0, #37	; 0x25
30001564:	e2844001 	add	r4, r4, #1	; 0x1
30001568:	0a000001 	beq	30001574 <lprint+0x34>
	    con_send(*fmt++);
3000156c:	ebfffce8 	bl	30000914 <s3c2440_serial_send_byte>
            continue;
30001570:	ea000019 	b	300015dc <lprint+0x9c>
        }
        switch (*++fmt) {
30001574:	e5d40000 	ldrb	r0, [r4]
30001578:	e3500073 	cmp	r0, #115	; 0x73
3000157c:	0a000008 	beq	300015a4 <lprint+0x64>
30001580:	ca000004 	bgt	30001598 <lprint+0x58>
30001584:	e3500025 	cmp	r0, #37	; 0x25
30001588:	0a000011 	beq	300015d4 <lprint+0x94>
3000158c:	e3500064 	cmp	r0, #100	; 0x64
30001590:	0a000006 	beq	300015b0 <lprint+0x70>
30001594:	ea00000b 	b	300015c8 <lprint+0x88>
30001598:	e3500078 	cmp	r0, #120	; 0x78
3000159c:	0a000006 	beq	300015bc <lprint+0x7c>
300015a0:	ea000008 	b	300015c8 <lprint+0x88>
	    case '%':
	        con_send(*fmt);
		break;
            case 's':
                s = va_arg(ap, const unsigned char *);
300015a4:	e4950004 	ldr	r0, [r5], #4
                print_string(s);
300015a8:	ebffff80 	bl	300013b0 <print_string>
                break;
300015ac:	ea000009 	b	300015d8 <lprint+0x98>
            case 'd':
                d = va_arg(ap, int);
300015b0:	e4950004 	ldr	r0, [r5], #4
                print_uint(d);
300015b4:	ebffffcd 	bl	300014f0 <print_uint>
                break;
300015b8:	ea000006 	b	300015d8 <lprint+0x98>
	    /*
	    case 'c':
                d = va_arg(ap, char);
                send_int(d);
                break;
	    */
	    case 'x':
                d = va_arg(ap, uint);
300015bc:	e4950004 	ldr	r0, [r5], #4
                print_hex(d);
300015c0:	ebffffd4 	bl	30001518 <print_hex>
                break;
300015c4:	ea000003 	b	300015d8 <lprint+0x98>
            /* Add other specifiers here... */             
            default: 
                con_send(*(fmt-1));
300015c8:	e5540001 	ldrb	r0, [r4, #-1]
300015cc:	ebfffcd0 	bl	30000914 <s3c2440_serial_send_byte>
		con_send(*fmt);
300015d0:	e5d40000 	ldrb	r0, [r4]
300015d4:	ebfffcce 	bl	30000914 <s3c2440_serial_send_byte>
                break;
        }
        fmt++;
300015d8:	e2844001 	add	r4, r4, #1	; 0x1
300015dc:	e5d40000 	ldrb	r0, [r4]
300015e0:	e3500000 	cmp	r0, #0	; 0x0
300015e4:	1affffdc 	bne	3000155c <lprint+0x1c>
    }
    va_end(ap);
    return;   
300015e8:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
300015ec:	e28dd010 	add	sp, sp, #16	; 0x10
300015f0:	e1a0f00e 	mov	pc, lr

300015f4 <crc16>:
uint crc16(unsigned char *c, uint len)
{
	uint crc16_check = 0, j;

	while(len--)
300015f4:	e2411001 	sub	r1, r1, #1	; 0x1
300015f8:	e3710001 	cmn	r1, #1	; 0x1
300015fc:	e52de004 	str	lr, [sp, #-4]!
30001600:	e1a0e000 	mov	lr, r0
30001604:	e3a00000 	mov	r0, #0	; 0x0
30001608:	0a00000e 	beq	30001648 <crc16+0x54>
	{
		crc16_check = crc16_check ^ (uint)*c++ << 8;
3000160c:	e4de3001 	ldrb	r3, [lr], #1
		for (j=0;j<8;j++)
30001610:	e3a0c000 	mov	ip, #0	; 0x0
30001614:	e0200403 	eor	r0, r0, r3, lsl #8
		{
			if(crc16_check & 0x8000)
30001618:	e59f3034 	ldr	r3, [pc, #52]	; 30001654 <.text+0x1654>
3000161c:	e1a02080 	mov	r2, r0, lsl #1
30001620:	e3100902 	tst	r0, #32768	; 0x8000
30001624:	e0220003 	eor	r0, r2, r3
30001628:	e28c3001 	add	r3, ip, #1	; 0x1
				crc16_check = crc16_check << 1 ^ 0x1021;
			else
				crc16_check <<= 1;
3000162c:	01a00002 	moveq	r0, r2
30001630:	e3530007 	cmp	r3, #7	; 0x7
30001634:	e1a0c003 	mov	ip, r3
30001638:	9afffff6 	bls	30001618 <crc16+0x24>
3000163c:	e2411001 	sub	r1, r1, #1	; 0x1
30001640:	e3710001 	cmn	r1, #1	; 0x1
30001644:	1afffff0 	bne	3000160c <crc16+0x18>
		}
	}
	return crc16_check & 0xffff;
30001648:	e1a00800 	mov	r0, r0, lsl #16
3000164c:	e1a00820 	mov	r0, r0, lsr #16
}
30001650:	e49df004 	ldr	pc, [sp], #4
30001654:	00001021 	andeq	r1, r0, r1, lsr #32

30001658 <time_limit_recv_byte>:

uint time_limit_recv_byte(uint limit, unsigned char * c)
{
30001658:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	while(limit--){
3000165c:	e2404001 	sub	r4, r0, #1	; 0x1
30001660:	e3740001 	cmn	r4, #1	; 0x1
30001664:	e1a05001 	mov	r5, r1
30001668:	0a000009 	beq	30001694 <time_limit_recv_byte+0x3c>
		if(is_con_recv()){
3000166c:	ebfffcbc 	bl	30000964 <s3c2440_is_serial_recv>
30001670:	e3500000 	cmp	r0, #0	; 0x0
30001674:	e2444001 	sub	r4, r4, #1	; 0x1
30001678:	0a000003 	beq	3000168c <time_limit_recv_byte+0x34>
			*c = con_recv();
3000167c:	ebfffcae 	bl	3000093c <s3c2440_serial_recv_byte>
			return 0;
30001680:	e3a03000 	mov	r3, #0	; 0x0
30001684:	e5c50000 	strb	r0, [r5]
30001688:	ea000002 	b	30001698 <time_limit_recv_byte+0x40>
3000168c:	e3740001 	cmn	r4, #1	; 0x1
30001690:	1afffff5 	bne	3000166c <time_limit_recv_byte+0x14>
		}
	}
	return 1;
30001694:	e3a03001 	mov	r3, #1	; 0x1
}
30001698:	e1a00003 	mov	r0, r3
3000169c:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

300016a0 <xmodem_1k_recv>:

uint xmodem_1k_recv(unsigned char*p)
{
300016a0:	e92d44f0 	stmdb	sp!, {r4, r5, r6, r7, sl, lr}
        uint i = 128, tmp = 0xa0000, repeat = 66;
	unsigned char recved = 0, index = 1, check_sum = 0, *c;
300016a4:	e3a03000 	mov	r3, #0	; 0x0
300016a8:	e24dd004 	sub	sp, sp, #4	; 0x4
300016ac:	e5cd3003 	strb	r3, [sp, #3]

	c = p;
300016b0:	e1a0a000 	mov	sl, r0
300016b4:	e3a04042 	mov	r4, #66	; 0x42
300016b8:	e3a07001 	mov	r7, #1	; 0x1
	do{
                con_send(0x15);
300016bc:	e3a00015 	mov	r0, #21	; 0x15
300016c0:	ebfffc93 	bl	30000914 <s3c2440_serial_send_byte>
		if(time_limit_recv_byte(0x80000, &recved) == 0)
300016c4:	e3a00702 	mov	r0, #524288	; 0x80000
300016c8:	e28d1003 	add	r1, sp, #3	; 0x3
300016cc:	ebffffe1 	bl	30001658 <time_limit_recv_byte>
300016d0:	e3500000 	cmp	r0, #0	; 0x0
300016d4:	0a000002 	beq	300016e4 <xmodem_1k_recv+0x44>
			break;
	}while(repeat--);
300016d8:	e2444001 	sub	r4, r4, #1	; 0x1
300016dc:	e3740001 	cmn	r4, #1	; 0x1
300016e0:	1afffff5 	bne	300016bc <xmodem_1k_recv+0x1c>
	if(!repeat){
300016e4:	e3540000 	cmp	r4, #0	; 0x0
300016e8:	1a000003 	bne	300016fc <xmodem_1k_recv+0x5c>
		con_send(CAN);
300016ec:	e3a00018 	mov	r0, #24	; 0x18
300016f0:	ebfffc87 	bl	30000914 <s3c2440_serial_send_byte>
		return 1;
300016f4:	e3a00001 	mov	r0, #1	; 0x1
300016f8:	ea00003d 	b	300017f4 <xmodem_1k_recv+0x154>
	}
start_recv_package:
	if(recved != SOH){
300016fc:	e5dd3003 	ldrb	r3, [sp, #3]
30001700:	e3530001 	cmp	r3, #1	; 0x1
30001704:	1a000037 	bne	300017e8 <xmodem_1k_recv+0x148>
		con_send(CAN);
		return 2;
	}
	if(time_limit_recv_byte(0x20000, &recved) == 1){
30001708:	e28d6003 	add	r6, sp, #3	; 0x3
3000170c:	e3a00802 	mov	r0, #131072	; 0x20000
30001710:	e1a01006 	mov	r1, r6
30001714:	ebffffcf 	bl	30001658 <time_limit_recv_byte>
30001718:	e3500001 	cmp	r0, #1	; 0x1
3000171c:	0a000031 	beq	300017e8 <xmodem_1k_recv+0x148>
		con_send(CAN);
		return 2;
	}
	if(recved != index){
30001720:	e5dd3003 	ldrb	r3, [sp, #3]
30001724:	e1530007 	cmp	r3, r7
30001728:	1a00002e 	bne	300017e8 <xmodem_1k_recv+0x148>
		con_send(CAN);
		return 2;
	}
	if(time_limit_recv_byte(0x20000, &recved) == 1){
3000172c:	e3a00802 	mov	r0, #131072	; 0x20000
30001730:	e1a01006 	mov	r1, r6
30001734:	ebffffc7 	bl	30001658 <time_limit_recv_byte>
30001738:	e3500001 	cmp	r0, #1	; 0x1
3000173c:	0a000029 	beq	300017e8 <xmodem_1k_recv+0x148>
		con_send(CAN);
		return 2;
	}
	if((recved + index) != 0xff){
30001740:	e5dd3003 	ldrb	r3, [sp, #3]
30001744:	e0833007 	add	r3, r3, r7
30001748:	e35300ff 	cmp	r3, #255	; 0xff
3000174c:	1a000025 	bne	300017e8 <xmodem_1k_recv+0x148>
		con_send(CAN);
		return 2;
	}
	i = 128;
	check_sum = 0;
30001750:	e3a05000 	mov	r5, #0	; 0x0
	while(i--){
30001754:	e3a0407f 	mov	r4, #127	; 0x7f
		if(time_limit_recv_byte(0x20000, &recved) == 1){
30001758:	e3a00802 	mov	r0, #131072	; 0x20000
3000175c:	e1a01006 	mov	r1, r6
30001760:	ebffffbc 	bl	30001658 <time_limit_recv_byte>
30001764:	e3500001 	cmp	r0, #1	; 0x1
30001768:	e2444001 	sub	r4, r4, #1	; 0x1
3000176c:	0a00001d 	beq	300017e8 <xmodem_1k_recv+0x148>
			con_send(CAN);
			return 2;
		}
		*c++ = recved;
30001770:	e5dd2003 	ldrb	r2, [sp, #3]
		check_sum += recved;
30001774:	e3740001 	cmn	r4, #1	; 0x1
30001778:	e0853002 	add	r3, r5, r2
3000177c:	e20350ff 	and	r5, r3, #255	; 0xff
30001780:	e4ca2001 	strb	r2, [sl], #1
30001784:	1afffff3 	bne	30001758 <xmodem_1k_recv+0xb8>
	}
	if(time_limit_recv_byte(0x20000, &recved) == 1){
30001788:	e3a00802 	mov	r0, #131072	; 0x20000
3000178c:	e1a01006 	mov	r1, r6
30001790:	ebffffb0 	bl	30001658 <time_limit_recv_byte>
30001794:	e3500001 	cmp	r0, #1	; 0x1
30001798:	0a000012 	beq	300017e8 <xmodem_1k_recv+0x148>
		con_send(CAN);
		return 2;
	}
	if(recved != check_sum){
3000179c:	e5dd3003 	ldrb	r3, [sp, #3]
300017a0:	e1530005 	cmp	r3, r5
300017a4:	1a00000f 	bne	300017e8 <xmodem_1k_recv+0x148>
		con_send(CAN);
		return 2;
	}
	con_send(ACK);
300017a8:	e3a00006 	mov	r0, #6	; 0x6
300017ac:	ebfffc58 	bl	30000914 <s3c2440_serial_send_byte>
	if(time_limit_recv_byte(0x20000, &recved) == 1){
300017b0:	e1a01006 	mov	r1, r6
300017b4:	e3a00802 	mov	r0, #131072	; 0x20000
300017b8:	ebffffa6 	bl	30001658 <time_limit_recv_byte>
300017bc:	e3500001 	cmp	r0, #1	; 0x1
300017c0:	0a000008 	beq	300017e8 <xmodem_1k_recv+0x148>
		con_send(CAN);
		return 2;
	}
	if(recved == EOT){
300017c4:	e5dd3003 	ldrb	r3, [sp, #3]
300017c8:	e3530004 	cmp	r3, #4	; 0x4
		con_send(ACK);
		return 0;
	}
	index++;
300017cc:	12873001 	addne	r3, r7, #1	; 0x1
300017d0:	120370ff 	andne	r7, r3, #255	; 0xff
	goto start_recv_package;
300017d4:	1affffc8 	bne	300016fc <xmodem_1k_recv+0x5c>
300017d8:	e3a00006 	mov	r0, #6	; 0x6
300017dc:	ebfffc4c 	bl	30000914 <s3c2440_serial_send_byte>
300017e0:	e3a00000 	mov	r0, #0	; 0x0
300017e4:	ea000002 	b	300017f4 <xmodem_1k_recv+0x154>
300017e8:	e3a00018 	mov	r0, #24	; 0x18
300017ec:	ebfffc48 	bl	30000914 <s3c2440_serial_send_byte>
300017f0:	e3a00002 	mov	r0, #2	; 0x2
}
300017f4:	e28dd004 	add	sp, sp, #4	; 0x4
300017f8:	e8bd84f0 	ldmia	sp!, {r4, r5, r6, r7, sl, pc}

300017fc <xmodem_1k_send>:

uint xmodem_1k_send(unsigned char*c, uint len)
{
300017fc:	e92d4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
30001800:	e1a05000 	mov	r5, r0
30001804:	e24dd008 	sub	sp, sp, #8	; 0x8
        uint i = 128, check_way = 0; /*0-crc16 1-checksum*/
30001808:	e3a0a000 	mov	sl, #0	; 0x0
	unsigned char tmpchar = 0, index = 1, check_sum = 0, *clast;
	uint check_crc16;

	lprint("Please get the receiver ready!\r\n");
3000180c:	e59f0114 	ldr	r0, [pc, #276]	; 30001928 <.text+0x1928>
30001810:	e58d1000 	str	r1, [sp]
30001814:	e5cda007 	strb	sl, [sp, #7]
30001818:	e3a07001 	mov	r7, #1	; 0x1
3000181c:	ebffff47 	bl	30001540 <lprint>
	while(1){
		tmpchar = con_recv();
30001820:	ebfffc45 	bl	3000093c <s3c2440_serial_recv_byte>
30001824:	e5cd0007 	strb	r0, [sp, #7]
		if(tmpchar == 'C'){
30001828:	e5dd3007 	ldrb	r3, [sp, #7]
3000182c:	e3530043 	cmp	r3, #67	; 0x43
30001830:	0a000002 	beq	30001840 <xmodem_1k_send+0x44>
			break;
		}
		if(tmpchar == NACK){
30001834:	e3530015 	cmp	r3, #21	; 0x15
30001838:	1afffff8 	bne	30001820 <xmodem_1k_send+0x24>
			check_way = 1;
3000183c:	e3a0a001 	mov	sl, #1	; 0x1
			break;
		}
	}
start_send_package:
	if(index > len){
30001840:	e59d3000 	ldr	r3, [sp]
30001844:	e1570003 	cmp	r7, r3
30001848:	8a00002d 	bhi	30001904 <xmodem_1k_send+0x108>
		con_send(EOT);
		con_recv();
		time_limit_recv_byte(0x20000, &tmpchar);
		return 0;
	}
	con_send(SOH);
3000184c:	e3a00001 	mov	r0, #1	; 0x1
30001850:	ebfffc2f 	bl	30000914 <s3c2440_serial_send_byte>
	con_send(index);
30001854:	e1a00007 	mov	r0, r7
30001858:	ebfffc2d 	bl	30000914 <s3c2440_serial_send_byte>
	con_send(~index & 0xff);
3000185c:	e1e00007 	mvn	r0, r7
30001860:	e20000ff 	and	r0, r0, #255	; 0xff
30001864:	ebfffc2a 	bl	30000914 <s3c2440_serial_send_byte>
	i = 128;
	check_sum = 0;
	if(!check_way)
30001868:	e35a0000 	cmp	sl, #0	; 0x0
3000186c:	e3a04080 	mov	r4, #128	; 0x80
30001870:	e3a06000 	mov	r6, #0	; 0x0
30001874:	1a000003 	bne	30001888 <xmodem_1k_send+0x8c>
		check_crc16 = crc16(c, 128);
30001878:	e1a01004 	mov	r1, r4
3000187c:	e1a00005 	mov	r0, r5
30001880:	ebffff5b 	bl	300015f4 <crc16>
30001884:	e1a0b000 	mov	fp, r0
	clast = c;
30001888:	e1a09005 	mov	r9, r5
	while(i--){
3000188c:	e3a0407f 	mov	r4, #127	; 0x7f
		tmpchar = *c++;
30001890:	e4d53001 	ldrb	r3, [r5], #1
30001894:	e5cd3007 	strb	r3, [sp, #7]
		con_send(tmpchar);
30001898:	e5dd0007 	ldrb	r0, [sp, #7]
3000189c:	ebfffc1c 	bl	30000914 <s3c2440_serial_send_byte>
		check_sum += tmpchar;
300018a0:	e5dd3007 	ldrb	r3, [sp, #7]
300018a4:	e2444001 	sub	r4, r4, #1	; 0x1
300018a8:	e0863003 	add	r3, r6, r3
300018ac:	e3740001 	cmn	r4, #1	; 0x1
300018b0:	e20360ff 	and	r6, r3, #255	; 0xff
300018b4:	1afffff5 	bne	30001890 <xmodem_1k_send+0x94>
	}
	if(check_way)
300018b8:	e35a0000 	cmp	sl, #0	; 0x0
300018bc:	11a00006 	movne	r0, r6
300018c0:	1a000003 	bne	300018d4 <xmodem_1k_send+0xd8>
		con_send(check_sum);
	else{
		//con_send(0xb1);
		//con_send(0x47);
		con_send((check_crc16>>8) & 0xff);
300018c4:	e1a0042b 	mov	r0, fp, lsr #8
300018c8:	e20000ff 	and	r0, r0, #255	; 0xff
300018cc:	ebfffc10 	bl	30000914 <s3c2440_serial_send_byte>
		con_send(check_crc16 & 0xff);
300018d0:	e20b00ff 	and	r0, fp, #255	; 0xff
300018d4:	ebfffc0e 	bl	30000914 <s3c2440_serial_send_byte>
	}	
	tmpchar = con_recv();
300018d8:	ebfffc17 	bl	3000093c <s3c2440_serial_recv_byte>
300018dc:	e5cd0007 	strb	r0, [sp, #7]
	if(tmpchar == ACK)
300018e0:	e5dd3007 	ldrb	r3, [sp, #7]
300018e4:	e3530006 	cmp	r3, #6	; 0x6
300018e8:	02873001 	addeq	r3, r7, #1	; 0x1
300018ec:	020370ff 	andeq	r7, r3, #255	; 0xff
300018f0:	0affffd2 	beq	30001840 <xmodem_1k_send+0x44>
		index++;
	else if(tmpchar == NACK)
300018f4:	e3530015 	cmp	r3, #21	; 0x15
300018f8:	01a05009 	moveq	r5, r9
300018fc:	0affffcf 	beq	30001840 <xmodem_1k_send+0x44>
		c = clast;
	else
		while(1);
30001900:	eafffffe 	b	30001900 <xmodem_1k_send+0x104>
	goto start_send_package;
}
30001904:	e3a00004 	mov	r0, #4	; 0x4
30001908:	ebfffc01 	bl	30000914 <s3c2440_serial_send_byte>
3000190c:	ebfffc0a 	bl	3000093c <s3c2440_serial_recv_byte>
30001910:	e28d1007 	add	r1, sp, #7	; 0x7
30001914:	e3a00802 	mov	r0, #131072	; 0x20000
30001918:	ebffff4e 	bl	30001658 <time_limit_recv_byte>
3000191c:	e3a00000 	mov	r0, #0	; 0x0
30001920:	e28dd008 	add	sp, sp, #8	; 0x8
30001924:	e8bd8ef0 	ldmia	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}
30001928:	30002428 	andcc	r2, r0, r8, lsr #8
