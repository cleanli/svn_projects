
asm2440.elf:     file format elf32-littlearm

Disassembly of section .text:

30000000 <_start>:

.globl nand_read_ll
.globl main
.globl _start
_start:	b       start_code
30000000:	ea000017 	b	30000064 <start_code>
	b	_start
30000004:	eafffffd 	b	30000000 <_start>
	b	_start
30000008:	eafffffc 	b	30000000 <_start>
	b	_start
3000000c:	eafffffb 	b	30000000 <_start>
	b	_start
30000010:	eafffffa 	b	30000000 <_start>
	b	_start
30000014:	eafffff9 	b	30000000 <_start>
	b	_start
30000018:	eafffff8 	b	30000000 <_start>
	b	_start
3000001c:	eafffff7 	b	30000000 <_start>
	b	_start
30000020:	eafffff6 	b	30000000 <_start>
30000024:	deadbeef 	cdple	14, 10, cr11, cr13, cr15, {7}
30000028:	deadbeef 	cdple	14, 10, cr11, cr13, cr15, {7}
3000002c:	deadbeef 	cdple	14, 10, cr11, cr13, cr15, {7}

30000030 <mem_reg_value>:
30000030:	22111110 	andcss	r1, r1, #4	; 0x4
30000034:	00000700 	andeq	r0, r0, r0, lsl #14
30000038:	00000700 	andeq	r0, r0, r0, lsl #14
3000003c:	00000700 	andeq	r0, r0, r0, lsl #14
30000040:	00000700 	andeq	r0, r0, r0, lsl #14
30000044:	00000700 	andeq	r0, r0, r0, lsl #14
30000048:	00000700 	andeq	r0, r0, r0, lsl #14
3000004c:	00018009 	andeq	r8, r1, r9
30000050:	00018009 	andeq	r8, r1, r9
30000054:	00ac03f4 	streqd	r0, [ip], r4
30000058:	000000b2 	streqh	r0, [r0], -r2
3000005c:	00000030 	andeq	r0, r0, r0, lsr r0
30000060:	00000030 	andeq	r0, r0, r0, lsr r0

30000064 <start_code>:
	.balignl 16,0xdeadbeef
.align 4

mem_reg_value:
        .long   0x22111110
        .long   0x00000700
        .long   0x00000700
        .long   0x00000700
        .long   0x00000700
        .long   0x00000700
        .long   0x00000700
        .long   0x00018009
        .long   0x00018009
        .long   0x00ac03f4
        .long   0x000000b2
        .long   0x00000030
        .long   0x00000030
/*
 * the actual start code
 */

start_code:
	/*
	 * set the cpu to SVC32 mode
	 */
	mrs	r0,cpsr
30000064:	e10f0000 	mrs	r0, CPSR
	bic	r0,r0,#0x1f
30000068:	e3c0001f 	bic	r0, r0, #31	; 0x1f
	orr	r0,r0,#0xd3
3000006c:	e38000d3 	orr	r0, r0, #211	; 0xd3
	msr	cpsr,r0
30000070:	e129f000 	msr	CPSR_fc, r0


#  define pWTCON		0x53000000
#  define INTMSK		0x4A000008	/* Interupt-Controller base addresses */
#  define INTSUBMSK	0x4A00001C
#  define CLKDIVN	0x4C000014	/* clock divisor register */

	ldr     r0, =pWTCON
30000074:	e3a00453 	mov	r0, #1392508928	; 0x53000000
	mov     r1, #0x0
30000078:	e3a01000 	mov	r1, #0	; 0x0
	str     r1, [r0]
3000007c:	e5801000 	str	r1, [r0]

/*init sp*/
	@ldr	sp, =0x00000ff8
	ldr	sp, =0x30101000
30000080:	e59fd1c4 	ldr	sp, [pc, #452]	; 3000024c <.text+0x24c>

	/*
	 * mask all IRQs by setting all bits in the INTMR - default
	 */
	mov	r1, #0xffffffff
30000084:	e3e01000 	mvn	r1, #0	; 0x0
	ldr	r0, =INTMSK
30000088:	e59f01c0 	ldr	r0, [pc, #448]	; 30000250 <.text+0x250>
	str	r1, [r0]
3000008c:	e5801000 	str	r1, [r0]

	ldr	r1, =0x7ff
30000090:	e59f11bc 	ldr	r1, [pc, #444]	; 30000254 <.text+0x254>
	ldr	r0, =INTSUBMSK
30000094:	e59f01bc 	ldr	r0, [pc, #444]	; 30000258 <.text+0x258>
	str	r1, [r0]
30000098:	e5801000 	str	r1, [r0]

/*******************************************************************************/
#  define GPFCON                0x56000050
#  define GPFDAT                0x56000054      /*  */
#  define LOCKTIME              0x4C000000
#  define MPLLCON               0x4C000004
#  define UPLLCON               0x4C000008

        ldr     r0, =GPFCON
3000009c:	e59f01b8 	ldr	r0, [pc, #440]	; 3000025c <.text+0x25c>
        mov     r1, #0x5500
300000a0:	e3a01c55 	mov	r1, #21760	; 0x5500
        str     r1, [r0]
300000a4:	e5801000 	str	r1, [r0]

        @initialize clock
        ldr     r0, =LOCKTIME
300000a8:	e3a00313 	mov	r0, #1275068416	; 0x4c000000
        ldr     r1, =0x00ffffff
300000ac:	e3e014ff 	mvn	r1, #-16777216	; 0xff000000
        str     r1, [r0]
300000b0:	e5801000 	str	r1, [r0]
        /* FCLK:HCLK:PCLK = 1:4:8 */
        ldr     r0, =CLKDIVN
300000b4:	e59f01a4 	ldr	r0, [pc, #420]	; 30000260 <.text+0x260>
        mov     r1, #5
300000b8:	e3a01005 	mov	r1, #5	; 0x5
        str     r1, [r0]
300000bc:	e5801000 	str	r1, [r0]
        @open code cache
        mrc     p15,0,r1,c1,c0,0
300000c0:	ee111f10 	mrc	15, 0, r1, cr1, cr0, {0}
        orr     r1,r1,#0xc0000000
300000c4:	e3811103 	orr	r1, r1, #-1073741824	; 0xc0000000
        mcr     p15,0,r1,c1,c0,0
300000c8:	ee011f10 	mcr	15, 0, r1, cr1, cr0, {0}
        @UPLL setup
        ldr     r0, =UPLLCON
300000cc:	e59f0190 	ldr	r0, [pc, #400]	; 30000264 <.text+0x264>
        ldr     r1, =(0x38<<12|0x2<<4|0x2)
300000d0:	e59f1190 	ldr	r1, [pc, #400]	; 30000268 <.text+0x268>
        str     r1, [r0]
300000d4:	e5801000 	str	r1, [r0]
        nop
300000d8:	e1a00000 	nop			(mov r0,r0)
        nop
300000dc:	e1a00000 	nop			(mov r0,r0)
        nop
300000e0:	e1a00000 	nop			(mov r0,r0)
        nop
300000e4:	e1a00000 	nop			(mov r0,r0)
        nop
300000e8:	e1a00000 	nop			(mov r0,r0)
        nop
300000ec:	e1a00000 	nop			(mov r0,r0)
        nop
300000f0:	e1a00000 	nop			(mov r0,r0)

        @MPLL setup
        ldr     r0, =MPLLCON
300000f4:	e59f0170 	ldr	r0, [pc, #368]	; 3000026c <.text+0x26c>
        ldr     r1, =0x7f021
300000f8:	e59f1170 	ldr	r1, [pc, #368]	; 30000270 <.text+0x270>
        str     r1, [r0]
300000fc:	e5801000 	str	r1, [r0]
        nop
30000100:	e1a00000 	nop			(mov r0,r0)
        nop
30000104:	e1a00000 	nop			(mov r0,r0)
        nop
30000108:	e1a00000 	nop			(mov r0,r0)
        nop
3000010c:	e1a00000 	nop			(mov r0,r0)
        nop
30000110:	e1a00000 	nop			(mov r0,r0)
        nop
30000114:	e1a00000 	nop			(mov r0,r0)
        nop
30000118:	e1a00000 	nop			(mov r0,r0)

        @memsetup
        ldr     r0, =0x48000000
3000011c:	e3a00312 	mov	r0, #1207959552	; 0x48000000
        adrl    r1, mem_reg_value
30000120:	e24f10f8 	sub	r1, pc, #248	; 0xf8
30000124:	e1a00000 	nop			(mov r0,r0)
        ldr     r2, =0x48000030
30000128:	e59f2144 	ldr	r2, [pc, #324]	; 30000274 <.text+0x274>

3000012c <loop10>:
loop10:
        ldr     r4, [r1], #4
3000012c:	e4914004 	ldr	r4, [r1], #4
        str     r4, [r0], #4
30000130:	e4804004 	str	r4, [r0], #4
        cmp     r2, r0
30000134:	e1520000 	cmp	r2, r0
        bne     loop10
30000138:	1afffffb 	bne	3000012c <loop10>

        ldr     r0, =GPFDAT
3000013c:	e59f0134 	ldr	r0, [pc, #308]	; 30000278 <.text+0x278>
        mov     r1, #0x50
30000140:	e3a01050 	mov	r1, #80	; 0x50
        str     r1, [r0]
30000144:	e5801000 	str	r1, [r0]

#define GPHCON  0x56000070
#define GPHUP   0x56000078
#define ULCON0  0x50000000
#define UCCON0  0x50000004
#define UFCON0  0x50000008
#define USCON0  0x50000010
#define UTXH0   0x50000020
#define URXH0   0x50000024
#define UBRDIV0 0x50000028

/*Init serial port 0*/
        ldr     r0, =GPHCON
30000148:	e59f012c 	ldr	r0, [pc, #300]	; 3000027c <.text+0x27c>
        ldr     r1, =0xaaa0
3000014c:	e59f112c 	ldr	r1, [pc, #300]	; 30000280 <.text+0x280>
        str     r1, [r0]
30000150:	e5801000 	str	r1, [r0]
        ldr     r0, =GPHUP
30000154:	e59f0128 	ldr	r0, [pc, #296]	; 30000284 <.text+0x284>
        ldr     r1, =0x7ff
30000158:	e59f10f4 	ldr	r1, [pc, #244]	; 30000254 <.text+0x254>
        str     r1, [r0]
3000015c:	e5801000 	str	r1, [r0]
        ldr     r0, =ULCON0
30000160:	e3a00205 	mov	r0, #1342177280	; 0x50000000
        mov     r1, #0x3
30000164:	e3a01003 	mov	r1, #3	; 0x3
        str     r1, [r0]
30000168:	e5801000 	str	r1, [r0]
        ldr     r0, =UCCON0
3000016c:	e3a00245 	mov	r0, #1342177284	; 0x50000004
        mov     r1, #0x5
30000170:	e3a01005 	mov	r1, #5	; 0x5
        str     r1, [r0]
30000174:	e5801000 	str	r1, [r0]
        ldr     r0, =UBRDIV0
30000178:	e59f0108 	ldr	r0, [pc, #264]	; 30000288 <.text+0x288>
        mov     r1, #0x1b
3000017c:	e3a0101b 	mov	r1, #27	; 0x1b
        str     r1, [r0]        /*set baudrate 115200bps*/
30000180:	e5801000 	str	r1, [r0]
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
@ copy code to ram from nand
@
#define NAND_CTL_BASE   0x4e000000
#define oNFCONF         0x0
#define oNFCONT         0x4
#define oNFCMD          0x8
#define oNFSTAT         0x20

        @ reset NAND
        mov     r1, #NAND_CTL_BASE
30000184:	e3a0144e 	mov	r1, #1308622848	; 0x4e000000
        ldr     r2, =( (7<<12)|(7<<8)|(7<<4)|(0<<0) )
30000188:	e59f20fc 	ldr	r2, [pc, #252]	; 3000028c <.text+0x28c>
        str     r2, [r1, #oNFCONF]
3000018c:	e5812000 	str	r2, [r1]
        ldr     r2, [r1, #oNFCONF]
30000190:	e5912000 	ldr	r2, [r1]

        ldr     r2, =( (1<<4)|(0<<1)|(1<<0) ) @ Active low CE Control
30000194:	e3a02011 	mov	r2, #17	; 0x11
        str     r2, [r1, #oNFCONT]
30000198:	e5812004 	str	r2, [r1, #4]
        ldr     r2, [r1, #oNFCONT]
3000019c:	e5912004 	ldr	r2, [r1, #4]

        ldr     r2, =(0x6)              @ RnB Clear
300001a0:	e3a02006 	mov	r2, #6	; 0x6
        str     r2, [r1, #oNFSTAT]
300001a4:	e5812020 	str	r2, [r1, #32]
        ldr     r2, [r1, #oNFSTAT]
300001a8:	e5912020 	ldr	r2, [r1, #32]

        mov     r2, #0xff               @ RESET command
300001ac:	e3a020ff 	mov	r2, #255	; 0xff
        strb    r2, [r1, #oNFCMD]
300001b0:	e5c12008 	strb	r2, [r1, #8]
        mov     r3, #0                  @ wait
300001b4:	e3a03000 	mov	r3, #0	; 0x0
1:      add     r3, r3, #0x1
300001b8:	e2833001 	add	r3, r3, #1	; 0x1
        cmp     r3, #0xa
300001bc:	e353000a 	cmp	r3, #10	; 0xa
        blt     1b
300001c0:	bafffffc 	blt	300001b8 <loop10+0x8c>
2:      ldr     r2, [r1, #oNFSTAT]      @ wait ready
300001c4:	e5912020 	ldr	r2, [r1, #32]
        tst     r2, #0x4
300001c8:	e3120004 	tst	r2, #4	; 0x4
        beq     2b
300001cc:	0afffffc 	beq	300001c4 <loop10+0x98>

        ldr     r2, [r1, #oNFCONT]
300001d0:	e5912004 	ldr	r2, [r1, #4]
        orr     r2, r2, #0x2            @ Flash Memory Chip Disable
300001d4:	e3822002 	orr	r2, r2, #2	; 0x2
        str     r2, [r1, #oNFCONT]
300001d8:	e5812004 	str	r2, [r1, #4]
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	@judge if in steppingstone
	mov	r0, pc
300001dc:	e1a0000f 	mov	r0, pc
	cmp	r0, #0x30000000
300001e0:	e3500203 	cmp	r0, #805306368	; 0x30000000
	bgt	jump_to_ram	@not in steppingstone, already in dram, go without copying nand code
300001e4:	ca00000f 	bgt	30000228 <jump_to_ram>

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

        @ get ready to call C functions (for nand_read())
        @ldr     sp, DW_STACK_START      @ has been setuped at start
        mov     fp, #0                  @ no previous frame, so fp=0
300001e8:	e3a0b000 	mov	fp, #0	; 0x0

#define TEXT_RAM_BASE   0x30000000
#define TEXT_NAND_BASE  0x0
#define TEXT_SIZE       0x100000

        @ copy
        ldr     r0, =TEXT_RAM_BASE
300001ec:	e3a00203 	mov	r0, #805306368	; 0x30000000
        ldr     r1, =TEXT_NAND_BASE
300001f0:	e3a01000 	mov	r1, #0	; 0x0
        ldr     r2, =TEXT_SIZE
300001f4:	e3a02601 	mov	r2, #1048576	; 0x100000
        bl      nand_read_ll
300001f8:	eb000041 	bl	30000304 <nand_read_ll>

        tst     r0, #0x0
300001fc:	e3100000 	tst	r0, #0	; 0x0
        bne     bad_nand_read
30000200:	1a00000d 	bne	3000023c <bad_nand_read>

        @ verify
        mov     r0, #0
30000204:	e3a00000 	mov	r0, #0	; 0x0
        ldr     r1, =TEXT_NAND_BASE
30000208:	e3a01000 	mov	r1, #0	; 0x0
        mov     r2, #0x400      @ 4 bytes * 1024 = 4K-bytes
3000020c:	e3a02b01 	mov	r2, #1024	; 0x400

30000210 <go_next>:
go_next:
        ldr     r3, [r0], #4
30000210:	e4903004 	ldr	r3, [r0], #4
        ldr     r4, [r1], #4
30000214:	e4914004 	ldr	r4, [r1], #4
        teq     r3, r4
30000218:	e1330004 	teq	r3, r4
        bne     bad_nand_read
3000021c:	1a000006 	bne	3000023c <bad_nand_read>
        subs    r2, r2, #4
30000220:	e2522004 	subs	r2, r2, #4	; 0x4
        bne     go_next
30000224:	1afffff9 	bne	30000210 <go_next>

30000228 <jump_to_ram>:
	
	@jump to ram to run
jump_to_ram:
	ldr     r1, =here_is_ram
30000228:	e59f1060 	ldr	r1, [pc, #96]	; 30000290 <.text+0x290>
        add     pc, r1, #0
3000022c:	e281f000 	add	pc, r1, #0	; 0x0
        nop
30000230:	e1a00000 	nop			(mov r0,r0)
        nop
30000234:	e1a00000 	nop			(mov r0,r0)
        b       .              @ infinite loop
30000238:	eafffffe 	b	30000238 <jump_to_ram+0x10>

3000023c <bad_nand_read>:
bad_nand_read:
        mov    	r0, #'E'
3000023c:	e3a00045 	mov	r0, #69	; 0x45
	bl	s3c2440_serial_send_byte
30000240:	eb000154 	bl	30000798 <s3c2440_serial_send_byte>
	b	.
30000244:	eafffffe 	b	30000244 <bad_nand_read+0x8>

30000248 <here_is_ram>:

here_is_ram:
        b       main
30000248:	ea0003a5 	b	300010e4 <main>
3000024c:	30101000 	andccs	r1, r0, r0
30000250:	4a000008 	bmi	30000278 <.text+0x278>
30000254:	000007ff 	streqd	r0, [r0], -pc
30000258:	4a00001c 	bmi	300002d0 <nand_reset+0x30>
3000025c:	56000050 	undefined
30000260:	4c000014 	stcmi	0, cr0, [r0], {20}
30000264:	4c000008 	stcmi	0, cr0, [r0], {8}
30000268:	00038022 	andeq	r8, r3, r2, lsr #32
3000026c:	4c000004 	stcmi	0, cr0, [r0], {4}
30000270:	0007f021 	andeq	pc, r7, r1, lsr #32
30000274:	48000030 	stmmida	r0, {r4, r5}
30000278:	56000054 	undefined
3000027c:	56000070 	undefined
30000280:	0000aaa0 	andeq	sl, r0, r0, lsr #21
30000284:	56000078 	undefined
30000288:	50000028 	andpl	r0, r0, r8, lsr #32
3000028c:	00007770 	andeq	r7, r0, r0, ror r7
30000290:	30000248 	andcc	r0, r0, r8, asr #4
30000294:	e1a00000 	nop			(mov r0,r0)
30000298:	e1a00000 	nop			(mov r0,r0)
3000029c:	e1a00000 	nop			(mov r0,r0)

300002a0 <nand_reset>:

void nand_reset()
{
	uint tmp = 10;
	NFCONF = (7<<12)|(7<<8)|(7<<4)|(0<<0);
300002a0:	e59f204c 	ldr	r2, [pc, #76]	; 300002f4 <.text+0x2f4>
300002a4:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
300002a8:	e5832000 	str	r2, [r3]
	NFCONT = (1<<4)|(0<<1)|(1<<0);
300002ac:	e59f3044 	ldr	r3, [pc, #68]	; 300002f8 <.text+0x2f8>
300002b0:	e3a02011 	mov	r2, #17	; 0x11
300002b4:	e5832000 	str	r2, [r3]
	NFSTAT = 0x4;
300002b8:	e59f303c 	ldr	r3, [pc, #60]	; 300002fc <.text+0x2fc>
300002bc:	e3a02004 	mov	r2, #4	; 0x4
300002c0:	e5c32000 	strb	r2, [r3]
	NFCMD = 0xff;
300002c4:	e59f3034 	ldr	r3, [pc, #52]	; 30000300 <.text+0x300>
300002c8:	e3e02000 	mvn	r2, #0	; 0x0
300002cc:	e5c32000 	strb	r2, [r3]
300002d0:	e3a0300a 	mov	r3, #10	; 0xa
	while(tmp--);
300002d4:	e2433001 	sub	r3, r3, #1	; 0x1
300002d8:	e3730001 	cmn	r3, #1	; 0x1
300002dc:	059f2014 	ldreq	r2, [pc, #20]	; 300002f8 <.text+0x2f8>
300002e0:	05923000 	ldreq	r3, [r2]
300002e4:	03833002 	orreq	r3, r3, #2	; 0x2
300002e8:	05823000 	streq	r3, [r2]
300002ec:	01a0f00e 	moveq	pc, lr
300002f0:	eafffff7 	b	300002d4 <nand_reset+0x34>
300002f4:	00007770 	andeq	r7, r0, r0, ror r7
300002f8:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
300002fc:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
30000300:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}

30000304 <nand_read_ll>:
        NAND_CHIP_DISABLE;
}

/* low level nand read function */
int nand_read_ll(unsigned char *buf, unsigned long start_addr, int size)
{
30000304:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
30000308:	e1a04001 	mov	r4, r1
3000030c:	e1a06000 	mov	r6, r0
30000310:	e1a05002 	mov	r5, r2
        int i, j;
	
	lprint("Copy Command:membuf=%x, nandaddr=%x, size=%x\r\n", buf, start_addr, size);
30000314:	e1a03005 	mov	r3, r5
30000318:	e59f00f8 	ldr	r0, [pc, #248]	; 30000418 <.text+0x418>
3000031c:	e1a01006 	mov	r1, r6
30000320:	e1a02004 	mov	r2, r4
30000324:	eb0003d3 	bl	30001278 <lprint>
        if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK)) {
30000328:	e1a03b84 	mov	r3, r4, lsl #23
3000032c:	e1a03ba3 	mov	r3, r3, lsr #23
30000330:	e3530000 	cmp	r3, #0	; 0x0
30000334:	1a000009 	bne	30000360 <nand_read_ll+0x5c>
30000338:	e1a03b85 	mov	r3, r5, lsl #23
3000033c:	e1a03ba3 	mov	r3, r3, lsr #23
30000340:	e3530000 	cmp	r3, #0	; 0x0
30000344:	1a000005 	bne	30000360 <nand_read_ll+0x5c>
                return -1;      /* invalid alignment */
        }
	if(!(NFSTAT&0x1)){
30000348:	e59f30cc 	ldr	r3, [pc, #204]	; 3000041c <.text+0x41c>
3000034c:	e5d33000 	ldrb	r3, [r3]
30000350:	e3130001 	tst	r3, #1	; 0x1
30000354:	1a000003 	bne	30000368 <nand_read_ll+0x64>
		lprint("nand flash may have some problem, quit!\r\n");
30000358:	e59f00c0 	ldr	r0, [pc, #192]	; 30000420 <.text+0x420>
3000035c:	eb0003c5 	bl	30001278 <lprint>
		return -1;
30000360:	e3e00000 	mvn	r0, #0	; 0x0
	}

        NAND_CHIP_ENABLE;

        for(i=start_addr; i < (start_addr + size);) {
                /* READ0 */
                NAND_CLEAR_RB;
                NFCMD = 0;

                /* Write Address */
                NFADDR = i & 0xff;
                NFADDR = (i >> 9) & 0xff;
                NFADDR = (i >> 17) & 0xff;
                NFADDR = (i >> 25) & 0xff;

                NAND_DETECT_RB;

                for(j=0; j < NAND_SECTOR_SIZE; j++, i++) {
                        *buf = (NFDATA & 0xff);
                        buf++;
                }
		if(!((i>>9) & 0x3f))
			s3c2440_serial_send_byte('>');
        }
        NAND_CHIP_DISABLE;
        return 0;
}
30000364:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30000368:	e59f20b4 	ldr	r2, [pc, #180]	; 30000424 <.text+0x424>
3000036c:	e5923000 	ldr	r3, [r2]
30000370:	e0845005 	add	r5, r4, r5
30000374:	e3c33002 	bic	r3, r3, #2	; 0x2
30000378:	e1540005 	cmp	r4, r5
3000037c:	e5823000 	str	r3, [r2]
30000380:	2a00001e 	bcs	30000400 <nand_read_ll+0xfc>
30000384:	e59f2090 	ldr	r2, [pc, #144]	; 3000041c <.text+0x41c>
30000388:	e5d23000 	ldrb	r3, [r2]
3000038c:	e3833004 	orr	r3, r3, #4	; 0x4
30000390:	e5c23000 	strb	r3, [r2]
30000394:	e59f108c 	ldr	r1, [pc, #140]	; 30000428 <.text+0x428>
30000398:	e59f308c 	ldr	r3, [pc, #140]	; 3000042c <.text+0x42c>
3000039c:	e1a004c4 	mov	r0, r4, asr #9
300003a0:	e1a0c8c4 	mov	ip, r4, asr #17
300003a4:	e1a0ecc4 	mov	lr, r4, asr #25
300003a8:	e3a02000 	mov	r2, #0	; 0x0
300003ac:	e5c32000 	strb	r2, [r3]
300003b0:	e5c14000 	strb	r4, [r1]
300003b4:	e5c10000 	strb	r0, [r1]
300003b8:	e5c1c000 	strb	ip, [r1]
300003bc:	e5c1e000 	strb	lr, [r1]
300003c0:	e59f3054 	ldr	r3, [pc, #84]	; 3000041c <.text+0x41c>
300003c4:	e5d33000 	ldrb	r3, [r3]
300003c8:	e3130004 	tst	r3, #4	; 0x4
300003cc:	0afffffb 	beq	300003c0 <nand_read_ll+0xbc>
300003d0:	e3a02c02 	mov	r2, #512	; 0x200
300003d4:	e59f3054 	ldr	r3, [pc, #84]	; 30000430 <.text+0x430>
300003d8:	e5d33000 	ldrb	r3, [r3]
300003dc:	e2522001 	subs	r2, r2, #1	; 0x1
300003e0:	e4c63001 	strb	r3, [r6], #1
300003e4:	e2844001 	add	r4, r4, #1	; 0x1
300003e8:	1afffff9 	bne	300003d4 <nand_read_ll+0xd0>
300003ec:	e3140c7e 	tst	r4, #32256	; 0x7e00
300003f0:	03a0003e 	moveq	r0, #62	; 0x3e
300003f4:	0b0000e7 	bleq	30000798 <s3c2440_serial_send_byte>
300003f8:	e1540005 	cmp	r4, r5
300003fc:	3affffe0 	bcc	30000384 <nand_read_ll+0x80>
30000400:	e59f201c 	ldr	r2, [pc, #28]	; 30000424 <.text+0x424>
30000404:	e5923000 	ldr	r3, [r2]
30000408:	e3a00000 	mov	r0, #0	; 0x0
3000040c:	e3833002 	orr	r3, r3, #2	; 0x2
30000410:	e5823000 	str	r3, [r2]
30000414:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30000418:	30001744 	andcc	r1, r0, r4, asr #14
3000041c:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
30000420:	30001774 	andcc	r1, r0, r4, ror r7
30000424:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
30000428:	4e00000c 	cdpmi	0, 0, cr0, cr0, cr12, {0}
3000042c:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
30000430:	4e000010 	mcrmi	0, 0, r0, cr0, cr0, {0}

30000434 <random_read_nand>:

#define ERASE_BLOCK_ADDR_MASK (512 * 32 -1)
uint random_read_nand(uint spare, uint addr)
{
	uint tmd;
	if(spare) 
30000434:	e3500000 	cmp	r0, #0	; 0x0
30000438:	e92d4030 	stmdb	sp!, {r4, r5, lr}
3000043c:	e1a04001 	mov	r4, r1
30000440:	13a05050 	movne	r5, #80	; 0x50
30000444:	1a000002 	bne	30000454 <random_read_nand+0x20>
		tmd = 0x50;
	else if(addr & 0x100)
30000448:	e2113c01 	ands	r3, r1, #256	; 0x100
3000044c:	01a05003 	moveq	r5, r3
30000450:	13a05001 	movne	r5, #1	; 0x1
		tmd = 0x01;
	else	
		tmd = 0;
        NAND_CHIP_ENABLE;
30000454:	e59f2074 	ldr	r2, [pc, #116]	; 300004d0 <.text+0x4d0>
30000458:	e5923000 	ldr	r3, [r2]
3000045c:	e3c33002 	bic	r3, r3, #2	; 0x2
30000460:	e5823000 	str	r3, [r2]
        NAND_CLEAR_RB;
30000464:	e59f1068 	ldr	r1, [pc, #104]	; 300004d4 <.text+0x4d4>
30000468:	e5d13000 	ldrb	r3, [r1]
3000046c:	e3833004 	orr	r3, r3, #4	; 0x4
30000470:	e5c13000 	strb	r3, [r1]
	NFCMD = tmd;
        NFADDR = (addr) & 0xff;
30000474:	e59f205c 	ldr	r2, [pc, #92]	; 300004d8 <.text+0x4d8>
30000478:	e59f305c 	ldr	r3, [pc, #92]	; 300004dc <.text+0x4dc>
        NFADDR = (addr >> 9) & 0xff;
        NFADDR = (addr >> 17) & 0xff;
        NFADDR = (addr >> 25) & 0xff;
3000047c:	e1a0eca4 	mov	lr, r4, lsr #25
30000480:	e1a004a4 	mov	r0, r4, lsr #9
30000484:	e1a0c8a4 	mov	ip, r4, lsr #17
30000488:	e5c35000 	strb	r5, [r3]
3000048c:	e5c24000 	strb	r4, [r2]
30000490:	e5c20000 	strb	r0, [r2]
30000494:	e5c2c000 	strb	ip, [r2]
30000498:	e5c2e000 	strb	lr, [r2]
        NAND_DETECT_RB;
3000049c:	e59f3030 	ldr	r3, [pc, #48]	; 300004d4 <.text+0x4d4>
300004a0:	e5d33000 	ldrb	r3, [r3]
300004a4:	e3130004 	tst	r3, #4	; 0x4
300004a8:	0afffffb 	beq	3000049c <random_read_nand+0x68>
	tmd =  NFDATA & 0xff;
300004ac:	e59f302c 	ldr	r3, [pc, #44]	; 300004e0 <.text+0x4e0>
        NAND_CHIP_DISABLE;
300004b0:	e59f1018 	ldr	r1, [pc, #24]	; 300004d0 <.text+0x4d0>
300004b4:	e5d32000 	ldrb	r2, [r3]
300004b8:	e5913000 	ldr	r3, [r1]
300004bc:	e20250ff 	and	r5, r2, #255	; 0xff
300004c0:	e3833002 	orr	r3, r3, #2	; 0x2
	return tmd;
}
300004c4:	e1a00005 	mov	r0, r5
300004c8:	e5813000 	str	r3, [r1]
300004cc:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
300004d0:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
300004d4:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
300004d8:	4e00000c 	cdpmi	0, 0, cr0, cr0, cr12, {0}
300004dc:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
300004e0:	4e000010 	mcrmi	0, 0, r0, cr0, cr0, {0}

300004e4 <is_marked_bad_block>:
	
int is_marked_bad_block(uint addr)
{
300004e4:	e92d4010 	stmdb	sp!, {r4, lr}
	unsigned char a;
	uint i;

	addr &= ~ERASE_BLOCK_ADDR_MASK;
        if(!(NFSTAT&0x1)){
300004e8:	e59f3064 	ldr	r3, [pc, #100]	; 30000554 <.text+0x554>
300004ec:	e1a04000 	mov	r4, r0
300004f0:	e5d33000 	ldrb	r3, [r3]
300004f4:	e3c44dff 	bic	r4, r4, #16320	; 0x3fc0
300004f8:	e3c4403f 	bic	r4, r4, #63	; 0x3f
300004fc:	e3130001 	tst	r3, #1	; 0x1
30000500:	e59f0050 	ldr	r0, [pc, #80]	; 30000558 <.text+0x558>
30000504:	e2841005 	add	r1, r4, #5	; 0x5
30000508:	1a000002 	bne	30000518 <is_marked_bad_block+0x34>
                lprint("nand flash may have some problem, quit!\r\n");
3000050c:	eb000359 	bl	30001278 <lprint>
                return -1;
30000510:	e3e03000 	mvn	r3, #0	; 0x0
30000514:	ea00000c 	b	3000054c <is_marked_bad_block+0x68>
        }
	if(random_read_nand(1, addr+5) != 0xff || 
30000518:	e3a00001 	mov	r0, #1	; 0x1
3000051c:	ebffffc4 	bl	30000434 <random_read_nand>
30000520:	e1a03000 	mov	r3, r0
30000524:	e2841f81 	add	r1, r4, #516	; 0x204
30000528:	e35300ff 	cmp	r3, #255	; 0xff
3000052c:	e2811001 	add	r1, r1, #1	; 0x1
30000530:	e3a00001 	mov	r0, #1	; 0x1
30000534:	1a000003 	bne	30000548 <is_marked_bad_block+0x64>
30000538:	ebffffbd 	bl	30000434 <random_read_nand>
3000053c:	e35000ff 	cmp	r0, #255	; 0xff
30000540:	e3a03000 	mov	r3, #0	; 0x0
30000544:	0a000000 	beq	3000054c <is_marked_bad_block+0x68>
		random_read_nand(1, addr+5+512) != 0xff)
		return 1;
30000548:	e3a03001 	mov	r3, #1	; 0x1

	return 0;	
}
3000054c:	e1a00003 	mov	r0, r3
30000550:	e8bd8010 	ldmia	sp!, {r4, pc}
30000554:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
30000558:	30001774 	andcc	r1, r0, r4, ror r7

3000055c <nand_erase_ll>:

#if 0
int is_marked_bad_block(uint addr)
{
	unsigned char a;
	uint i;

	addr &= ~ERASE_BLOCK_ADDR_MASK;
        if(!(NFSTAT&0x1)){
                lprint("nand flash may have some problem, quit!\r\n");
                return -1;
        }
        NAND_CHIP_ENABLE;
        NAND_CLEAR_RB;
	NFCMD = 0x50;
        NFADDR = (addr) & 0xff;
        NFADDR = (addr >> 9) & 0xff;
        NFADDR = (addr >> 17) & 0xff;
        NFADDR = (addr >> 25) & 0xff;
        NAND_DETECT_RB;
	i = 5;
	while(i--){
		a = NFDATA;
#ifdef NAND_DEBUG
		lprint("%x\r\n", a);
#endif  
	}
	a = NFDATA;
#ifdef NAND_DEBUG
	lprint("%x\r\n", a);
#endif  
	if(a != 0xff){
#ifdef NAND_DEBUG
		lprint("marded bad\r\n");
#endif  
		return 1;
	}
	i = 15;
	while(i--){
		a = NFDATA;
#ifdef NAND_DEBUG
		lprint("%x\r\n", a);
#endif  
	}
	a = NFDATA;
#ifdef NAND_DEBUG
	lprint("%x\r\n", a);
#endif  
	if(a != 0xff){
#ifdef NAND_DEBUG
		lprint("marded bad\r\n");
#endif  
		return 1;
	}
	i = 10;
	while(i--){
		a = NFDATA;
#ifdef NAND_DEBUG
		lprint("%x\r\n", a);
#endif  
	}
#ifdef NAND_DEBUG
	lprint("not marked bad\r\n");
#endif  
        NAND_CHIP_DISABLE;
	return 0;	
}
#endif /*if 0*/

int nand_erase_ll(uint addr)
{
3000055c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
        lprint("Erase Command:addr=%x\r\n", addr);
30000560:	e1a01000 	mov	r1, r0
30000564:	e1a04000 	mov	r4, r0
30000568:	e59f00d0 	ldr	r0, [pc, #208]	; 30000640 <.text+0x640>
3000056c:	eb000341 	bl	30001278 <lprint>
	if(addr & ERASE_BLOCK_ADDR_MASK){
30000570:	e1a03904 	mov	r3, r4, lsl #18
30000574:	e1a03923 	mov	r3, r3, lsr #18
30000578:	e3530000 	cmp	r3, #0	; 0x0
3000057c:	159f00c0 	ldrne	r0, [pc, #192]	; 30000644 <.text+0x644>
30000580:	1a000004 	bne	30000598 <nand_erase_ll+0x3c>
		lprint("erase addr not correct!\r\n");
		return -1;
	}	
        if(!(NFSTAT&0x1)){
30000584:	e59f50bc 	ldr	r5, [pc, #188]	; 30000648 <.text+0x648>
30000588:	e5d53000 	ldrb	r3, [r5]
3000058c:	e3130001 	tst	r3, #1	; 0x1
30000590:	1a000003 	bne	300005a4 <nand_erase_ll+0x48>
                lprint("nand flash may have some problem, quit!\r\n");
30000594:	e59f00b0 	ldr	r0, [pc, #176]	; 3000064c <.text+0x64c>
30000598:	eb000336 	bl	30001278 <lprint>
                return -1;
3000059c:	e3e00000 	mvn	r0, #0	; 0x0
        }
/*
	if(is_marked_bad_block(addr)){
                lprint("block %x is bad block, quit!\r\n",addr);
                return -1;
	}
*/
        NAND_CHIP_ENABLE;
        NAND_CLEAR_RB;
	NFCMD = 0x60;
        NFADDR = (addr >> 9) & 0xff;
        NFADDR = (addr >> 17) & 0xff;
        NFADDR = (addr >> 25) & 0xff;
	NFCMD = 0xd0;
	while(!(NFSTAT & 0x1)){
#ifdef NAND_DEBUG
		lprint("%x\r\n", NFSTAT);
#endif	
	}
	NFCMD = 0x70;
	if(NFDATA & 0x1){
		lprint("erase failed! may get bad.\r\n");
		return -1;
	}
	lprint("erase successfully! \r\n");
        NAND_CHIP_DISABLE;
	return 0;
}
300005a0:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
300005a4:	e59f20a4 	ldr	r2, [pc, #164]	; 30000650 <.text+0x650>
300005a8:	e5923000 	ldr	r3, [r2]
300005ac:	e3c33002 	bic	r3, r3, #2	; 0x2
300005b0:	e5823000 	str	r3, [r2]
300005b4:	e5d53000 	ldrb	r3, [r5]
300005b8:	e59fc094 	ldr	ip, [pc, #148]	; 30000654 <.text+0x654>
300005bc:	e3833004 	orr	r3, r3, #4	; 0x4
300005c0:	e5c53000 	strb	r3, [r5]
300005c4:	e59f208c 	ldr	r2, [pc, #140]	; 30000658 <.text+0x658>
300005c8:	e3a03060 	mov	r3, #96	; 0x60
300005cc:	e5cc3000 	strb	r3, [ip]
300005d0:	e1a0eca4 	mov	lr, r4, lsr #25
300005d4:	e1a014a4 	mov	r1, r4, lsr #9
300005d8:	e1a008a4 	mov	r0, r4, lsr #17
300005dc:	e3e0302f 	mvn	r3, #47	; 0x2f
300005e0:	e5c21000 	strb	r1, [r2]
300005e4:	e5c20000 	strb	r0, [r2]
300005e8:	e5c2e000 	strb	lr, [r2]
300005ec:	e5cc3000 	strb	r3, [ip]
300005f0:	e59f3050 	ldr	r3, [pc, #80]	; 30000648 <.text+0x648>
300005f4:	e5d33000 	ldrb	r3, [r3]
300005f8:	e3130001 	tst	r3, #1	; 0x1
300005fc:	0afffffb 	beq	300005f0 <nand_erase_ll+0x94>
30000600:	e59f304c 	ldr	r3, [pc, #76]	; 30000654 <.text+0x654>
30000604:	e3a02070 	mov	r2, #112	; 0x70
30000608:	e5c32000 	strb	r2, [r3]
3000060c:	e59f3048 	ldr	r3, [pc, #72]	; 3000065c <.text+0x65c>
30000610:	e5d33000 	ldrb	r3, [r3]
30000614:	e2134001 	ands	r4, r3, #1	; 0x1
30000618:	159f0040 	ldrne	r0, [pc, #64]	; 30000660 <.text+0x660>
3000061c:	1affffdd 	bne	30000598 <nand_erase_ll+0x3c>
30000620:	e59f003c 	ldr	r0, [pc, #60]	; 30000664 <.text+0x664>
30000624:	eb000313 	bl	30001278 <lprint>
30000628:	e59f2020 	ldr	r2, [pc, #32]	; 30000650 <.text+0x650>
3000062c:	e5923000 	ldr	r3, [r2]
30000630:	e1a00004 	mov	r0, r4
30000634:	e3833002 	orr	r3, r3, #2	; 0x2
30000638:	e5823000 	str	r3, [r2]
3000063c:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30000640:	300017a0 	andcc	r1, r0, r0, lsr #15
30000644:	300017b8 	strcch	r1, [r0], -r8
30000648:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
3000064c:	30001774 	andcc	r1, r0, r4, ror r7
30000650:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
30000654:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
30000658:	4e00000c 	cdpmi	0, 0, cr0, cr0, cr12, {0}
3000065c:	4e000010 	mcrmi	0, 0, r0, cr0, cr0, {0}
30000660:	300017d4 	ldrccd	r1, [r0], -r4
30000664:	300017f4 	strccd	r1, [r0], -r4

30000668 <nand_write_ll>:

int nand_write_ll(unsigned char *buf, unsigned long start_addr, int size)
{
30000668:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
3000066c:	e1a04001 	mov	r4, r1
30000670:	e1a06000 	mov	r6, r0
30000674:	e1a05002 	mov	r5, r2
        int i, j;

        lprint("Write Command:membuf=%x, nandaddr=%x, size=%x\r\n", buf, start_addr, size);
30000678:	e1a03005 	mov	r3, r5
3000067c:	e59f00f8 	ldr	r0, [pc, #248]	; 3000077c <.text+0x77c>
30000680:	e1a01006 	mov	r1, r6
30000684:	e1a02004 	mov	r2, r4
30000688:	eb0002fa 	bl	30001278 <lprint>
        if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK)) {
3000068c:	e1a03b84 	mov	r3, r4, lsl #23
30000690:	e1a03ba3 	mov	r3, r3, lsr #23
30000694:	e3530000 	cmp	r3, #0	; 0x0
30000698:	1a000009 	bne	300006c4 <nand_write_ll+0x5c>
3000069c:	e1a03b85 	mov	r3, r5, lsl #23
300006a0:	e1a03ba3 	mov	r3, r3, lsr #23
300006a4:	e3530000 	cmp	r3, #0	; 0x0
300006a8:	1a000005 	bne	300006c4 <nand_write_ll+0x5c>
                return -1;      /* invalid alignment */
        }
        if(!(NFSTAT&0x1)){
300006ac:	e59f30cc 	ldr	r3, [pc, #204]	; 30000780 <.text+0x780>
300006b0:	e5d33000 	ldrb	r3, [r3]
300006b4:	e3130001 	tst	r3, #1	; 0x1
300006b8:	1a000003 	bne	300006cc <nand_write_ll+0x64>
                lprint("nand flash may have some problem, quit!\r\n");
300006bc:	e59f00c0 	ldr	r0, [pc, #192]	; 30000784 <.text+0x784>
300006c0:	eb0002ec 	bl	30001278 <lprint>
                return -1;
300006c4:	e3e00000 	mvn	r0, #0	; 0x0
        }

        NAND_CHIP_ENABLE;

        for(i=start_addr; i < (start_addr + size);) {
                /* READ0 */
                NAND_CLEAR_RB;
                NFCMD = 0;

                /* Write Address */
                NFADDR = i & 0xff;
                NFADDR = (i >> 9) & 0xff;
                NFADDR = (i >> 17) & 0xff;
                NFADDR = (i >> 25) & 0xff;

                NAND_DETECT_RB;

                for(j=0; j < NAND_SECTOR_SIZE; j++, i++) {
                        *buf = (NFDATA & 0xff);
                        buf++;
                }
                if(!((i>>9) & 0x3f))
                        s3c2440_serial_send_byte('>');
        }
        NAND_CHIP_DISABLE;
        return 0;
}
300006c8:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
300006cc:	e59f20b4 	ldr	r2, [pc, #180]	; 30000788 <.text+0x788>
300006d0:	e5923000 	ldr	r3, [r2]
300006d4:	e0845005 	add	r5, r4, r5
300006d8:	e3c33002 	bic	r3, r3, #2	; 0x2
300006dc:	e1540005 	cmp	r4, r5
300006e0:	e5823000 	str	r3, [r2]
300006e4:	2a00001e 	bcs	30000764 <nand_write_ll+0xfc>
300006e8:	e59f2090 	ldr	r2, [pc, #144]	; 30000780 <.text+0x780>
300006ec:	e5d23000 	ldrb	r3, [r2]
300006f0:	e3833004 	orr	r3, r3, #4	; 0x4
300006f4:	e5c23000 	strb	r3, [r2]
300006f8:	e59f108c 	ldr	r1, [pc, #140]	; 3000078c <.text+0x78c>
300006fc:	e59f308c 	ldr	r3, [pc, #140]	; 30000790 <.text+0x790>
30000700:	e1a004c4 	mov	r0, r4, asr #9
30000704:	e1a0c8c4 	mov	ip, r4, asr #17
30000708:	e1a0ecc4 	mov	lr, r4, asr #25
3000070c:	e3a02000 	mov	r2, #0	; 0x0
30000710:	e5c32000 	strb	r2, [r3]
30000714:	e5c14000 	strb	r4, [r1]
30000718:	e5c10000 	strb	r0, [r1]
3000071c:	e5c1c000 	strb	ip, [r1]
30000720:	e5c1e000 	strb	lr, [r1]
30000724:	e59f3054 	ldr	r3, [pc, #84]	; 30000780 <.text+0x780>
30000728:	e5d33000 	ldrb	r3, [r3]
3000072c:	e3130004 	tst	r3, #4	; 0x4
30000730:	0afffffb 	beq	30000724 <nand_write_ll+0xbc>
30000734:	e3a02c02 	mov	r2, #512	; 0x200
30000738:	e59f3054 	ldr	r3, [pc, #84]	; 30000794 <.text+0x794>
3000073c:	e5d33000 	ldrb	r3, [r3]
30000740:	e2522001 	subs	r2, r2, #1	; 0x1
30000744:	e4c63001 	strb	r3, [r6], #1
30000748:	e2844001 	add	r4, r4, #1	; 0x1
3000074c:	1afffff9 	bne	30000738 <nand_write_ll+0xd0>
30000750:	e3140c7e 	tst	r4, #32256	; 0x7e00
30000754:	03a0003e 	moveq	r0, #62	; 0x3e
30000758:	0b00000e 	bleq	30000798 <s3c2440_serial_send_byte>
3000075c:	e1540005 	cmp	r4, r5
30000760:	3affffe0 	bcc	300006e8 <nand_write_ll+0x80>
30000764:	e59f201c 	ldr	r2, [pc, #28]	; 30000788 <.text+0x788>
30000768:	e5923000 	ldr	r3, [r2]
3000076c:	e3a00000 	mov	r0, #0	; 0x0
30000770:	e3833002 	orr	r3, r3, #2	; 0x2
30000774:	e5823000 	str	r3, [r2]
30000778:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
3000077c:	3000180c 	andcc	r1, r0, ip, lsl #16
30000780:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
30000784:	30001774 	andcc	r1, r0, r4, ror r7
30000788:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
3000078c:	4e00000c 	cdpmi	0, 0, cr0, cr0, cr12, {0}
30000790:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
30000794:	4e000010 	mcrmi	0, 0, r0, cr0, cr0, {0}

30000798 <s3c2440_serial_send_byte>:
                    

/*
void s3c2440_serial_init(){
	GPHCON = 0xaaa0;
	GPHUP = 0x7ff;
	ULCON0 = 0x3;
	UCCON0 = 0x5;
	UBRDIV0 = 18;//set bautrate 9600bps
}
*/
void s3c2440_serial_send_byte(unsigned char c)
{
30000798:	e20000ff 	and	r0, r0, #255	; 0xff
        while(!(USCON0 & 0x2));
3000079c:	e59f3014 	ldr	r3, [pc, #20]	; 300007b8 <.text+0x7b8>
300007a0:	e5933000 	ldr	r3, [r3]
300007a4:	e3130002 	tst	r3, #2	; 0x2
300007a8:	159f300c 	ldrne	r3, [pc, #12]	; 300007bc <.text+0x7bc>
300007ac:	15830000 	strne	r0, [r3]
300007b0:	11a0f00e 	movne	pc, lr
300007b4:	eafffff8 	b	3000079c <s3c2440_serial_send_byte+0x4>
300007b8:	50000010 	andpl	r0, r0, r0, lsl r0
300007bc:	50000020 	andpl	r0, r0, r0, lsr #32

300007c0 <s3c2440_serial_recv_byte>:
        UTXH0 = c;
}

unsigned char s3c2440_serial_recv_byte()
{
        while(!(USCON0 & 0x1));
300007c0:	e59f3018 	ldr	r3, [pc, #24]	; 300007e0 <.text+0x7e0>
300007c4:	e5933000 	ldr	r3, [r3]
300007c8:	e3130001 	tst	r3, #1	; 0x1
300007cc:	159f3010 	ldrne	r3, [pc, #16]	; 300007e4 <.text+0x7e4>
300007d0:	15930000 	ldrne	r0, [r3]
300007d4:	120000ff 	andne	r0, r0, #255	; 0xff
        return URXH0;
}
300007d8:	11a0f00e 	movne	pc, lr
300007dc:	eafffff7 	b	300007c0 <s3c2440_serial_recv_byte>
300007e0:	50000010 	andpl	r0, r0, r0, lsl r0
300007e4:	50000024 	andpl	r0, r0, r4, lsr #32

300007e8 <s3c2440_is_serial_recv>:

uint s3c2440_is_serial_recv()
{
	return (USCON0 & 0x1);
300007e8:	e59f3008 	ldr	r3, [pc, #8]	; 300007f8 <.text+0x7f8>
300007ec:	e5930000 	ldr	r0, [r3]
300007f0:	e2000001 	and	r0, r0, #1	; 0x1
}
300007f4:	e1a0f00e 	mov	pc, lr
300007f8:	50000010 	andpl	r0, r0, r0, lsl r0

300007fc <ndchkbb>:
};
static uint * mrw_addr = 0x0;

void ndchkbb(unsigned char *para)
{
300007fc:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
	uint i, addr, marked_bad = 0, addr_list[16];
	lprint("I will check all block(0 - 0x%x) on current K9f1208 and find out all marked bad block, please wait!\r\n", 0x4000 * 4096);
30000800:	e59f0090 	ldr	r0, [pc, #144]	; 30000898 <.text+0x898>
30000804:	e24dd040 	sub	sp, sp, #64	; 0x40
30000808:	e3a01301 	mov	r1, #67108864	; 0x4000000
3000080c:	eb000299 	bl	30001278 <lprint>
30000810:	e3a04000 	mov	r4, #0	; 0x0
	i = 4096;
	addr = 0;
	while(i--){
30000814:	e59f6080 	ldr	r6, [pc, #128]	; 3000089c <.text+0x89c>
30000818:	e1a05004 	mov	r5, r4
		if(is_marked_bad_block(addr)){
3000081c:	e1a00005 	mov	r0, r5
30000820:	ebffff2f 	bl	300004e4 <is_marked_bad_block>
30000824:	e28d1040 	add	r1, sp, #64	; 0x40
30000828:	e1a03000 	mov	r3, r0
3000082c:	e3530000 	cmp	r3, #0	; 0x0
30000830:	e0812104 	add	r2, r1, r4, lsl #2
			addr_list[marked_bad++] = addr;
30000834:	15025040 	strne	r5, [r2, #-64]
30000838:	e3a00058 	mov	r0, #88	; 0x58
			con_send('X');
		}
		else
			con_send('O');
		addr += 0x4000;
3000083c:	e2466001 	sub	r6, r6, #1	; 0x1
30000840:	03a0004f 	moveq	r0, #79	; 0x4f
30000844:	12844001 	addne	r4, r4, #1	; 0x1
30000848:	ebffffd2 	bl	30000798 <s3c2440_serial_send_byte>
3000084c:	e3760001 	cmn	r6, #1	; 0x1
30000850:	e2855901 	add	r5, r5, #16384	; 0x4000
30000854:	1afffff0 	bne	3000081c <ndchkbb+0x20>
	}	
	lprint("\r\ncheck over! %x blocks bad.\r\n", marked_bad);
30000858:	e1a01004 	mov	r1, r4
3000085c:	e59f003c 	ldr	r0, [pc, #60]	; 300008a0 <.text+0x8a0>
	i = 0;
	while(marked_bad--)
30000860:	e2444001 	sub	r4, r4, #1	; 0x1
30000864:	eb000283 	bl	30001278 <lprint>
30000868:	e3740001 	cmn	r4, #1	; 0x1
3000086c:	0a000007 	beq	30000890 <ndchkbb+0x94>
30000870:	e28d5040 	add	r5, sp, #64	; 0x40
		lprint("%x\r\n", addr_list[i++]); 
30000874:	e5151040 	ldr	r1, [r5, #-64]
30000878:	e59f0024 	ldr	r0, [pc, #36]	; 300008a4 <.text+0x8a4>
3000087c:	e2444001 	sub	r4, r4, #1	; 0x1
30000880:	eb00027c 	bl	30001278 <lprint>
30000884:	e3740001 	cmn	r4, #1	; 0x1
30000888:	e2855004 	add	r5, r5, #4	; 0x4
3000088c:	1afffff8 	bne	30000874 <ndchkbb+0x78>
30000890:	e28dd040 	add	sp, sp, #64	; 0x40
30000894:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30000898:	30001a08 	andcc	r1, r0, r8, lsl #20
3000089c:	00000fff 	streqd	r0, [r0], -pc
300008a0:	30001a70 	andcc	r1, r0, r0, ror sl
300008a4:	30001dec 	andcc	r1, r0, ip, ror #27

300008a8 <go>:
}

void go(unsigned char *para)
{
300008a8:	e52de004 	str	lr, [sp, #-4]!
	lprint("This will go at the addr you just used with the 'r' cmd. Any problem please check!\r\n");
300008ac:	e59f0010 	ldr	r0, [pc, #16]	; 300008c4 <.text+0x8c4>
300008b0:	eb000270 	bl	30001278 <lprint>
	(*((void (*)())mrw_addr))();
300008b4:	e59f300c 	ldr	r3, [pc, #12]	; 300008c8 <.text+0x8c8>
300008b8:	e1a0e00f 	mov	lr, pc
300008bc:	e593f000 	ldr	pc, [r3]
300008c0:	e49df004 	ldr	pc, [sp], #4
300008c4:	30001a90 	mulcc	r0, r0, sl
300008c8:	30002050 	andcc	r2, r0, r0, asr r0

300008cc <put_file_by_serial>:
}

void put_file_by_serial(unsigned char *p)
{
300008cc:	e92d4010 	stmdb	sp!, {r4, lr}
    uint length = 0x80, tmp, i;
300008d0:	e3a03080 	mov	r3, #128	; 0x80
300008d4:	e24dd004 	sub	sp, sp, #4	; 0x4
300008d8:	e58d3000 	str	r3, [sp]
300008dc:	e1a04000 	mov	r4, r0

    tmp = get_howmany_para(p);
300008e0:	eb000043 	bl	300009f4 <get_howmany_para>
    if( tmp > 1)
300008e4:	e3500001 	cmp	r0, #1	; 0x1
300008e8:	e1a03000 	mov	r3, r0
300008ec:	8a00000e 	bhi	3000092c <put_file_by_serial+0x60>
        goto error;
    if(tmp == 0)
300008f0:	e3530000 	cmp	r3, #0	; 0x0
300008f4:	e1a00004 	mov	r0, r4
300008f8:	e1a0100d 	mov	r1, sp
300008fc:	0a000005 	beq	30000918 <put_file_by_serial+0x4c>
        goto modemsend;
    str_to_hex(p, &length);
30000900:	eb000051 	bl	30000a4c <str_to_hex>
    length >>= 7;
30000904:	e59d3000 	ldr	r3, [sp]
30000908:	e1a033a3 	mov	r3, r3, lsr #7
    if(!length)
3000090c:	e3530000 	cmp	r3, #0	; 0x0
30000910:	e58d3000 	str	r3, [sp]
30000914:	0a000004 	beq	3000092c <put_file_by_serial+0x60>
	goto error;
modemsend:
	xmodem_1k_send((unsigned char*)mrw_addr, length);
30000918:	e59f301c 	ldr	r3, [pc, #28]	; 3000093c <.text+0x93c>
3000091c:	e59d1000 	ldr	r1, [sp]
30000920:	e5930000 	ldr	r0, [r3]
30000924:	eb000310 	bl	3000156c <xmodem_1k_send>
	return;
30000928:	ea000001 	b	30000934 <put_file_by_serial+0x68>
error:
    lprint("Error para!\r\npfbs [length(0x80bytes x n)](default 0x80(16k) if no this argu)\r\n");
3000092c:	e59f000c 	ldr	r0, [pc, #12]	; 30000940 <.text+0x940>
30000930:	eb000250 	bl	30001278 <lprint>
} 
30000934:	e28dd004 	add	sp, sp, #4	; 0x4
30000938:	e8bd8010 	ldmia	sp!, {r4, pc}
3000093c:	30002050 	andcc	r2, r0, r0, asr r0
30000940:	30001ae8 	andcc	r1, r0, r8, ror #21

30000944 <get_file_by_serial>:

void get_file_by_serial(unsigned char *para)
{
	xmodem_1k_recv((unsigned char*)mrw_addr);
30000944:	e59f3004 	ldr	r3, [pc, #4]	; 30000950 <.text+0x950>
30000948:	e5930000 	ldr	r0, [r3]
3000094c:	ea0002a1 	b	300013d8 <xmodem_1k_recv>
30000950:	30002050 	andcc	r2, r0, r0, asr r0

30000954 <print_help>:

/*
	uint i = 1028, tmp = 0x20000, repeat = 36;
	unsigned char *c = (unsigned char*const)0xbf4;

	lprint("\r\nNow start(*0xbf4 = 0 will be test):\r\n\r\n");
	if(*c)
		con_send(0x15);
	else
		lprint("\r\nTest, time is up!\r\n");
	while(tmp--)
		if(is_con_recv())
			break;
	while(i--)
		*c++ = con_recv();
	con_send(0x06);
	*c++ = con_recv();
	con_send(0x06);
*/
}

void print_help(unsigned char *para)
{
30000954:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    uint i = 0;
    lprint("Clean Boot V%s\r\nAvailable cmd is:\r\n", CLEAN_BOOT_VERSION);
30000958:	e59f0044 	ldr	r0, [pc, #68]	; 300009a4 <.text+0x9a4>
3000095c:	e59f1044 	ldr	r1, [pc, #68]	; 300009a8 <.text+0x9a8>
30000960:	eb000244 	bl	30001278 <lprint>
    while(1){
30000964:	e59f5040 	ldr	r5, [pc, #64]	; 300009ac <.text+0x9ac>
30000968:	e3a04000 	mov	r4, #0	; 0x0
            if(cmd_list[i].cmd_name == NULL)
3000096c:	e59f3038 	ldr	r3, [pc, #56]	; 300009ac <.text+0x9ac>
30000970:	e7943003 	ldr	r3, [r4, r3]
30000974:	e3530000 	cmp	r3, #0	; 0x0
30000978:	e59f0030 	ldr	r0, [pc, #48]	; 300009b0 <.text+0x9b0>
3000097c:	e1a01003 	mov	r1, r3
30000980:	e284400c 	add	r4, r4, #12	; 0xc
30000984:	0a000003 	beq	30000998 <print_help+0x44>
                    break;
	    lprint("--%s\r\n\t%s\r\n", cmd_list[i].cmd_name, cmd_list[i].cmd_des);
30000988:	e5952008 	ldr	r2, [r5, #8]
            i++;
3000098c:	e285500c 	add	r5, r5, #12	; 0xc
30000990:	eb000238 	bl	30001278 <lprint>
30000994:	eafffff4 	b	3000096c <print_help+0x18>
    }
    lprint("'r' is a special command, if a address followed, it will be set as a memory base for many other command, such as 'pm', and so on\r\nESC will cancel current command\r\n");
30000998:	e59f0014 	ldr	r0, [pc, #20]	; 300009b4 <.text+0x9b4>
3000099c:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
300009a0:	ea000234 	b	30001278 <lprint>
300009a4:	30001b38 	andcc	r1, r0, r8, lsr fp
300009a8:	30001b5c 	andcc	r1, r0, ip, asr fp
300009ac:	3000169c 	mulcc	r0, ip, r6
300009b0:	30001bfc 	strccd	r1, [r0], -ip
300009b4:	30001c08 	andcc	r1, r0, r8, lsl #24

300009b8 <asc_to_hex>:
}

uint asc_to_hex(unsigned char c)
{
300009b8:	e20000ff 	and	r0, r0, #255	; 0xff
	uint v;

	if(c >= '0' && c <= '9')
300009bc:	e2402030 	sub	r2, r0, #48	; 0x30
300009c0:	e20230ff 	and	r3, r2, #255	; 0xff
300009c4:	e3530009 	cmp	r3, #9	; 0x9
300009c8:	e2401041 	sub	r1, r0, #65	; 0x41
300009cc:	9a000006 	bls	300009ec <asc_to_hex+0x34>
		return c - '0';	
	if(c >= 'A' && c <= 'F')
300009d0:	e3510005 	cmp	r1, #5	; 0x5
300009d4:	e2403061 	sub	r3, r0, #97	; 0x61
300009d8:	e2402037 	sub	r2, r0, #55	; 0x37
300009dc:	9a000002 	bls	300009ec <asc_to_hex+0x34>
		return c - 'A' + 10;
	if(c >= 'a' && c <= 'f')
300009e0:	e3530005 	cmp	r3, #5	; 0x5
300009e4:	e2402057 	sub	r2, r0, #87	; 0x57
		return c - 'a' + 10;
	return 0;
300009e8:	83a02000 	movhi	r2, #0	; 0x0
}
300009ec:	e1a00002 	mov	r0, r2
300009f0:	e1a0f00e 	mov	pc, lr

300009f4 <get_howmany_para>:

uint get_howmany_para(unsigned char *s)
{
	uint tmp = 0;
300009f4:	e3a02000 	mov	r2, #0	; 0x0
	while(1){
		while(*s == ' ')
300009f8:	e5d03000 	ldrb	r3, [r0]
300009fc:	e3530020 	cmp	r3, #32	; 0x20
30000a00:	1a000002 	bne	30000a10 <get_howmany_para+0x1c>
			s++;
30000a04:	e5f03001 	ldrb	r3, [r0, #1]!
30000a08:	e3530020 	cmp	r3, #32	; 0x20
30000a0c:	0afffffc 	beq	30000a04 <get_howmany_para+0x10>
		if(*s)
30000a10:	e5d03000 	ldrb	r3, [r0]
30000a14:	e3530000 	cmp	r3, #0	; 0x0
			tmp++;
30000a18:	12822001 	addne	r2, r2, #1	; 0x1
		while(*s != ' ' && *s)
30000a1c:	e3530020 	cmp	r3, #32	; 0x20
30000a20:	13530000 	cmpne	r3, #0	; 0x0
30000a24:	0a000003 	beq	30000a38 <get_howmany_para+0x44>
			s++;
30000a28:	e5f03001 	ldrb	r3, [r0, #1]!
30000a2c:	e3530020 	cmp	r3, #32	; 0x20
30000a30:	13530000 	cmpne	r3, #0	; 0x0
30000a34:	1afffffb 	bne	30000a28 <get_howmany_para+0x34>
		if(!*s)
30000a38:	e5d03000 	ldrb	r3, [r0]
30000a3c:	e3530000 	cmp	r3, #0	; 0x0
30000a40:	01a00002 	moveq	r0, r2
30000a44:	01a0f00e 	moveq	pc, lr
30000a48:	eaffffea 	b	300009f8 <get_howmany_para+0x4>

30000a4c <str_to_hex>:
			return tmp;
	}
}

unsigned char * str_to_hex(unsigned char *s, uint * result)
{
30000a4c:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
	uint  i = 0;
30000a50:	e3a07000 	mov	r7, #0	; 0x0

	*result = 0;
30000a54:	e5817000 	str	r7, [r1]
	while(*s == ' ')s++;
30000a58:	e5d03000 	ldrb	r3, [r0]
30000a5c:	e3530020 	cmp	r3, #32	; 0x20
30000a60:	e1a06001 	mov	r6, r1
30000a64:	e1a05000 	mov	r5, r0
30000a68:	1a000002 	bne	30000a78 <str_to_hex+0x2c>
30000a6c:	e5f53001 	ldrb	r3, [r5, #1]!
30000a70:	e3530020 	cmp	r3, #32	; 0x20
30000a74:	0afffffc 	beq	30000a6c <str_to_hex+0x20>
	for(i=0;i<8;i++){
30000a78:	e3a07000 	mov	r7, #0	; 0x0
		if(*s == ' ' || *s == 0)
30000a7c:	e5d53000 	ldrb	r3, [r5]
30000a80:	e3530000 	cmp	r3, #0	; 0x0
30000a84:	13530020 	cmpne	r3, #32	; 0x20
30000a88:	e1a00003 	mov	r0, r3
30000a8c:	e2877001 	add	r7, r7, #1	; 0x1
30000a90:	0a000007 	beq	30000ab4 <str_to_hex+0x68>
			break;
		*result = *result*16 + asc_to_hex(*s++);
30000a94:	ebffffc7 	bl	300009b8 <asc_to_hex>
30000a98:	e5964000 	ldr	r4, [r6]
30000a9c:	e1a04204 	mov	r4, r4, lsl #4
30000aa0:	e0844000 	add	r4, r4, r0
30000aa4:	e3570007 	cmp	r7, #7	; 0x7
30000aa8:	e2855001 	add	r5, r5, #1	; 0x1
30000aac:	e5864000 	str	r4, [r6]
30000ab0:	9afffff1 	bls	30000a7c <str_to_hex+0x30>
	}
	while(*s == ' ')s++;
30000ab4:	e5d53000 	ldrb	r3, [r5]
30000ab8:	e3530020 	cmp	r3, #32	; 0x20
30000abc:	1a000002 	bne	30000acc <str_to_hex+0x80>
30000ac0:	e5f53001 	ldrb	r3, [r5, #1]!
30000ac4:	e3530020 	cmp	r3, #32	; 0x20
30000ac8:	0afffffc 	beq	30000ac0 <str_to_hex+0x74>
	return s;
}
30000acc:	e1a00005 	mov	r0, r5
30000ad0:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}

30000ad4 <print_mem>:

void print_mem(unsigned char *cp, uint length)
{
30000ad4:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    uint i;

    cp = (unsigned char *)((uint)cp & (~0x3));
30000ad8:	e3c04003 	bic	r4, r0, #3	; 0x3
30000adc:	e1a05001 	mov	r5, r1
    lprint("Start print 0x%x mem content @%x:\r\n", length, (uint)cp);
30000ae0:	e59f004c 	ldr	r0, [pc, #76]	; 30000b34 <.text+0xb34>
30000ae4:	e1a02004 	mov	r2, r4
30000ae8:	eb0001e2 	bl	30001278 <lprint>
    while(length){
30000aec:	e3550000 	cmp	r5, #0	; 0x0
30000af0:	0a00000b 	beq	30000b24 <print_mem+0x50>
	lprint("\r\n");
30000af4:	e59f003c 	ldr	r0, [pc, #60]	; 30000b38 <.text+0xb38>
30000af8:	eb0001de 	bl	30001278 <lprint>
	for(i=0;i<8;i++){
30000afc:	e3a06000 	mov	r6, #0	; 0x0
		length--;
		lprint("%x\t", *cp++);
30000b00:	e4d41001 	ldrb	r1, [r4], #1
30000b04:	e59f0030 	ldr	r0, [pc, #48]	; 30000b3c <.text+0xb3c>
30000b08:	e2866001 	add	r6, r6, #1	; 0x1
30000b0c:	eb0001d9 	bl	30001278 <lprint>
30000b10:	e3560007 	cmp	r6, #7	; 0x7
30000b14:	e2455001 	sub	r5, r5, #1	; 0x1
30000b18:	9afffff8 	bls	30000b00 <print_mem+0x2c>
30000b1c:	e3550000 	cmp	r5, #0	; 0x0
30000b20:	1afffff3 	bne	30000af4 <print_mem+0x20>
	}
    }
    lprint("\r\nPrint end @%x.\r\n", (uint)cp);
30000b24:	e59f0014 	ldr	r0, [pc, #20]	; 30000b40 <.text+0xb40>
30000b28:	e1a01004 	mov	r1, r4
30000b2c:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
30000b30:	ea0001d0 	b	30001278 <lprint>
30000b34:	30001cac 	andcc	r1, r0, ip, lsr #25
30000b38:	30001808 	andcc	r1, r0, r8, lsl #16
30000b3c:	30001cd0 	ldrccd	r1, [r0], -r0
30000b40:	30001cd4 	ldrccd	r1, [r0], -r4

30000b44 <pm>:
}

void pm(unsigned char *p)
{
30000b44:	e92d4010 	stmdb	sp!, {r4, lr}
    uint length = 0x80, tmp, i;
30000b48:	e3a03080 	mov	r3, #128	; 0x80
30000b4c:	e24dd004 	sub	sp, sp, #4	; 0x4
30000b50:	e58d3000 	str	r3, [sp]
30000b54:	e1a04000 	mov	r4, r0

    tmp = get_howmany_para(p);
30000b58:	ebffffa5 	bl	300009f4 <get_howmany_para>
30000b5c:	e1a03000 	mov	r3, r0
    if( tmp > 1)
30000b60:	e3530001 	cmp	r3, #1	; 0x1
30000b64:	e59f0030 	ldr	r0, [pc, #48]	; 30000b9c <.text+0xb9c>
30000b68:	8a000008 	bhi	30000b90 <pm+0x4c>
        goto error;
    if(tmp == 0)
30000b6c:	e3530000 	cmp	r3, #0	; 0x0
30000b70:	e1a00004 	mov	r0, r4
30000b74:	e1a0100d 	mov	r1, sp
        goto print;
    str_to_hex(p, &length);
30000b78:	1bffffb3 	blne	30000a4c <str_to_hex>
print:
    print_mem((unsigned char*)mrw_addr, length);
30000b7c:	e59f301c 	ldr	r3, [pc, #28]	; 30000ba0 <.text+0xba0>
30000b80:	e59d1000 	ldr	r1, [sp]
30000b84:	e5930000 	ldr	r0, [r3]
30000b88:	ebffffd1 	bl	30000ad4 <print_mem>
    return;
30000b8c:	ea000000 	b	30000b94 <pm+0x50>

error:
    lprint("Error para!\r\npm [length](default 0x80 if no this argu)\r\n");
30000b90:	eb0001b8 	bl	30001278 <lprint>

}
30000b94:	e28dd004 	add	sp, sp, #4	; 0x4
30000b98:	e8bd8010 	ldmia	sp!, {r4, pc}
30000b9c:	30001ce8 	andcc	r1, r0, r8, ror #25
30000ba0:	30002050 	andcc	r2, r0, r0, asr r0

30000ba4 <ndbb>:


void ndbb(unsigned char *p)
{
30000ba4:	e92d4010 	stmdb	sp!, {r4, lr}
30000ba8:	e24dd004 	sub	sp, sp, #4	; 0x4
30000bac:	e1a04000 	mov	r4, r0
    uint addr, tmp;

    tmp = get_howmany_para(p);
30000bb0:	ebffff8f 	bl	300009f4 <get_howmany_para>
30000bb4:	e1a03000 	mov	r3, r0
    if(tmp != 1)
30000bb8:	e3530001 	cmp	r3, #1	; 0x1
30000bbc:	e59f0040 	ldr	r0, [pc, #64]	; 30000c04 <.text+0xc04>
30000bc0:	e1a0100d 	mov	r1, sp
30000bc4:	1a00000b 	bne	30000bf8 <ndbb+0x54>
        goto error;
    p = str_to_hex(p, &addr);
30000bc8:	e1a00004 	mov	r0, r4
30000bcc:	ebffff9e 	bl	30000a4c <str_to_hex>
cp:
    lprint("block %x ", addr);
30000bd0:	e59d1000 	ldr	r1, [sp]
30000bd4:	e59f002c 	ldr	r0, [pc, #44]	; 30000c08 <.text+0xc08>
30000bd8:	eb0001a6 	bl	30001278 <lprint>
    nand_reset();
30000bdc:	ebfffdaf 	bl	300002a0 <nand_reset>
    if(is_marked_bad_block(addr))
30000be0:	e59d0000 	ldr	r0, [sp]
30000be4:	ebfffe3e 	bl	300004e4 <is_marked_bad_block>
30000be8:	e1a03000 	mov	r3, r0
30000bec:	e3530000 	cmp	r3, #0	; 0x0
30000bf0:	e59f0014 	ldr	r0, [pc, #20]	; 30000c0c <.text+0xc0c>
	lprint("is Marked bad.\r\n");
    else
    	lprint("is not marked bad!\r\n");
30000bf4:	059f0014 	ldreq	r0, [pc, #20]	; 30000c10 <.text+0xc10>
    return;

error:
    lprint("Error para!\r\nnander (hex block addr)\r\n");
30000bf8:	eb00019e 	bl	30001278 <lprint>

}
30000bfc:	e28dd004 	add	sp, sp, #4	; 0x4
30000c00:	e8bd8010 	ldmia	sp!, {r4, pc}
30000c04:	30001d24 	andcc	r1, r0, r4, lsr #26
30000c08:	30001d4c 	andcc	r1, r0, ip, asr #26
30000c0c:	30001d58 	andcc	r1, r0, r8, asr sp
30000c10:	30001d6c 	andcc	r1, r0, ip, ror #26

30000c14 <nandspr>:

void nandspr(unsigned char *p)
{
30000c14:	e92d4030 	stmdb	sp!, {r4, r5, lr}
30000c18:	e24dd004 	sub	sp, sp, #4	; 0x4
30000c1c:	e1a04000 	mov	r4, r0
    uint addr, tmp;

    tmp = get_howmany_para(p);
30000c20:	ebffff73 	bl	300009f4 <get_howmany_para>
30000c24:	e1a05000 	mov	r5, r0
    if(tmp != 1)
30000c28:	e3550001 	cmp	r5, #1	; 0x1
30000c2c:	e1a0100d 	mov	r1, sp
30000c30:	e1a00004 	mov	r0, r4
30000c34:	1a000009 	bne	30000c60 <nandspr+0x4c>
        goto error;
    p = str_to_hex(p, &addr);
30000c38:	ebffff83 	bl	30000a4c <str_to_hex>
cp:
    nand_reset();
30000c3c:	ebfffd97 	bl	300002a0 <nand_reset>
    lprint("%x at nand spare addr %x\r\n", random_read_nand(1, addr), addr);
30000c40:	e59d1000 	ldr	r1, [sp]
30000c44:	e1a00005 	mov	r0, r5
30000c48:	ebfffdf9 	bl	30000434 <random_read_nand>
30000c4c:	e59d2000 	ldr	r2, [sp]
30000c50:	e1a01000 	mov	r1, r0
30000c54:	e59f0014 	ldr	r0, [pc, #20]	; 30000c70 <.text+0xc70>
30000c58:	eb000186 	bl	30001278 <lprint>
    return;
30000c5c:	ea000001 	b	30000c68 <nandspr+0x54>

error:
    lprint("Error para!\r\nnandspr (hex addr) random read nand spare\r\n");
30000c60:	e59f000c 	ldr	r0, [pc, #12]	; 30000c74 <.text+0xc74>
30000c64:	eb000183 	bl	30001278 <lprint>

}
30000c68:	e28dd004 	add	sp, sp, #4	; 0x4
30000c6c:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30000c70:	30001d84 	andcc	r1, r0, r4, lsl #27
30000c74:	30001da0 	andcc	r1, r0, r0, lsr #27

30000c78 <nandr>:

void nandr(unsigned char *p)
{
30000c78:	e92d4010 	stmdb	sp!, {r4, lr}
30000c7c:	e24dd004 	sub	sp, sp, #4	; 0x4
30000c80:	e1a04000 	mov	r4, r0
    uint addr, tmp;

    tmp = get_howmany_para(p);
30000c84:	ebffff5a 	bl	300009f4 <get_howmany_para>
30000c88:	e1a03000 	mov	r3, r0
    if(tmp != 1)
30000c8c:	e3530001 	cmp	r3, #1	; 0x1
30000c90:	e1a0100d 	mov	r1, sp
30000c94:	e1a00004 	mov	r0, r4
30000c98:	1a000009 	bne	30000cc4 <nandr+0x4c>
        goto error;
    p = str_to_hex(p, &addr);
30000c9c:	ebffff6a 	bl	30000a4c <str_to_hex>
cp:
    nand_reset();
30000ca0:	ebfffd7e 	bl	300002a0 <nand_reset>
    lprint("%x at nand addr %x\r\n", random_read_nand(0, addr), addr);
30000ca4:	e59d1000 	ldr	r1, [sp]
30000ca8:	e3a00000 	mov	r0, #0	; 0x0
30000cac:	ebfffde0 	bl	30000434 <random_read_nand>
30000cb0:	e59d2000 	ldr	r2, [sp]
30000cb4:	e1a01000 	mov	r1, r0
30000cb8:	e59f0014 	ldr	r0, [pc, #20]	; 30000cd4 <.text+0xcd4>
30000cbc:	eb00016d 	bl	30001278 <lprint>
    return;
30000cc0:	ea000001 	b	30000ccc <nandr+0x54>

error:
    lprint("Error para!\r\nnandr (hex addr) random read nand\r\n");
30000cc4:	e59f000c 	ldr	r0, [pc, #12]	; 30000cd8 <.text+0xcd8>
30000cc8:	eb00016a 	bl	30001278 <lprint>

}
30000ccc:	e28dd004 	add	sp, sp, #4	; 0x4
30000cd0:	e8bd8010 	ldmia	sp!, {r4, pc}
30000cd4:	30001ddc 	ldrccd	r1, [r0], -ip
30000cd8:	30001df4 	strccd	r1, [r0], -r4

30000cdc <nander>:

void nander(unsigned char *p)
{
30000cdc:	e92d4010 	stmdb	sp!, {r4, lr}
30000ce0:	e24dd004 	sub	sp, sp, #4	; 0x4
30000ce4:	e1a04000 	mov	r4, r0
    uint addr, tmp;

    tmp = get_howmany_para(p);
30000ce8:	ebffff41 	bl	300009f4 <get_howmany_para>
30000cec:	e1a03000 	mov	r3, r0
    if(tmp != 1)
30000cf0:	e3530001 	cmp	r3, #1	; 0x1
30000cf4:	e59f0044 	ldr	r0, [pc, #68]	; 30000d40 <.text+0xd40>
30000cf8:	e1a0100d 	mov	r1, sp
30000cfc:	1a00000c 	bne	30000d34 <nander+0x58>
        goto error;
    p = str_to_hex(p, &addr);
30000d00:	e1a00004 	mov	r0, r4
30000d04:	ebffff50 	bl	30000a4c <str_to_hex>
cp:
    nand_reset();
30000d08:	ebfffd64 	bl	300002a0 <nand_reset>
    if(nand_erase_ll(addr))
30000d0c:	e59d0000 	ldr	r0, [sp]
30000d10:	ebfffe11 	bl	3000055c <nand_erase_ll>
30000d14:	e1a03000 	mov	r3, r0
30000d18:	e3530000 	cmp	r3, #0	; 0x0
30000d1c:	e59f0020 	ldr	r0, [pc, #32]	; 30000d44 <.text+0xd44>
30000d20:	1a000003 	bne	30000d34 <nander+0x58>
	lprint("erase error\r\n");
    else
    	lprint("erase nand block 0x%x done!\r\n",addr);
30000d24:	e59f001c 	ldr	r0, [pc, #28]	; 30000d48 <.text+0xd48>
30000d28:	e59d1000 	ldr	r1, [sp]
30000d2c:	eb000151 	bl	30001278 <lprint>
    return;
30000d30:	ea000000 	b	30000d38 <nander+0x5c>

error:
    lprint("Error para!\r\nnander (hex block addr)\r\n");
30000d34:	eb00014f 	bl	30001278 <lprint>

}
30000d38:	e28dd004 	add	sp, sp, #4	; 0x4
30000d3c:	e8bd8010 	ldmia	sp!, {r4, pc}
30000d40:	30001d24 	andcc	r1, r0, r4, lsr #26
30000d44:	30001e28 	andcc	r1, r0, r8, lsr #28
30000d48:	30001e38 	andcc	r1, r0, r8, lsr lr

30000d4c <nandcp>:

void nandcp(unsigned char *p)
{
30000d4c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
30000d50:	e24dd008 	sub	sp, sp, #8	; 0x8
30000d54:	e1a04000 	mov	r4, r0
    uint addr, pages, tmp;

    tmp = get_howmany_para(p);
30000d58:	ebffff25 	bl	300009f4 <get_howmany_para>
30000d5c:	e1a03000 	mov	r3, r0
    if(tmp != 2)
30000d60:	e3530002 	cmp	r3, #2	; 0x2
30000d64:	e59f5060 	ldr	r5, [pc, #96]	; 30000dcc <.text+0xdcc>
30000d68:	e28d1004 	add	r1, sp, #4	; 0x4
30000d6c:	e1a00004 	mov	r0, r4
30000d70:	1a000011 	bne	30000dbc <nandcp+0x70>
        goto error;
    p = str_to_hex(p, &addr);
30000d74:	ebffff34 	bl	30000a4c <str_to_hex>
    str_to_hex(p, &pages);
30000d78:	e1a0100d 	mov	r1, sp
30000d7c:	ebffff32 	bl	30000a4c <str_to_hex>
    addr = addr & 0xfffffe00;
30000d80:	e59d3004 	ldr	r3, [sp, #4]
30000d84:	e3c33f7f 	bic	r3, r3, #508	; 0x1fc
30000d88:	e3c33003 	bic	r3, r3, #3	; 0x3
30000d8c:	e58d3004 	str	r3, [sp, #4]
cp:
    nand_reset();
30000d90:	ebfffd42 	bl	300002a0 <nand_reset>
    nand_read_ll(mrw_addr, addr, 512 * pages);
30000d94:	e59d2000 	ldr	r2, [sp]
30000d98:	e59d1004 	ldr	r1, [sp, #4]
30000d9c:	e5950000 	ldr	r0, [r5]
30000da0:	e1a02482 	mov	r2, r2, lsl #9
30000da4:	ebfffd56 	bl	30000304 <nand_read_ll>
    lprint("cp 0x%x pages from nand addr %x to memory 0x%x done!\r\n",pages,addr,mrw_addr);
30000da8:	e5953000 	ldr	r3, [r5]
30000dac:	e89d0006 	ldmia	sp, {r1, r2}
30000db0:	e59f0018 	ldr	r0, [pc, #24]	; 30000dd0 <.text+0xdd0>
30000db4:	eb00012f 	bl	30001278 <lprint>
    return;
30000db8:	ea000001 	b	30000dc4 <nandcp+0x78>

error:
    lprint("Error para!\r\nnandcp (hex addr) (hex pages)\r\n");
30000dbc:	e59f0010 	ldr	r0, [pc, #16]	; 30000dd4 <.text+0xdd4>
30000dc0:	eb00012c 	bl	30001278 <lprint>

}
30000dc4:	e28dd008 	add	sp, sp, #8	; 0x8
30000dc8:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30000dcc:	30002050 	andcc	r2, r0, r0, asr r0
30000dd0:	30001e58 	andcc	r1, r0, r8, asr lr
30000dd4:	30001e90 	mulcc	r0, r0, lr

30000dd8 <write_mem>:

void write_mem(unsigned char *p)
{
30000dd8:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
30000ddc:	e24dd004 	sub	sp, sp, #4	; 0x4
30000de0:	e1a06000 	mov	r6, r0
    uint value, tmp;

    tmp = get_howmany_para(p);
30000de4:	ebffff02 	bl	300009f4 <get_howmany_para>
30000de8:	e1a05000 	mov	r5, r0
    if(tmp == 0 || tmp > 2)
30000dec:	e2453001 	sub	r3, r5, #1	; 0x1
30000df0:	e3530001 	cmp	r3, #1	; 0x1
30000df4:	e59f005c 	ldr	r0, [pc, #92]	; 30000e58 <.text+0xe58>
30000df8:	e1a0100d 	mov	r1, sp
30000dfc:	8a000012 	bhi	30000e4c <write_mem+0x74>
	goto error;
    p = str_to_hex(p, &value);
30000e00:	e59f4054 	ldr	r4, [pc, #84]	; 30000e5c <.text+0xe5c>
30000e04:	e1a00006 	mov	r0, r6
30000e08:	ebffff0f 	bl	30000a4c <str_to_hex>
    if(tmp == 1)
30000e0c:	e3550001 	cmp	r5, #1	; 0x1
30000e10:	e1a01004 	mov	r1, r4
30000e14:	0a000003 	beq	30000e28 <write_mem+0x50>
        goto write;
    str_to_hex(p, (uint*)&mrw_addr);
30000e18:	ebffff0b 	bl	30000a4c <str_to_hex>
    mrw_addr = (uint*)((uint)mrw_addr & 0xfffffffc);
30000e1c:	e5943000 	ldr	r3, [r4]
30000e20:	e3c33003 	bic	r3, r3, #3	; 0x3
30000e24:	e5843000 	str	r3, [r4]
write:
    *(uint*)mrw_addr = value;
30000e28:	e59f102c 	ldr	r1, [pc, #44]	; 30000e5c <.text+0xe5c>
30000e2c:	e59d3000 	ldr	r3, [sp]
30000e30:	e5912000 	ldr	r2, [r1]
30000e34:	e5823000 	str	r3, [r2]
    lprint("Write 0x%x to memory 0x%x done!\r\n",value,mrw_addr);
30000e38:	e59f0020 	ldr	r0, [pc, #32]	; 30000e60 <.text+0xe60>
30000e3c:	e5912000 	ldr	r2, [r1]
30000e40:	e59d1000 	ldr	r1, [sp]
30000e44:	eb00010b 	bl	30001278 <lprint>
    return;
30000e48:	ea000000 	b	30000e50 <write_mem+0x78>

error:
    lprint("Error para!\r\nw (hex value) [(hex addr)](last addr if no this argu)\r\n");
30000e4c:	eb000109 	bl	30001278 <lprint>

}
30000e50:	e28dd004 	add	sp, sp, #4	; 0x4
30000e54:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30000e58:	30001ec0 	andcc	r1, r0, r0, asr #29
30000e5c:	30002050 	andcc	r2, r0, r0, asr r0
30000e60:	30001f08 	andcc	r1, r0, r8, lsl #30

30000e64 <read_mem>:


void read_mem(unsigned char *p)
{
30000e64:	e92d4030 	stmdb	sp!, {r4, r5, lr}
30000e68:	e1a05000 	mov	r5, r0
    uint value, tmp;

    tmp = get_howmany_para(p);
30000e6c:	ebfffee0 	bl	300009f4 <get_howmany_para>
30000e70:	e1a03000 	mov	r3, r0
    if( tmp > 1)
30000e74:	e3530001 	cmp	r3, #1	; 0x1
30000e78:	e59f0044 	ldr	r0, [pc, #68]	; 30000ec4 <.text+0xec4>
30000e7c:	8a00000e 	bhi	30000ebc <read_mem+0x58>
	goto error;
    if(tmp == 0)
30000e80:	e59f4040 	ldr	r4, [pc, #64]	; 30000ec8 <.text+0xec8>
30000e84:	e3530000 	cmp	r3, #0	; 0x0
30000e88:	e1a00005 	mov	r0, r5
30000e8c:	e1a01004 	mov	r1, r4
30000e90:	0a000003 	beq	30000ea4 <read_mem+0x40>
    	goto read;
    str_to_hex(p, (uint*)&mrw_addr);
30000e94:	ebfffeec 	bl	30000a4c <str_to_hex>
    mrw_addr = (uint*)((uint)mrw_addr & 0xfffffffc);
30000e98:	e5943000 	ldr	r3, [r4]
30000e9c:	e3c33003 	bic	r3, r3, #3	; 0x3
30000ea0:	e5843000 	str	r3, [r4]
read:
    value = *(uint*)mrw_addr;
30000ea4:	e59f301c 	ldr	r3, [pc, #28]	; 30000ec8 <.text+0xec8>
30000ea8:	e5932000 	ldr	r2, [r3]
    lprint("Read 0x%x at memory 0x%x\r\n",value,mrw_addr);
30000eac:	e59f0018 	ldr	r0, [pc, #24]	; 30000ecc <.text+0xecc>
30000eb0:	e5921000 	ldr	r1, [r2]
30000eb4:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
30000eb8:	ea0000ee 	b	30001278 <lprint>

    return;

error:
    lprint("Error para!\r\nr [(hex addr)](last addr if no this argu)\r\n");
30000ebc:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
30000ec0:	ea0000ec 	b	30001278 <lprint>
30000ec4:	30001f2c 	andcc	r1, r0, ip, lsr #30
30000ec8:	30002050 	andcc	r2, r0, r0, asr r0
30000ecc:	30001f68 	andcc	r1, r0, r8, ror #30

30000ed0 <lmemcpy>:

}


unsigned char* lmemcpy(unsigned char *d,unsigned char*s,uint n)
{
	unsigned char *p=d;
	while(n--)*d++=*s++;
30000ed0:	e2422001 	sub	r2, r2, #1	; 0x1
30000ed4:	e3720001 	cmn	r2, #1	; 0x1
30000ed8:	e1a0c000 	mov	ip, r0
30000edc:	0a000004 	beq	30000ef4 <lmemcpy+0x24>
30000ee0:	e4d13001 	ldrb	r3, [r1], #1
30000ee4:	e2422001 	sub	r2, r2, #1	; 0x1
30000ee8:	e3720001 	cmn	r2, #1	; 0x1
30000eec:	e4c03001 	strb	r3, [r0], #1
30000ef0:	1afffffa 	bne	30000ee0 <lmemcpy+0x10>
	return p;
}
30000ef4:	e1a0000c 	mov	r0, ip
30000ef8:	e1a0f00e 	mov	pc, lr

30000efc <lmemset>:

void lmemset(unsigned char *d,unsigned char v,unsigned int n)
{
	while(n--)*d++=v;
30000efc:	e2422001 	sub	r2, r2, #1	; 0x1
30000f00:	e3720001 	cmn	r2, #1	; 0x1
30000f04:	e20110ff 	and	r1, r1, #255	; 0xff
30000f08:	01a0f00e 	moveq	pc, lr
30000f0c:	e2422001 	sub	r2, r2, #1	; 0x1
30000f10:	e3720001 	cmn	r2, #1	; 0x1
30000f14:	e4c01001 	strb	r1, [r0], #1
30000f18:	01a0f00e 	moveq	pc, lr
30000f1c:	eafffffa 	b	30000f0c <lmemset+0x10>

30000f20 <handle_cmd>:
}

void handle_cmd()
{
30000f20:	e92d4010 	stmdb	sp!, {r4, lr}
    unsigned char i = 0, *p_cmd, *p_buf;

    lprint("\r\n");
30000f24:	e59f00a8 	ldr	r0, [pc, #168]	; 30000fd4 <.text+0xfd4>
30000f28:	eb0000d2 	bl	30001278 <lprint>
    if(!cmd_buf[0])
30000f2c:	e59f30a4 	ldr	r3, [pc, #164]	; 30000fd8 <.text+0xfd8>
30000f30:	e5d33000 	ldrb	r3, [r3]
30000f34:	e3530000 	cmp	r3, #0	; 0x0
30000f38:	e3a0c000 	mov	ip, #0	; 0x0
30000f3c:	08bd8010 	ldmeqia	sp!, {r4, pc}
	return;
    while(1){
	    if(cmd_list[i].cmd_name == NULL)
30000f40:	e59f4094 	ldr	r4, [pc, #148]	; 30000fdc <.text+0xfdc>
30000f44:	e1a0e08c 	mov	lr, ip, lsl #1
30000f48:	e08e300c 	add	r3, lr, ip
30000f4c:	e7943103 	ldr	r3, [r4, r3, lsl #2]
30000f50:	e3530000 	cmp	r3, #0	; 0x0
30000f54:	0a000015 	beq	30000fb0 <handle_cmd+0x90>
		    break;
	    p_cmd=cmd_list[i].cmd_name;
	    p_buf=cmd_buf;
	    while(*p_cmd){
30000f58:	e5d32000 	ldrb	r2, [r3]
30000f5c:	e3520000 	cmp	r2, #0	; 0x0
30000f60:	e1a01003 	mov	r1, r3
30000f64:	e59f006c 	ldr	r0, [pc, #108]	; 30000fd8 <.text+0xfd8>
30000f68:	0a000009 	beq	30000f94 <handle_cmd+0x74>
		    if(*p_buf != *p_cmd)
30000f6c:	e5d03000 	ldrb	r3, [r0]
30000f70:	e1530002 	cmp	r3, r2
30000f74:	1a000003 	bne	30000f88 <handle_cmd+0x68>
			    break;
		    p_buf++;
		    p_cmd++;
30000f78:	e5f12001 	ldrb	r2, [r1, #1]!
30000f7c:	e3520000 	cmp	r2, #0	; 0x0
30000f80:	e2800001 	add	r0, r0, #1	; 0x1
30000f84:	1afffff8 	bne	30000f6c <handle_cmd+0x4c>
	    }
	    if(!(*p_cmd) && (*p_buf == ' ' || !(*p_buf))){
30000f88:	e5d13000 	ldrb	r3, [r1]
30000f8c:	e3530000 	cmp	r3, #0	; 0x0
30000f90:	1a000003 	bne	30000fa4 <handle_cmd+0x84>
30000f94:	e5d03000 	ldrb	r3, [r0]
30000f98:	e3530000 	cmp	r3, #0	; 0x0
30000f9c:	13530020 	cmpne	r3, #32	; 0x20
30000fa0:	0a000006 	beq	30000fc0 <handle_cmd+0xa0>
            	    cmd_list[i].cmd_fun(p_buf);
            	    return;
       	    }
	    i++;
30000fa4:	e28c3001 	add	r3, ip, #1	; 0x1
30000fa8:	e203c0ff 	and	ip, r3, #255	; 0xff
30000fac:	eaffffe3 	b	30000f40 <handle_cmd+0x20>
    }
    lprint("Unknow command:%s\r\n",cmd_buf);
30000fb0:	e59f0028 	ldr	r0, [pc, #40]	; 30000fe0 <.text+0xfe0>
30000fb4:	e59f101c 	ldr	r1, [pc, #28]	; 30000fd8 <.text+0xfd8>
30000fb8:	e8bd4010 	ldmia	sp!, {r4, lr}
30000fbc:	ea0000ad 	b	30001278 <lprint>
30000fc0:	e08e300c 	add	r3, lr, ip
30000fc4:	e0843103 	add	r3, r4, r3, lsl #2
30000fc8:	e1a0e00f 	mov	lr, pc
30000fcc:	e593f004 	ldr	pc, [r3, #4]
}
30000fd0:	e8bd8010 	ldmia	sp!, {r4, pc}
30000fd4:	30001808 	andcc	r1, r0, r8, lsl #16
30000fd8:	30002054 	andcc	r2, r0, r4, asr r0
30000fdc:	3000169c 	mulcc	r0, ip, r6
30000fe0:	30001f84 	andcc	r1, r0, r4, lsl #31

30000fe4 <run_clean_boot>:

void run_clean_boot()
{
	unsigned char c;
	
	mrw_addr = 0;
30000fe4:	e59fc0d4 	ldr	ip, [pc, #212]	; 300010c0 <.text+0x10c0>
30000fe8:	e92d4010 	stmdb	sp!, {r4, lr}
30000fec:	e3a04000 	mov	r4, #0	; 0x0
	lprint("\r\n\r\nHello, this is clean_boot v%sbuild on %s %s.\r\n", CLEAN_BOOT_VERSION,__DATE__,__TIME__);
30000ff0:	e59f30cc 	ldr	r3, [pc, #204]	; 300010c4 <.text+0x10c4>
30000ff4:	e59f00cc 	ldr	r0, [pc, #204]	; 300010c8 <.text+0x10c8>
30000ff8:	e59f10cc 	ldr	r1, [pc, #204]	; 300010cc <.text+0x10cc>
30000ffc:	e59f20cc 	ldr	r2, [pc, #204]	; 300010d0 <.text+0x10d0>
30001000:	e58c4000 	str	r4, [ip]
30001004:	eb00009b 	bl	30001278 <lprint>
	lmemset(cmd_buf, 0, COM_MAX_LEN);
30001008:	e59f00c4 	ldr	r0, [pc, #196]	; 300010d4 <.text+0x10d4>
3000100c:	e1a01004 	mov	r1, r4
30001010:	e3a02020 	mov	r2, #32	; 0x20
30001014:	ebffffb8 	bl	30000efc <lmemset>
	cmd_buf_p = 0;
30001018:	e59f30b8 	ldr	r3, [pc, #184]	; 300010d8 <.text+0x10d8>
	lprint("\r\nCleanBoot@%s>", PLATFORM);
3000101c:	e59f00b8 	ldr	r0, [pc, #184]	; 300010dc <.text+0x10dc>
30001020:	e59f10b8 	ldr	r1, [pc, #184]	; 300010e0 <.text+0x10e0>
30001024:	e5834000 	str	r4, [r3]
30001028:	eb000092 	bl	30001278 <lprint>
	while(1){
		c = con_recv();
3000102c:	ebfffde3 	bl	300007c0 <s3c2440_serial_recv_byte>
30001030:	e200c0ff 	and	ip, r0, #255	; 0xff
		if(c == ENTER_CHAR){
30001034:	e35c000d 	cmp	ip, #13	; 0xd
30001038:	1a00000a 	bne	30001068 <run_clean_boot+0x84>
			handle_cmd();
3000103c:	ebffffb7 	bl	30000f20 <handle_cmd>
			lmemset(cmd_buf, 0, COM_MAX_LEN);
30001040:	e59f008c 	ldr	r0, [pc, #140]	; 300010d4 <.text+0x10d4>
30001044:	e3a01000 	mov	r1, #0	; 0x0
30001048:	e3a02020 	mov	r2, #32	; 0x20
3000104c:	ebffffaa 	bl	30000efc <lmemset>
			cmd_buf_p = 0;
30001050:	e59f3080 	ldr	r3, [pc, #128]	; 300010d8 <.text+0x10d8>
			lprint("\r\nCleanBoot@%s>", PLATFORM);
30001054:	e59f0080 	ldr	r0, [pc, #128]	; 300010dc <.text+0x10dc>
30001058:	e59f1080 	ldr	r1, [pc, #128]	; 300010e0 <.text+0x10e0>
3000105c:	e3a02000 	mov	r2, #0	; 0x0
30001060:	e5832000 	str	r2, [r3]
30001064:	eaffffef 	b	30001028 <run_clean_boot+0x44>
		}else if(c == 0x1b){
30001068:	e35c001b 	cmp	ip, #27	; 0x1b
3000106c:	e59f0060 	ldr	r0, [pc, #96]	; 300010d4 <.text+0x10d4>
30001070:	e3a01000 	mov	r1, #0	; 0x0
30001074:	e3a02020 	mov	r2, #32	; 0x20
30001078:	e59f4058 	ldr	r4, [pc, #88]	; 300010d8 <.text+0x10d8>
3000107c:	1a000005 	bne	30001098 <run_clean_boot+0xb4>
			lmemset(cmd_buf, 0, COM_MAX_LEN);
30001080:	ebffff9d 	bl	30000efc <lmemset>
			cmd_buf_p = 0;
			lprint("\r\nCleanBoot@%s>", PLATFORM);
30001084:	e59f0050 	ldr	r0, [pc, #80]	; 300010dc <.text+0x10dc>
30001088:	e59f1050 	ldr	r1, [pc, #80]	; 300010e0 <.text+0x10e0>
3000108c:	e3a03000 	mov	r3, #0	; 0x0
30001090:	e5843000 	str	r3, [r4]
30001094:	eaffffe3 	b	30001028 <run_clean_boot+0x44>
		}else{
			if(cmd_buf_p < (COM_MAX_LEN - 1)){
30001098:	e5942000 	ldr	r2, [r4]
3000109c:	e352001e 	cmp	r2, #30	; 0x1e
300010a0:	e1a0000c 	mov	r0, ip
300010a4:	e2823001 	add	r3, r2, #1	; 0x1
300010a8:	8affffdf 	bhi	3000102c <run_clean_boot+0x48>
				cmd_buf[cmd_buf_p++] = c;
300010ac:	e5843000 	str	r3, [r4]
300010b0:	e59f301c 	ldr	r3, [pc, #28]	; 300010d4 <.text+0x10d4>
300010b4:	e7c2c003 	strb	ip, [r2, r3]
				con_send(c);
300010b8:	ebfffdb6 	bl	30000798 <s3c2440_serial_send_byte>
300010bc:	eaffffda 	b	3000102c <run_clean_boot+0x48>
300010c0:	30002050 	andcc	r2, r0, r0, asr r0
300010c4:	30001f98 	mulcc	r0, r8, pc
300010c8:	30001fa4 	andcc	r1, r0, r4, lsr #31
300010cc:	30001b5c 	andcc	r1, r0, ip, asr fp
300010d0:	30001fd8 	ldrccd	r1, [r0], -r8
300010d4:	30002054 	andcc	r2, r0, r4, asr r0
300010d8:	3000204c 	andcc	r2, r0, ip, asr #32
300010dc:	30001fe4 	andcc	r1, r0, r4, ror #31
300010e0:	30001ff4 	strccd	r1, [r0], -r4

300010e4 <main>:
#include "print.h"

void main()
{
	run_clean_boot();
300010e4:	eaffffbe 	b	30000fe4 <run_clean_boot>

300010e8 <print_string>:
#include "debug.h"
#include "print.h"

void print_string(unsigned char *s)
{
300010e8:	e92d4010 	stmdb	sp!, {r4, lr}
300010ec:	e1a04000 	mov	r4, r0
        unsigned char c;
        while(1){
                if(!(c = *s++))
300010f0:	e4d43001 	ldrb	r3, [r4], #1
300010f4:	e2530000 	subs	r0, r3, #0	; 0x0
300010f8:	08bd8010 	ldmeqia	sp!, {r4, pc}
                        break;
                con_send(c);
300010fc:	ebfffda5 	bl	30000798 <s3c2440_serial_send_byte>
30001100:	eafffffa 	b	300010f0 <print_string+0x8>

30001104 <halfbyte2char>:
        }
        return;

}

unsigned char halfbyte2char(unsigned char c)
{
        return ((c & 0x0f) < 0x0a)?(0x30 + c):('A' + c - 0x0a);
30001104:	e200300f 	and	r3, r0, #15	; 0xf
30001108:	e20000ff 	and	r0, r0, #255	; 0xff
3000110c:	e3530009 	cmp	r3, #9	; 0x9
30001110:	e2803030 	add	r3, r0, #48	; 0x30
30001114:	e2800037 	add	r0, r0, #55	; 0x37
30001118:	e20330ff 	and	r3, r3, #255	; 0xff
3000111c:	c20030ff 	andgt	r3, r0, #255	; 0xff
}
30001120:	e1a00003 	mov	r0, r3
30001124:	e1a0f00e 	mov	pc, lr

30001128 <div>:

uint div(uint beichushu, uint chushu)
{
    uint shang = 0, tmp = 0;
30001128:	e3a0c000 	mov	ip, #0	; 0x0
3000112c:	e52de004 	str	lr, [sp, #-4]!
30001130:	e1a0200c 	mov	r2, ip
    const unsigned char bit_of_uint = 8 * sizeof(uint);
    unsigned char n = bit_of_uint;

    while(n--){
30001134:	e3a0e01f 	mov	lr, #31	; 0x1f
        tmp = (tmp<<1) + (beichushu>>(bit_of_uint - 1));
30001138:	e24e3001 	sub	r3, lr, #1	; 0x1
3000113c:	e203e0ff 	and	lr, r3, #255	; 0xff
30001140:	e1a03fa0 	mov	r3, r0, lsr #31
30001144:	e0832082 	add	r2, r3, r2, lsl #1
        beichushu<<=1;
        shang = shang<<1;
        if(tmp >= chushu){
30001148:	e1520001 	cmp	r2, r1
3000114c:	e1a0c08c 	mov	ip, ip, lsl #1
                tmp = tmp - chushu;
                shang++;
30001150:	228cc001 	addcs	ip, ip, #1	; 0x1
30001154:	20612002 	rsbcs	r2, r1, r2
30001158:	e35e00ff 	cmp	lr, #255	; 0xff
3000115c:	e1a00080 	mov	r0, r0, lsl #1
30001160:	01a0000c 	moveq	r0, ip
30001164:	049df004 	ldreq	pc, [sp], #4
30001168:	eafffff2 	b	30001138 <div+0x10>

3000116c <num2str>:
        }
    }
    return shang;
}

unsigned char * num2str(uint jt, unsigned char * s, unsigned char n)
{
3000116c:	e92d4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
30001170:	e20290ff 	and	r9, r2, #255	; 0xff
        unsigned char * st, k = 1, j;
        uint tmp;

        st = s;
        if(n > 16 || n < 2){
30001174:	e2493002 	sub	r3, r9, #2	; 0x2
30001178:	e353000e 	cmp	r3, #14	; 0xe
                *st++ = 0x30;
3000117c:	83a03030 	movhi	r3, #48	; 0x30
30001180:	85c13000 	strhib	r3, [r1]
                *st = 0;
30001184:	83a03000 	movhi	r3, #0	; 0x0
30001188:	e1a0b001 	mov	fp, r1
3000118c:	e1a07000 	mov	r7, r0
30001190:	e3a05001 	mov	r5, #1	; 0x1
30001194:	e1a0a001 	mov	sl, r1
30001198:	85c13001 	strhib	r3, [r1, #1]
                return s;
3000119c:	8a00001f 	bhi	30001220 <num2str+0xb4>
        }
        tmp = 1;
300011a0:	e1a06005 	mov	r6, r5
        while(div(jt, tmp) >= n){
                k++;
                tmp *= n;
300011a4:	e1a01006 	mov	r1, r6
300011a8:	e1a00007 	mov	r0, r7
300011ac:	ebffffdd 	bl	30001128 <div>
300011b0:	e2853001 	add	r3, r5, #1	; 0x1
300011b4:	e1500009 	cmp	r0, r9
300011b8:	20060699 	mulcs	r6, r9, r6
300011bc:	220350ff 	andcs	r5, r3, #255	; 0xff
300011c0:	2afffff7 	bcs	300011a4 <num2str+0x38>
        }

        while(k--){
300011c4:	e2453001 	sub	r3, r5, #1	; 0x1
300011c8:	e20350ff 	and	r5, r3, #255	; 0xff
300011cc:	e35500ff 	cmp	r5, #255	; 0xff
300011d0:	0a000010 	beq	30001218 <num2str+0xac>
                j = div(jt, tmp);
300011d4:	e1a01006 	mov	r1, r6
300011d8:	e1a00007 	mov	r0, r7
300011dc:	ebffffd1 	bl	30001128 <div>
300011e0:	e20040ff 	and	r4, r0, #255	; 0xff
                *st++ = halfbyte2char(j);
300011e4:	e1a00004 	mov	r0, r4
300011e8:	ebffffc5 	bl	30001104 <halfbyte2char>
                jt -= tmp * j;
300011ec:	e0030694 	mul	r3, r4, r6
300011f0:	e4ca0001 	strb	r0, [sl], #1
                tmp = div(tmp, n);
300011f4:	e1a01009 	mov	r1, r9
300011f8:	e1a00006 	mov	r0, r6
300011fc:	e0637007 	rsb	r7, r3, r7
30001200:	ebffffc8 	bl	30001128 <div>
30001204:	e2453001 	sub	r3, r5, #1	; 0x1
30001208:	e20350ff 	and	r5, r3, #255	; 0xff
3000120c:	e35500ff 	cmp	r5, #255	; 0xff
30001210:	e1a06000 	mov	r6, r0
30001214:	1affffee 	bne	300011d4 <num2str+0x68>
        }
        *st = 0;
30001218:	e3a03000 	mov	r3, #0	; 0x0
3000121c:	e5ca3000 	strb	r3, [sl]
        return s;
}
30001220:	e1a0000b 	mov	r0, fp
30001224:	e8bd8ef0 	ldmia	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}

30001228 <print_uint>:

void print_uint(uint num)
{
30001228:	e92d4010 	stmdb	sp!, {r4, lr}
3000122c:	e24dd00c 	sub	sp, sp, #12	; 0xc
        unsigned char nc[11];
        num2str(num, nc, 10);
30001230:	e1a0100d 	mov	r1, sp
30001234:	e3a0200a 	mov	r2, #10	; 0xa
30001238:	ebffffcb 	bl	3000116c <num2str>
        print_string(nc);
3000123c:	e1a0000d 	mov	r0, sp
30001240:	e1a0400d 	mov	r4, sp
30001244:	ebffffa7 	bl	300010e8 <print_string>
30001248:	e28dd00c 	add	sp, sp, #12	; 0xc
3000124c:	e8bd8010 	ldmia	sp!, {r4, pc}

30001250 <print_hex>:
}

void print_hex(uint num)
{
30001250:	e92d4010 	stmdb	sp!, {r4, lr}
30001254:	e24dd00c 	sub	sp, sp, #12	; 0xc
        unsigned char nc[9];
        num2str(num, nc, 16);
30001258:	e1a0100d 	mov	r1, sp
3000125c:	e3a02010 	mov	r2, #16	; 0x10
30001260:	ebffffc1 	bl	3000116c <num2str>
        print_string(nc);
30001264:	e1a0000d 	mov	r0, sp
30001268:	e1a0400d 	mov	r4, sp
3000126c:	ebffff9d 	bl	300010e8 <print_string>
30001270:	e28dd00c 	add	sp, sp, #12	; 0xc
30001274:	e8bd8010 	ldmia	sp!, {r4, pc}

30001278 <lprint>:
}

void lprint(const unsigned char * fmt, ...)
{
30001278:	e92d000f 	stmdb	sp!, {r0, r1, r2, r3}
3000127c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
30001280:	e59d400c 	ldr	r4, [sp, #12]
    const unsigned char *s;
    uint d;
    va_list ap;

    va_start(ap, fmt);
    while (*fmt) {
30001284:	e5d40000 	ldrb	r0, [r4]
30001288:	e3500000 	cmp	r0, #0	; 0x0
3000128c:	e28d5010 	add	r5, sp, #16	; 0x10
30001290:	0a000022 	beq	30001320 <lprint+0xa8>
        if (*fmt != '%') {
30001294:	e20000ff 	and	r0, r0, #255	; 0xff
30001298:	e3500025 	cmp	r0, #37	; 0x25
3000129c:	e2844001 	add	r4, r4, #1	; 0x1
300012a0:	0a000001 	beq	300012ac <lprint+0x34>
	    con_send(*fmt++);
300012a4:	ebfffd3b 	bl	30000798 <s3c2440_serial_send_byte>
            continue;
300012a8:	ea000019 	b	30001314 <lprint+0x9c>
        }
        switch (*++fmt) {
300012ac:	e5d40000 	ldrb	r0, [r4]
300012b0:	e3500073 	cmp	r0, #115	; 0x73
300012b4:	0a000008 	beq	300012dc <lprint+0x64>
300012b8:	ca000004 	bgt	300012d0 <lprint+0x58>
300012bc:	e3500025 	cmp	r0, #37	; 0x25
300012c0:	0a000011 	beq	3000130c <lprint+0x94>
300012c4:	e3500064 	cmp	r0, #100	; 0x64
300012c8:	0a000006 	beq	300012e8 <lprint+0x70>
300012cc:	ea00000b 	b	30001300 <lprint+0x88>
300012d0:	e3500078 	cmp	r0, #120	; 0x78
300012d4:	0a000006 	beq	300012f4 <lprint+0x7c>
300012d8:	ea000008 	b	30001300 <lprint+0x88>
	    case '%':
	        con_send(*fmt);
		break;
            case 's':
                s = va_arg(ap, const unsigned char *);
300012dc:	e4950004 	ldr	r0, [r5], #4
                print_string(s);
300012e0:	ebffff80 	bl	300010e8 <print_string>
                break;
300012e4:	ea000009 	b	30001310 <lprint+0x98>
            case 'd':
                d = va_arg(ap, int);
300012e8:	e4950004 	ldr	r0, [r5], #4
                print_uint(d);
300012ec:	ebffffcd 	bl	30001228 <print_uint>
                break;
300012f0:	ea000006 	b	30001310 <lprint+0x98>
	    /*
	    case 'c':
                d = va_arg(ap, char);
                send_int(d);
                break;
	    */
	    case 'x':
                d = va_arg(ap, uint);
300012f4:	e4950004 	ldr	r0, [r5], #4
                print_hex(d);
300012f8:	ebffffd4 	bl	30001250 <print_hex>
                break;
300012fc:	ea000003 	b	30001310 <lprint+0x98>
            /* Add other specifiers here... */             
            default: 
                con_send(*(fmt-1));
30001300:	e5540001 	ldrb	r0, [r4, #-1]
30001304:	ebfffd23 	bl	30000798 <s3c2440_serial_send_byte>
		con_send(*fmt);
30001308:	e5d40000 	ldrb	r0, [r4]
3000130c:	ebfffd21 	bl	30000798 <s3c2440_serial_send_byte>
                break;
        }
        fmt++;
30001310:	e2844001 	add	r4, r4, #1	; 0x1
30001314:	e5d40000 	ldrb	r0, [r4]
30001318:	e3500000 	cmp	r0, #0	; 0x0
3000131c:	1affffdc 	bne	30001294 <lprint+0x1c>
    }
    va_end(ap);
    return;   
30001320:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
30001324:	e28dd010 	add	sp, sp, #16	; 0x10
30001328:	e1a0f00e 	mov	pc, lr

3000132c <crc16>:
uint crc16(unsigned char *c, uint len)
{
	uint crc16_check = 0, j;

	while(len--)
3000132c:	e2411001 	sub	r1, r1, #1	; 0x1
30001330:	e3710001 	cmn	r1, #1	; 0x1
30001334:	e52de004 	str	lr, [sp, #-4]!
30001338:	e1a0e000 	mov	lr, r0
3000133c:	e3a00000 	mov	r0, #0	; 0x0
30001340:	0a00000e 	beq	30001380 <crc16+0x54>
	{
		crc16_check = crc16_check ^ (uint)*c++ << 8;
30001344:	e4de3001 	ldrb	r3, [lr], #1
		for (j=0;j<8;j++)
30001348:	e3a0c000 	mov	ip, #0	; 0x0
3000134c:	e0200403 	eor	r0, r0, r3, lsl #8
		{
			if(crc16_check & 0x8000)
30001350:	e59f3034 	ldr	r3, [pc, #52]	; 3000138c <.text+0x138c>
30001354:	e1a02080 	mov	r2, r0, lsl #1
30001358:	e3100902 	tst	r0, #32768	; 0x8000
3000135c:	e0220003 	eor	r0, r2, r3
30001360:	e28c3001 	add	r3, ip, #1	; 0x1
				crc16_check = crc16_check << 1 ^ 0x1021;
			else
				crc16_check <<= 1;
30001364:	01a00002 	moveq	r0, r2
30001368:	e3530007 	cmp	r3, #7	; 0x7
3000136c:	e1a0c003 	mov	ip, r3
30001370:	9afffff6 	bls	30001350 <crc16+0x24>
30001374:	e2411001 	sub	r1, r1, #1	; 0x1
30001378:	e3710001 	cmn	r1, #1	; 0x1
3000137c:	1afffff0 	bne	30001344 <crc16+0x18>
		}
	}
	return crc16_check & 0xffff;
30001380:	e1a00800 	mov	r0, r0, lsl #16
30001384:	e1a00820 	mov	r0, r0, lsr #16
}
30001388:	e49df004 	ldr	pc, [sp], #4
3000138c:	00001021 	andeq	r1, r0, r1, lsr #32

30001390 <time_limit_recv_byte>:

uint time_limit_recv_byte(uint limit, unsigned char * c)
{
30001390:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	while(limit--){
30001394:	e2404001 	sub	r4, r0, #1	; 0x1
30001398:	e3740001 	cmn	r4, #1	; 0x1
3000139c:	e1a05001 	mov	r5, r1
300013a0:	0a000009 	beq	300013cc <time_limit_recv_byte+0x3c>
		if(is_con_recv()){
300013a4:	ebfffd0f 	bl	300007e8 <s3c2440_is_serial_recv>
300013a8:	e3500000 	cmp	r0, #0	; 0x0
300013ac:	e2444001 	sub	r4, r4, #1	; 0x1
300013b0:	0a000003 	beq	300013c4 <time_limit_recv_byte+0x34>
			*c = con_recv();
300013b4:	ebfffd01 	bl	300007c0 <s3c2440_serial_recv_byte>
			return 0;
300013b8:	e3a03000 	mov	r3, #0	; 0x0
300013bc:	e5c50000 	strb	r0, [r5]
300013c0:	ea000002 	b	300013d0 <time_limit_recv_byte+0x40>
300013c4:	e3740001 	cmn	r4, #1	; 0x1
300013c8:	1afffff5 	bne	300013a4 <time_limit_recv_byte+0x14>
		}
	}
	return 1;
300013cc:	e3a03001 	mov	r3, #1	; 0x1
}
300013d0:	e1a00003 	mov	r0, r3
300013d4:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

300013d8 <xmodem_1k_recv>:

uint xmodem_1k_recv(unsigned char*p)
{
300013d8:	e92d46f0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, lr}
        uint i = 128, tmp = 0xa0000, repeat = 66;
	unsigned char recved = 0, index = 1, check_sum = 0, *c;
300013dc:	e3a03000 	mov	r3, #0	; 0x0
300013e0:	e24dd004 	sub	sp, sp, #4	; 0x4
300013e4:	e1a09000 	mov	r9, r0

	lprint("@0xffc=0(default)go after 10s or anykey!\r\n");
300013e8:	e59f0174 	ldr	r0, [pc, #372]	; 30001564 <.text+0x1564>
300013ec:	e5cd3003 	strb	r3, [sp, #3]
300013f0:	ebffffa0 	bl	30001278 <lprint>
300013f4:	e3a04042 	mov	r4, #66	; 0x42
300013f8:	e3a07001 	mov	r7, #1	; 0x1
	c = p;
300013fc:	e1a0a009 	mov	sl, r9
	do{
                con_send(0x15);
30001400:	e3a00015 	mov	r0, #21	; 0x15
30001404:	ebfffce3 	bl	30000798 <s3c2440_serial_send_byte>
		if(time_limit_recv_byte(0x80000, &recved) == 0)
30001408:	e3a00702 	mov	r0, #524288	; 0x80000
3000140c:	e28d1003 	add	r1, sp, #3	; 0x3
30001410:	ebffffde 	bl	30001390 <time_limit_recv_byte>
30001414:	e3500000 	cmp	r0, #0	; 0x0
30001418:	0a000002 	beq	30001428 <xmodem_1k_recv+0x50>
			break;
	}while(repeat--);
3000141c:	e2444001 	sub	r4, r4, #1	; 0x1
30001420:	e3740001 	cmn	r4, #1	; 0x1
30001424:	1afffff5 	bne	30001400 <xmodem_1k_recv+0x28>
	if(!repeat){
30001428:	e3540000 	cmp	r4, #0	; 0x0
3000142c:	1a000003 	bne	30001440 <xmodem_1k_recv+0x68>
		con_send(CAN);
30001430:	e3a00018 	mov	r0, #24	; 0x18
30001434:	ebfffcd7 	bl	30000798 <s3c2440_serial_send_byte>
		return 1;
30001438:	e3a00001 	mov	r0, #1	; 0x1
3000143c:	ea000046 	b	3000155c <xmodem_1k_recv+0x184>
	}
start_recv_package:
	if(recved != SOH){
30001440:	e5dd3003 	ldrb	r3, [sp, #3]
30001444:	e3530001 	cmp	r3, #1	; 0x1
30001448:	1a000040 	bne	30001550 <xmodem_1k_recv+0x178>
		con_send(CAN);
		return 2;
	}
	if(time_limit_recv_byte(0x20000, &recved) == 1){
3000144c:	e28d6003 	add	r6, sp, #3	; 0x3
30001450:	e3a00802 	mov	r0, #131072	; 0x20000
30001454:	e1a01006 	mov	r1, r6
30001458:	ebffffcc 	bl	30001390 <time_limit_recv_byte>
3000145c:	e3500001 	cmp	r0, #1	; 0x1
30001460:	0a00003a 	beq	30001550 <xmodem_1k_recv+0x178>
		con_send(CAN);
		return 2;
	}
	if(recved != index){
30001464:	e5dd3003 	ldrb	r3, [sp, #3]
30001468:	e1530007 	cmp	r3, r7
3000146c:	1a000037 	bne	30001550 <xmodem_1k_recv+0x178>
		con_send(CAN);
		return 2;
	}
	if(time_limit_recv_byte(0x20000, &recved) == 1){
30001470:	e3a00802 	mov	r0, #131072	; 0x20000
30001474:	e1a01006 	mov	r1, r6
30001478:	ebffffc4 	bl	30001390 <time_limit_recv_byte>
3000147c:	e3500001 	cmp	r0, #1	; 0x1
30001480:	0a000032 	beq	30001550 <xmodem_1k_recv+0x178>
		con_send(CAN);
		return 2;
	}
	if((recved + index) != 0xff){
30001484:	e5dd3003 	ldrb	r3, [sp, #3]
30001488:	e0833007 	add	r3, r3, r7
3000148c:	e35300ff 	cmp	r3, #255	; 0xff
30001490:	1a00002e 	bne	30001550 <xmodem_1k_recv+0x178>
		con_send(CAN);
		return 2;
	}
	i = 128;
	check_sum = 0;
30001494:	e3a05000 	mov	r5, #0	; 0x0
	while(i--){
30001498:	e3a0407f 	mov	r4, #127	; 0x7f
		if(time_limit_recv_byte(0x20000, &recved) == 1){
3000149c:	e3a00802 	mov	r0, #131072	; 0x20000
300014a0:	e1a01006 	mov	r1, r6
300014a4:	ebffffb9 	bl	30001390 <time_limit_recv_byte>
300014a8:	e3500001 	cmp	r0, #1	; 0x1
300014ac:	e2444001 	sub	r4, r4, #1	; 0x1
300014b0:	0a000026 	beq	30001550 <xmodem_1k_recv+0x178>
			con_send(CAN);
			return 2;
		}
		*c++ = recved;
300014b4:	e5dd2003 	ldrb	r2, [sp, #3]
		check_sum += recved;
300014b8:	e3740001 	cmn	r4, #1	; 0x1
300014bc:	e0853002 	add	r3, r5, r2
300014c0:	e20350ff 	and	r5, r3, #255	; 0xff
300014c4:	e4ca2001 	strb	r2, [sl], #1
300014c8:	1afffff3 	bne	3000149c <xmodem_1k_recv+0xc4>
	}
	if(time_limit_recv_byte(0x20000, &recved) == 1){
300014cc:	e3a00802 	mov	r0, #131072	; 0x20000
300014d0:	e1a01006 	mov	r1, r6
300014d4:	ebffffad 	bl	30001390 <time_limit_recv_byte>
300014d8:	e3500001 	cmp	r0, #1	; 0x1
300014dc:	0a00001b 	beq	30001550 <xmodem_1k_recv+0x178>
		con_send(CAN);
		return 2;
	}
	if(recved != check_sum){
300014e0:	e5dd3003 	ldrb	r3, [sp, #3]
300014e4:	e1530005 	cmp	r3, r5
300014e8:	1a000018 	bne	30001550 <xmodem_1k_recv+0x178>
		con_send(CAN);
		return 2;
	}
	con_send(ACK);
300014ec:	e3a00006 	mov	r0, #6	; 0x6
300014f0:	ebfffca8 	bl	30000798 <s3c2440_serial_send_byte>
	if(time_limit_recv_byte(0x20000, &recved) == 1){
300014f4:	e3a00802 	mov	r0, #131072	; 0x20000
300014f8:	e1a01006 	mov	r1, r6
300014fc:	ebffffa3 	bl	30001390 <time_limit_recv_byte>
30001500:	e3500001 	cmp	r0, #1	; 0x1
30001504:	0a000011 	beq	30001550 <xmodem_1k_recv+0x178>
		con_send(CAN);
		return 2;
	}
	if(recved == EOT){
30001508:	e5dd3003 	ldrb	r3, [sp, #3]
3000150c:	e3530004 	cmp	r3, #4	; 0x4
		con_send(ACK);
		if(*(uint*)0xffc == 0){
			time_limit_recv_byte(0xc00000, &recved);
			(*((void (*)())p))();
		}
		return 0;
	}
	index++;
30001510:	12873001 	addne	r3, r7, #1	; 0x1
30001514:	120370ff 	andne	r7, r3, #255	; 0xff
	goto start_recv_package;
30001518:	1affffc8 	bne	30001440 <xmodem_1k_recv+0x68>
3000151c:	e3a00006 	mov	r0, #6	; 0x6
30001520:	ebfffc9c 	bl	30000798 <s3c2440_serial_send_byte>
30001524:	e59f303c 	ldr	r3, [pc, #60]	; 30001568 <.text+0x1568>
30001528:	e5933000 	ldr	r3, [r3]
3000152c:	e3530000 	cmp	r3, #0	; 0x0
30001530:	1a000004 	bne	30001548 <xmodem_1k_recv+0x170>
30001534:	e1a01006 	mov	r1, r6
30001538:	e3a00503 	mov	r0, #12582912	; 0xc00000
3000153c:	ebffff93 	bl	30001390 <time_limit_recv_byte>
30001540:	e1a0e00f 	mov	lr, pc
30001544:	e1a0f009 	mov	pc, r9
30001548:	e3a00000 	mov	r0, #0	; 0x0
3000154c:	ea000002 	b	3000155c <xmodem_1k_recv+0x184>
30001550:	e3a00018 	mov	r0, #24	; 0x18
30001554:	ebfffc8f 	bl	30000798 <s3c2440_serial_send_byte>
30001558:	e3a00002 	mov	r0, #2	; 0x2
}
3000155c:	e28dd004 	add	sp, sp, #4	; 0x4
30001560:	e8bd86f0 	ldmia	sp!, {r4, r5, r6, r7, r9, sl, pc}
30001564:	30001ffc 	strccd	r1, [r0], -ip
30001568:	00000ffc 	streqd	r0, [r0], -ip

3000156c <xmodem_1k_send>:

uint xmodem_1k_send(unsigned char*c, uint len)
{
3000156c:	e92d4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
30001570:	e1a05000 	mov	r5, r0
30001574:	e24dd008 	sub	sp, sp, #8	; 0x8
        uint i = 128, check_way = 0; /*0-crc16 1-checksum*/
30001578:	e3a0a000 	mov	sl, #0	; 0x0
	unsigned char tmpchar = 0, index = 1, check_sum = 0, *clast;
	uint check_crc16;

	lprint("Please get the receiver ready!\r\n");
3000157c:	e59f0114 	ldr	r0, [pc, #276]	; 30001698 <.text+0x1698>
30001580:	e58d1000 	str	r1, [sp]
30001584:	e5cda007 	strb	sl, [sp, #7]
30001588:	e3a07001 	mov	r7, #1	; 0x1
3000158c:	ebffff39 	bl	30001278 <lprint>
	while(1){
		tmpchar = con_recv();
30001590:	ebfffc8a 	bl	300007c0 <s3c2440_serial_recv_byte>
30001594:	e5cd0007 	strb	r0, [sp, #7]
		if(tmpchar == 'C'){
30001598:	e5dd3007 	ldrb	r3, [sp, #7]
3000159c:	e3530043 	cmp	r3, #67	; 0x43
300015a0:	0a000002 	beq	300015b0 <xmodem_1k_send+0x44>
			break;
		}
		if(tmpchar == NACK){
300015a4:	e3530015 	cmp	r3, #21	; 0x15
300015a8:	1afffff8 	bne	30001590 <xmodem_1k_send+0x24>
			check_way = 1;
300015ac:	e3a0a001 	mov	sl, #1	; 0x1
			break;
		}
	}
start_send_package:
	if(index > len){
300015b0:	e59d3000 	ldr	r3, [sp]
300015b4:	e1570003 	cmp	r7, r3
300015b8:	8a00002d 	bhi	30001674 <xmodem_1k_send+0x108>
		con_send(EOT);
		con_recv();
		time_limit_recv_byte(0x20000, &tmpchar);
		return 0;
	}
	con_send(SOH);
300015bc:	e3a00001 	mov	r0, #1	; 0x1
300015c0:	ebfffc74 	bl	30000798 <s3c2440_serial_send_byte>
	con_send(index);
300015c4:	e1a00007 	mov	r0, r7
300015c8:	ebfffc72 	bl	30000798 <s3c2440_serial_send_byte>
	con_send(~index & 0xff);
300015cc:	e1e00007 	mvn	r0, r7
300015d0:	e20000ff 	and	r0, r0, #255	; 0xff
300015d4:	ebfffc6f 	bl	30000798 <s3c2440_serial_send_byte>
	i = 128;
	check_sum = 0;
	if(!check_way)
300015d8:	e35a0000 	cmp	sl, #0	; 0x0
300015dc:	e3a04080 	mov	r4, #128	; 0x80
300015e0:	e3a06000 	mov	r6, #0	; 0x0
300015e4:	1a000003 	bne	300015f8 <xmodem_1k_send+0x8c>
		check_crc16 = crc16(c, 128);
300015e8:	e1a01004 	mov	r1, r4
300015ec:	e1a00005 	mov	r0, r5
300015f0:	ebffff4d 	bl	3000132c <crc16>
300015f4:	e1a0b000 	mov	fp, r0
	clast = c;
300015f8:	e1a09005 	mov	r9, r5
	while(i--){
300015fc:	e3a0407f 	mov	r4, #127	; 0x7f
		tmpchar = *c++;
30001600:	e4d53001 	ldrb	r3, [r5], #1
30001604:	e5cd3007 	strb	r3, [sp, #7]
		con_send(tmpchar);
30001608:	e5dd0007 	ldrb	r0, [sp, #7]
3000160c:	ebfffc61 	bl	30000798 <s3c2440_serial_send_byte>
		check_sum += tmpchar;
30001610:	e5dd3007 	ldrb	r3, [sp, #7]
30001614:	e2444001 	sub	r4, r4, #1	; 0x1
30001618:	e0863003 	add	r3, r6, r3
3000161c:	e3740001 	cmn	r4, #1	; 0x1
30001620:	e20360ff 	and	r6, r3, #255	; 0xff
30001624:	1afffff5 	bne	30001600 <xmodem_1k_send+0x94>
	}
	if(check_way)
30001628:	e35a0000 	cmp	sl, #0	; 0x0
3000162c:	11a00006 	movne	r0, r6
30001630:	1a000003 	bne	30001644 <xmodem_1k_send+0xd8>
		con_send(check_sum);
	else{
		//con_send(0xb1);
		//con_send(0x47);
		con_send((check_crc16>>8) & 0xff);
30001634:	e1a0042b 	mov	r0, fp, lsr #8
30001638:	e20000ff 	and	r0, r0, #255	; 0xff
3000163c:	ebfffc55 	bl	30000798 <s3c2440_serial_send_byte>
		con_send(check_crc16 & 0xff);
30001640:	e20b00ff 	and	r0, fp, #255	; 0xff
30001644:	ebfffc53 	bl	30000798 <s3c2440_serial_send_byte>
	}	
	tmpchar = con_recv();
30001648:	ebfffc5c 	bl	300007c0 <s3c2440_serial_recv_byte>
3000164c:	e5cd0007 	strb	r0, [sp, #7]
	if(tmpchar == ACK)
30001650:	e5dd3007 	ldrb	r3, [sp, #7]
30001654:	e3530006 	cmp	r3, #6	; 0x6
30001658:	02873001 	addeq	r3, r7, #1	; 0x1
3000165c:	020370ff 	andeq	r7, r3, #255	; 0xff
30001660:	0affffd2 	beq	300015b0 <xmodem_1k_send+0x44>
		index++;
	else if(tmpchar == NACK)
30001664:	e3530015 	cmp	r3, #21	; 0x15
30001668:	01a05009 	moveq	r5, r9
3000166c:	0affffcf 	beq	300015b0 <xmodem_1k_send+0x44>
		c = clast;
	else
		while(1);
30001670:	eafffffe 	b	30001670 <xmodem_1k_send+0x104>
	goto start_send_package;
}
30001674:	e3a00004 	mov	r0, #4	; 0x4
30001678:	ebfffc46 	bl	30000798 <s3c2440_serial_send_byte>
3000167c:	ebfffc4f 	bl	300007c0 <s3c2440_serial_recv_byte>
30001680:	e28d1007 	add	r1, sp, #7	; 0x7
30001684:	e3a00802 	mov	r0, #131072	; 0x20000
30001688:	ebffff40 	bl	30001390 <time_limit_recv_byte>
3000168c:	e3a00000 	mov	r0, #0	; 0x0
30001690:	e28dd008 	add	sp, sp, #8	; 0x8
30001694:	e8bd8ef0 	ldmia	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}
30001698:	30002028 	andcc	r2, r0, r8, lsr #32
