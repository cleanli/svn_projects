
cleanboot.elf:     file format elf32-littlearm

Disassembly of section .text:

30000000 <_start>:
.globl _start
.globl get_psr
.globl test_int
.globl irq_handle
_start:	b       start_code
30000000:	ea000013 	b	30000054 <start_code>
	b       handle_int4
30000004:	ea0000a1 	b	30000290 <handle_int4>
	b       handle_int8
30000008:	ea0000a3 	b	3000029c <handle_int8>
	b       handle_intc
3000000c:	ea0000ab 	b	300002c0 <handle_intc>
	b       handle_int10
30000010:	ea0000ad 	b	300002cc <handle_int10>
	b       handle_int14
30000014:	ea0000af 	b	300002d8 <handle_int14>
	b       handle_int18
30000018:	ea0000b1 	b	300002e4 <handle_int18>
	b       handle_int1c
3000001c:	ea0000b4 	b	300002f4 <handle_int1c>

30000020 <mem_reg_value>:
30000020:	2211d110 	andcss	sp, r1, #4	; 0x4
30000024:	00000700 	andeq	r0, r0, r0, lsl #14
30000028:	00000700 	andeq	r0, r0, r0, lsl #14
3000002c:	00000700 	andeq	r0, r0, r0, lsl #14
30000030:	00000700 	andeq	r0, r0, r0, lsl #14
30000034:	00000700 	andeq	r0, r0, r0, lsl #14
30000038:	00000700 	andeq	r0, r0, r0, lsl #14
3000003c:	00018009 	andeq	r8, r1, r9
30000040:	00018009 	andeq	r8, r1, r9
30000044:	00ac03f4 	streqd	r0, [ip], r4
30000048:	000000b2 	streqh	r0, [r0], -r2
3000004c:	00000030 	andeq	r0, r0, r0, lsr r0
30000050:	00000030 	andeq	r0, r0, r0, lsr r0

30000054 <start_code>:
	.balignl 16,0xdeadbeef
.align 4

mem_reg_value:
        .long   0x2211d110
        .long   0x00000700
        .long   0x00000700
        .long   0x00000700
        .long   0x00000700
        .long   0x00000700
        .long   0x00000700
        .long   0x00018009
        .long   0x00018009
        .long   0x00ac03f4
        .long   0x000000b2
        .long   0x00000030
        .long   0x00000030
/*
 * the actual start code
 */

start_code:
	/*
	 * set the cpu to SVC32 mode
	 */
	mrs	r0,cpsr
30000054:	e10f0000 	mrs	r0, CPSR
	bic	r0,r0,#0x1f
30000058:	e3c0001f 	bic	r0, r0, #31	; 0x1f
	orr	r0,r0,#0xd3
3000005c:	e38000d3 	orr	r0, r0, #211	; 0xd3
	msr	cpsr,r0
30000060:	e129f000 	msr	CPSR_fc, r0


#  define pWTCON		0x53000000
#  define INTMSK		0x4A000008	/* Interupt-Controller base addresses */
#  define INTSUBMSK	0x4A00001C
#  define CLKDIVN	0x4C000014	/* clock divisor register */

	ldr     r0, =pWTCON
30000064:	e3a00453 	mov	r0, #1392508928	; 0x53000000
	mov     r1, #0x0
30000068:	e3a01000 	mov	r1, #0	; 0x0
	str     r1, [r0]
3000006c:	e5801000 	str	r1, [r0]

/*init sp*/
	@ldr	sp, =0x00000ff8
	ldr	sp, =0x30101000
30000070:	e59fd28c 	ldr	sp, [pc, #652]	; 30000304 <.text+0x304>

	/*
	 * mask all IRQs by setting all bits in the INTMR - default
	 */
	mov	r1, #0xfffffffe
30000074:	e3e01001 	mvn	r1, #1	; 0x1
	ldr	r0, =INTMSK
30000078:	e59f0288 	ldr	r0, [pc, #648]	; 30000308 <.text+0x308>
	str	r1, [r0]
3000007c:	e5801000 	str	r1, [r0]

	ldr	r1, =0x7ff
30000080:	e59f1284 	ldr	r1, [pc, #644]	; 3000030c <.text+0x30c>
	ldr	r0, =INTSUBMSK
30000084:	e59f0284 	ldr	r0, [pc, #644]	; 30000310 <.text+0x310>
	str	r1, [r0]
30000088:	e5801000 	str	r1, [r0]

/*******************************************************************************/
#  define GPFCON                0x56000050
#  define GPFDAT                0x56000054      /*  */
#  define EXTINT0               0x56000088
#  define LOCKTIME              0x4C000000
#  define MPLLCON               0x4C000004
#  define UPLLCON               0x4C000008

        ldr     r0, =GPFCON
3000008c:	e59f0280 	ldr	r0, [pc, #640]	; 30000314 <.text+0x314>
        ldr     r1, =0x5502
30000090:	e59f1280 	ldr	r1, [pc, #640]	; 30000318 <.text+0x318>
        str     r1, [r0]
30000094:	e5801000 	str	r1, [r0]
        ldr     r0, =EXTINT0
30000098:	e59f027c 	ldr	r0, [pc, #636]	; 3000031c <.text+0x31c>
        ldr     r1, =0x2
3000009c:	e3a01002 	mov	r1, #2	; 0x2
        str     r1, [r0]
300000a0:	e5801000 	str	r1, [r0]

        @initialize clock
        ldr     r0, =LOCKTIME
300000a4:	e3a00313 	mov	r0, #1275068416	; 0x4c000000
        ldr     r1, =0x00ffffff
300000a8:	e3e014ff 	mvn	r1, #-16777216	; 0xff000000
        str     r1, [r0]
300000ac:	e5801000 	str	r1, [r0]
        /* FCLK:HCLK:PCLK = 1:4:8 */
        ldr     r0, =CLKDIVN
300000b0:	e59f0268 	ldr	r0, [pc, #616]	; 30000320 <.text+0x320>
        mov     r1, #5
300000b4:	e3a01005 	mov	r1, #5	; 0x5
        str     r1, [r0]
300000b8:	e5801000 	str	r1, [r0]
        @open code cache
        mrc     p15,0,r1,c1,c0,0
300000bc:	ee111f10 	mrc	15, 0, r1, cr1, cr0, {0}
        orr     r1,r1,#0xc0000000
300000c0:	e3811103 	orr	r1, r1, #-1073741824	; 0xc0000000
        mcr     p15,0,r1,c1,c0,0
300000c4:	ee011f10 	mcr	15, 0, r1, cr1, cr0, {0}
        @UPLL setup
        ldr     r0, =UPLLCON
300000c8:	e59f0254 	ldr	r0, [pc, #596]	; 30000324 <.text+0x324>
        ldr     r1, =(0x38<<12|0x2<<4|0x2)
300000cc:	e59f1254 	ldr	r1, [pc, #596]	; 30000328 <.text+0x328>
        str     r1, [r0]
300000d0:	e5801000 	str	r1, [r0]
        nop
300000d4:	e1a00000 	nop			(mov r0,r0)
        nop
300000d8:	e1a00000 	nop			(mov r0,r0)
        nop
300000dc:	e1a00000 	nop			(mov r0,r0)
        nop
300000e0:	e1a00000 	nop			(mov r0,r0)
        nop
300000e4:	e1a00000 	nop			(mov r0,r0)
        nop
300000e8:	e1a00000 	nop			(mov r0,r0)
        nop
300000ec:	e1a00000 	nop			(mov r0,r0)

        @MPLL setup
        ldr     r0, =MPLLCON
300000f0:	e59f0234 	ldr	r0, [pc, #564]	; 3000032c <.text+0x32c>
        ldr     r1, =0x7f021
300000f4:	e59f1234 	ldr	r1, [pc, #564]	; 30000330 <.text+0x330>
        str     r1, [r0]
300000f8:	e5801000 	str	r1, [r0]
        nop
300000fc:	e1a00000 	nop			(mov r0,r0)
        nop
30000100:	e1a00000 	nop			(mov r0,r0)
        nop
30000104:	e1a00000 	nop			(mov r0,r0)
        nop
30000108:	e1a00000 	nop			(mov r0,r0)
        nop
3000010c:	e1a00000 	nop			(mov r0,r0)
        nop
30000110:	e1a00000 	nop			(mov r0,r0)
        nop
30000114:	e1a00000 	nop			(mov r0,r0)

        @memsetup
        ldr     r0, =0x48000000
30000118:	e3a00312 	mov	r0, #1207959552	; 0x48000000
        adrl    r1, mem_reg_value
3000011c:	e24f1f41 	sub	r1, pc, #260	; 0x104
30000120:	e1a00000 	nop			(mov r0,r0)
        ldr     r2, =0x48000030
30000124:	e59f2208 	ldr	r2, [pc, #520]	; 30000334 <.text+0x334>

30000128 <loop10>:
loop10:
        ldr     r4, [r1], #4
30000128:	e4914004 	ldr	r4, [r1], #4
        str     r4, [r0], #4
3000012c:	e4804004 	str	r4, [r0], #4
        cmp     r2, r0
30000130:	e1520000 	cmp	r2, r0
        bne     loop10
30000134:	1afffffb 	bne	30000128 <loop10>

#define GPHCON  0x56000070
#define GPHUP   0x56000078
#define ULCON0  0x50000000
#define UCCON0  0x50000004
#define UFCON0  0x50000008
#define USCON0  0x50000010
#define UTXH0   0x50000020
#define URXH0   0x50000024
#define UBRDIV0 0x50000028

/*Init serial port 0*/
        ldr     r0, =GPHCON
30000138:	e59f01f8 	ldr	r0, [pc, #504]	; 30000338 <.text+0x338>
        ldr     r1, =0xaaa0
3000013c:	e59f11f8 	ldr	r1, [pc, #504]	; 3000033c <.text+0x33c>
        str     r1, [r0]
30000140:	e5801000 	str	r1, [r0]
        ldr     r0, =GPHUP
30000144:	e59f01f4 	ldr	r0, [pc, #500]	; 30000340 <.text+0x340>
        ldr     r1, =0x7ff
30000148:	e59f11bc 	ldr	r1, [pc, #444]	; 3000030c <.text+0x30c>
        str     r1, [r0]
3000014c:	e5801000 	str	r1, [r0]
        ldr     r0, =ULCON0
30000150:	e3a00205 	mov	r0, #1342177280	; 0x50000000
        mov     r1, #0x3
30000154:	e3a01003 	mov	r1, #3	; 0x3
        str     r1, [r0]
30000158:	e5801000 	str	r1, [r0]
        ldr     r0, =UCCON0
3000015c:	e3a00245 	mov	r0, #1342177284	; 0x50000004
        mov     r1, #0x5
30000160:	e3a01005 	mov	r1, #5	; 0x5
        str     r1, [r0]
30000164:	e5801000 	str	r1, [r0]
        ldr     r0, =UBRDIV0
30000168:	e59f01d4 	ldr	r0, [pc, #468]	; 30000344 <.text+0x344>
        mov     r1, #0x1b
3000016c:	e3a0101b 	mov	r1, #27	; 0x1b
        str     r1, [r0]        /*set baudrate 115200bps*/
30000170:	e5801000 	str	r1, [r0]

        ldr     r0, =GPFDAT
30000174:	e59f01cc 	ldr	r0, [pc, #460]	; 30000348 <.text+0x348>
        mov     r1, #0x30
30000178:	e3a01030 	mov	r1, #48	; 0x30
        str     r1, [r0]
3000017c:	e5801000 	str	r1, [r0]
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
@ copy code to ram from nand
@
#define NAND_CTL_BASE   0x4e000000
#define oNFCONF         0x0
#define oNFCONT         0x4
#define oNFCMD          0x8
#define oNFSTAT         0x20

        @ reset NAND
        mov     r1, #NAND_CTL_BASE
30000180:	e3a0144e 	mov	r1, #1308622848	; 0x4e000000
        ldr     r2, =( (7<<12)|(7<<8)|(7<<4)|(0<<0) )
30000184:	e59f21c0 	ldr	r2, [pc, #448]	; 3000034c <.text+0x34c>
        str     r2, [r1, #oNFCONF]
30000188:	e5812000 	str	r2, [r1]
        ldr     r2, [r1, #oNFCONF]
3000018c:	e5912000 	ldr	r2, [r1]

        ldr     r2, =( (1<<4)|(0<<1)|(1<<0) ) @ Active low CE Control
30000190:	e3a02011 	mov	r2, #17	; 0x11
        str     r2, [r1, #oNFCONT]
30000194:	e5812004 	str	r2, [r1, #4]
        ldr     r2, [r1, #oNFCONT]
30000198:	e5912004 	ldr	r2, [r1, #4]

        ldr     r2, =(0x6)              @ RnB Clear
3000019c:	e3a02006 	mov	r2, #6	; 0x6
        str     r2, [r1, #oNFSTAT]
300001a0:	e5812020 	str	r2, [r1, #32]
        ldr     r2, [r1, #oNFSTAT]
300001a4:	e5912020 	ldr	r2, [r1, #32]

        mov     r2, #0xff               @ RESET command
300001a8:	e3a020ff 	mov	r2, #255	; 0xff
        strb    r2, [r1, #oNFCMD]
300001ac:	e5c12008 	strb	r2, [r1, #8]
        mov     r3, #0                  @ wait
300001b0:	e3a03000 	mov	r3, #0	; 0x0
1:      add     r3, r3, #0x1
300001b4:	e2833001 	add	r3, r3, #1	; 0x1
        cmp     r3, #0xa
300001b8:	e353000a 	cmp	r3, #10	; 0xa
        blt     1b
300001bc:	bafffffc 	blt	300001b4 <loop10+0x8c>
2:      ldr     r2, [r1, #oNFSTAT]      @ wait ready
300001c0:	e5912020 	ldr	r2, [r1, #32]
        tst     r2, #0x4
300001c4:	e3120004 	tst	r2, #4	; 0x4
        beq     2b
300001c8:	0afffffc 	beq	300001c0 <loop10+0x98>

        ldr     r2, [r1, #oNFCONT]
300001cc:	e5912004 	ldr	r2, [r1, #4]
        orr     r2, r2, #0x2            @ Flash Memory Chip Disable
300001d0:	e3822002 	orr	r2, r2, #2	; 0x2
        str     r2, [r1, #oNFCONT]
300001d4:	e5812004 	str	r2, [r1, #4]

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	@judge if in steppingstone
	mov	r0, pc
300001d8:	e1a0000f 	mov	r0, pc
	cmp	r0, #0x30000000
300001dc:	e3500203 	cmp	r0, #805306368	; 0x30000000
	bgt	jump_to_ram	@not in steppingstone, already in dram, go without copying nand code
300001e0:	ca00000f 	bgt	30000224 <jump_to_ram>

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @ get ready to call C functions (for nand_read())
        @ldr     sp, DW_STACK_START      @ has been setuped at start
        mov     fp, #0                  @ no previous frame, so fp=0
300001e4:	e3a0b000 	mov	fp, #0	; 0x0

#define TEXT_RAM_BASE   0x30000000
#define TEXT_NAND_BASE  0x0
#define TEXT_SIZE       0x100000

        @ copy
        ldr     r0, =TEXT_RAM_BASE
300001e8:	e3a00203 	mov	r0, #805306368	; 0x30000000
        ldr     r1, =TEXT_NAND_BASE
300001ec:	e3a01000 	mov	r1, #0	; 0x0
        ldr     r2, =TEXT_SIZE
300001f0:	e3a02601 	mov	r2, #1048576	; 0x100000
        bl      nand_read_ll
300001f4:	eb00052d 	bl	300016b0 <nand_read_ll>

        tst     r0, #0x0
300001f8:	e3100000 	tst	r0, #0	; 0x0
        bne     bad_nand_read
300001fc:	1a00001b 	bne	30000270 <bad_nand_read>

        @ verify
        mov     r0, #0
30000200:	e3a00000 	mov	r0, #0	; 0x0
        ldr     r1, =TEXT_NAND_BASE
30000204:	e3a01000 	mov	r1, #0	; 0x0
        mov     r2, #0x400      @ 4 bytes * 1024 = 4K-bytes
30000208:	e3a02b01 	mov	r2, #1024	; 0x400

3000020c <go_next>:
go_next:
        ldr     r3, [r0], #4
3000020c:	e4903004 	ldr	r3, [r0], #4
        ldr     r4, [r1], #4
30000210:	e4914004 	ldr	r4, [r1], #4
        teq     r3, r4
30000214:	e1330004 	teq	r3, r4
        bne     bad_nand_read
30000218:	1a000014 	bne	30000270 <bad_nand_read>
        subs    r2, r2, #4
3000021c:	e2522004 	subs	r2, r2, #4	; 0x4
        bne     go_next
30000220:	1afffff9 	bne	3000020c <go_next>

30000224 <jump_to_ram>:
	
	@jump to ram to run
jump_to_ram:
	@init stack
	msr	cpsr, #0xd1
30000224:	e329f0d1 	msr	CPSR_fc, #209	; 0xd1
	ldr	sp, =0x30102000
30000228:	e59fd120 	ldr	sp, [pc, #288]	; 30000350 <.text+0x350>
	msr	cpsr, #0xd2
3000022c:	e329f0d2 	msr	CPSR_fc, #210	; 0xd2
	ldr	sp, =0x30103000
30000230:	e59fd11c 	ldr	sp, [pc, #284]	; 30000354 <.text+0x354>
	msr	cpsr, #0xd3
30000234:	e329f0d3 	msr	CPSR_fc, #211	; 0xd3
	ldr	sp, =0x30104000
30000238:	e59fd118 	ldr	sp, [pc, #280]	; 30000358 <.text+0x358>
	msr	cpsr, #0xd7
3000023c:	e329f0d7 	msr	CPSR_fc, #215	; 0xd7
	ldr	sp, =0x30105000
30000240:	e59fd114 	ldr	sp, [pc, #276]	; 3000035c <.text+0x35c>
	msr	cpsr, #0xdb
30000244:	e329f0db 	msr	CPSR_fc, #219	; 0xdb
	ldr	sp, =0x30106000
30000248:	e59fd110 	ldr	sp, [pc, #272]	; 30000360 <.text+0x360>
	msr	cpsr, #0xdf
3000024c:	e329f0df 	msr	CPSR_fc, #223	; 0xdf
	ldr	sp, =0x30107000
30000250:	e59fd10c 	ldr	sp, [pc, #268]	; 30000364 <.text+0x364>
	@open interrupt and switch to user mode
	msr	cpsr, #0x10
30000254:	e329f010 	msr	CPSR_fc, #16	; 0x10
	ldr	sp, =0x30108000
30000258:	e59fd108 	ldr	sp, [pc, #264]	; 30000368 <.text+0x368>

	ldr     r1, =here_is_ram
3000025c:	e59f1108 	ldr	r1, [pc, #264]	; 3000036c <.text+0x36c>
        add     pc, r1, #0
30000260:	e281f000 	add	pc, r1, #0	; 0x0
        nop
30000264:	e1a00000 	nop			(mov r0,r0)
        nop
30000268:	e1a00000 	nop			(mov r0,r0)
        b       .              @ infinite loop
3000026c:	eafffffe 	b	3000026c <jump_to_ram+0x48>

30000270 <bad_nand_read>:
bad_nand_read:
        mov    	r0, #'E'
30000270:	e3a00045 	mov	r0, #69	; 0x45
	bl	s3c2440_serial_send_byte
30000274:	eb000691 	bl	30001cc0 <s3c2440_serial_send_byte>
	b	.
30000278:	eafffffe 	b	30000278 <bad_nand_read+0x8>

3000027c <here_is_ram>:

here_is_ram:
        b       main
3000027c:	ea00044b 	b	300013b0 <main>

30000280 <get_psr>:
                                                    
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
get_psr:
	mrs 	r0, cpsr
30000280:	e10f0000 	mrs	r0, CPSR
	mov	pc, lr
30000284:	e1a0f00e 	mov	pc, lr

30000288 <test_int>:

test_int:
/*
	stmfd	sp!, {lr}
	mrs	r0, cpsr
	bl	print_hex
	ldr	r0, =changeline
	bl	print_string
	swi	0
	mrs	r0, cpsr
	bl	print_hex
	ldr	r0, =changeline
	bl	print_string
	ldmfd   sp!, {pc}^
	mov	pc, lr
*/
	swi	0
30000288:	ef000000 	swi	0x00000000
        ldr	pc, =0                                   
3000028c:	e3a0f000 	mov	pc, #0	; 0x0

30000290 <handle_int4>:

handle_int4:
        mov    	r0, #'4'
30000290:	e3a00034 	mov	r0, #52	; 0x34
	bl	s3c2440_serial_send_byte
30000294:	eb000689 	bl	30001cc0 <s3c2440_serial_send_byte>
	b	_start
30000298:	eaffff58 	b	30000000 <_start>

3000029c <handle_int8>:
handle_int8:
	mov 	pc, lr
3000029c:	e1a0f00e 	mov	pc, lr
	stmfd	sp!, {r0-r12,lr}
300002a0:	e92d5fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	mrs	r0, spsr
300002a4:	e14f0000 	mrs	r0, SPSR
	bl 	print_hex
300002a8:	eb0004a1 	bl	30001534 <print_hex>
	mrs	r0, cpsr
300002ac:	e10f0000 	mrs	r0, CPSR
	bl	print_hex
300002b0:	eb00049f 	bl	30001534 <print_hex>
	mov	r0, #0xff000000
300002b4:	e3a004ff 	mov	r0, #-16777216	; 0xff000000
	bl	print_hex
300002b8:	eb00049d 	bl	30001534 <print_hex>
	ldmfd   sp!, {r0-r12,pc}^
300002bc:	e8fd9fff 	ldmia	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}^

300002c0 <handle_intc>:
handle_intc:
        mov    	r0, #'c'
300002c0:	e3a00063 	mov	r0, #99	; 0x63
	bl	s3c2440_serial_send_byte
300002c4:	eb00067d 	bl	30001cc0 <s3c2440_serial_send_byte>
	b	.
300002c8:	eafffffe 	b	300002c8 <handle_intc+0x8>

300002cc <handle_int10>:
handle_int10:
        mov    	r0, #'0'
300002cc:	e3a00030 	mov	r0, #48	; 0x30
	bl	s3c2440_serial_send_byte
300002d0:	eb00067a 	bl	30001cc0 <s3c2440_serial_send_byte>
	b	.
300002d4:	eafffffe 	b	300002d4 <handle_int10+0x8>

300002d8 <handle_int14>:
handle_int14:
        mov    	r0, #'E'
300002d8:	e3a00045 	mov	r0, #69	; 0x45
	bl	s3c2440_serial_send_byte
300002dc:	eb000677 	bl	30001cc0 <s3c2440_serial_send_byte>
	b	.
300002e0:	eafffffe 	b	300002e0 <handle_int14+0x8>

300002e4 <handle_int18>:
handle_int18:
	sub	lr, lr, #4
300002e4:	e24ee004 	sub	lr, lr, #4	; 0x4
	stmfd	sp!, {r0-r12,lr}
300002e8:	e92d5fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	bl	irq_handle
300002ec:	eb0006df 	bl	30001e70 <irq_handle>
	ldmfd   sp!, {r0-r12,pc}^
300002f0:	e8fd9fff 	ldmia	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}^

300002f4 <handle_int1c>:
handle_int1c:
        mov    	r0, #'F'
300002f4:	e3a00046 	mov	r0, #70	; 0x46
	bl	s3c2440_serial_send_byte
300002f8:	eb000670 	bl	30001cc0 <s3c2440_serial_send_byte>
	b	.
300002fc:	eafffffe 	b	300002fc <handle_int1c+0x8>

30000300 <changeline>:
30000300:	00000a0d 	andeq	r0, r0, sp, lsl #20
30000304:	30101000 	andccs	r1, r0, r0
30000308:	4a000008 	bmi	30000330 <.text+0x330>
3000030c:	000007ff 	streqd	r0, [r0], -pc
30000310:	4a00001c 	bmi	30000388 <.text+0x388>
30000314:	56000050 	undefined
30000318:	00005502 	andeq	r5, r0, r2, lsl #10
3000031c:	56000088 	strpl	r0, [r0], -r8, lsl #1
30000320:	4c000014 	stcmi	0, cr0, [r0], {20}
30000324:	4c000008 	stcmi	0, cr0, [r0], {8}
30000328:	00038022 	andeq	r8, r3, r2, lsr #32
3000032c:	4c000004 	stcmi	0, cr0, [r0], {4}
30000330:	0007f021 	andeq	pc, r7, r1, lsr #32
30000334:	48000030 	stmmida	r0, {r4, r5}
30000338:	56000070 	undefined
3000033c:	0000aaa0 	andeq	sl, r0, r0, lsr #21
30000340:	56000078 	undefined
30000344:	50000028 	andpl	r0, r0, r8, lsr #32
30000348:	56000054 	undefined
3000034c:	00007770 	andeq	r7, r0, r0, ror r7
30000350:	30102000 	andccs	r2, r0, r0
30000354:	30103000 	andccs	r3, r0, r0
30000358:	30104000 	andccs	r4, r0, r0
3000035c:	30105000 	andccs	r5, r0, r0
30000360:	30106000 	andccs	r6, r0, r0
30000364:	30107000 	andccs	r7, r0, r0
30000368:	30108000 	andccs	r8, r0, r0
3000036c:	3000027c 	andcc	r0, r0, ip, ror r2

30000370 <prt>:
	return a;
}
*/
void prt(unsigned char *p)
{
30000370:	e52de004 	str	lr, [sp, #-4]!
	//get_psr();
	lprint("current CPSR = 0x%x\r\n", get_psr());
30000374:	ebffffc1 	bl	30000280 <get_psr>
30000378:	e1a01000 	mov	r1, r0
3000037c:	e59f0004 	ldr	r0, [pc, #4]	; 30000388 <.text+0x388>
30000380:	e49de004 	ldr	lr, [sp], #4
30000384:	ea00047e 	b	30001584 <lprint>
30000388:	300031f8 	strccd	r3, [r0], -r8

3000038c <test>:
}
void test(unsigned char *p)
{
/*
	uint t = 10;
	while(t--){
		delay_us(1000000);
		lprint("%x\r\n", t);
	}
*/
/*
	while(1)
		lprint("%x\r\n", con_recv());
*/
/*
        print_mem(cs8900_mac, 6);
*/
/*
	test_random();
*/
	test_int();
3000038c:	eaffffbd 	b	30000288 <test_int>

30000390 <reboot>:
}

void reboot(unsigned char *p)
{
30000390:	e52de004 	str	lr, [sp, #-4]!
	lprint("rebooting...\r\n");
30000394:	e59f0018 	ldr	r0, [pc, #24]	; 300003b4 <.text+0x3b4>
30000398:	eb000479 	bl	30001584 <lprint>
	delay_us(100000);
3000039c:	e59f0014 	ldr	r0, [pc, #20]	; 300003b8 <.text+0x3b8>
300003a0:	eb00034d 	bl	300010dc <delay_us>
	((void(*const)())0)();
300003a4:	e3a03000 	mov	r3, #0	; 0x0
300003a8:	e1a0e00f 	mov	lr, pc
300003ac:	e1a0f003 	mov	pc, r3
300003b0:	e49df004 	ldr	pc, [sp], #4
300003b4:	30003210 	andcc	r3, r0, r0, lsl r2
300003b8:	000186a0 	andeq	r8, r1, r0, lsr #13

300003bc <tftpget>:
}

void tftpget(unsigned char *p)
{
300003bc:	e92d4010 	stmdb	sp!, {r4, lr}
300003c0:	e1a04000 	mov	r4, r0
	if(get_howmany_para(p) != 1)
300003c4:	eb0000fd 	bl	300007c0 <get_howmany_para>
300003c8:	e3500001 	cmp	r0, #1	; 0x1
300003cc:	1a00000a 	bne	300003fc <tftpget+0x40>
		goto error;
	while(*p == ' ')
300003d0:	e5d43000 	ldrb	r3, [r4]
300003d4:	e3530020 	cmp	r3, #32	; 0x20
300003d8:	1a000002 	bne	300003e8 <tftpget+0x2c>
		p++;
300003dc:	e5f43001 	ldrb	r3, [r4, #1]!
300003e0:	e3530020 	cmp	r3, #32	; 0x20
300003e4:	0afffffc 	beq	300003dc <tftpget+0x20>
	tftp_get(p, mrw_addr);
300003e8:	e59f3018 	ldr	r3, [pc, #24]	; 30000408 <.text+0x408>
300003ec:	e5931000 	ldr	r1, [r3]
300003f0:	e1a00004 	mov	r0, r4
300003f4:	e8bd4010 	ldmia	sp!, {r4, lr}
300003f8:	ea0006fa 	b	30001fe8 <tftp_get>
	return;
error:
    lprint("Error para!\r\ntftpget (name)\r\n");
300003fc:	e59f0008 	ldr	r0, [pc, #8]	; 3000040c <.text+0x40c>
30000400:	e8bd4010 	ldmia	sp!, {r4, lr}
30000404:	ea00045e 	b	30001584 <lprint>
30000408:	30003e34 	andcc	r3, r0, r4, lsr lr
3000040c:	30003220 	andcc	r3, r0, r0, lsr #4

30000410 <tftpput>:
}
void tftpput(unsigned char *p)
{
30000410:	e92d4010 	stmdb	sp!, {r4, lr}
30000414:	e24dd004 	sub	sp, sp, #4	; 0x4
30000418:	e1a04000 	mov	r4, r0
	uint sz;
	if(get_howmany_para(p) != 2)
3000041c:	eb0000e7 	bl	300007c0 <get_howmany_para>
30000420:	e1a03000 	mov	r3, r0
30000424:	e3530002 	cmp	r3, #2	; 0x2
30000428:	e1a0100d 	mov	r1, sp
3000042c:	e1a00004 	mov	r0, r4
30000430:	1a000005 	bne	3000044c <tftpput+0x3c>
		goto error;
    	p = str_to_hex(p, &sz);
30000434:	eb0000f7 	bl	30000818 <str_to_hex>
	tftp_put(p, sz, mrw_addr);
30000438:	e59f301c 	ldr	r3, [pc, #28]	; 3000045c <.text+0x45c>
3000043c:	e59d1000 	ldr	r1, [sp]
30000440:	e5932000 	ldr	r2, [r3]
30000444:	eb0006d8 	bl	30001fac <tftp_put>
	return;
30000448:	ea000001 	b	30000454 <tftpput+0x44>
error:
    lprint("Error para!\r\ntftpput (filesize) (name)\r\n");
3000044c:	e59f000c 	ldr	r0, [pc, #12]	; 30000460 <.text+0x460>
30000450:	eb00044b 	bl	30001584 <lprint>
}
30000454:	e28dd004 	add	sp, sp, #4	; 0x4
30000458:	e8bd8010 	ldmia	sp!, {r4, pc}
3000045c:	30003e34 	andcc	r3, r0, r4, lsr lr
30000460:	30003240 	andcc	r3, r0, r0, asr #4

30000464 <setip>:
void setip(unsigned char *p)
{
30000464:	e1a0f00e 	mov	pc, lr

30000468 <rw_byte>:
}
void rw_byte(unsigned char *p)
{
30000468:	e92d4030 	stmdb	sp!, {r4, r5, lr}
3000046c:	e24dd008 	sub	sp, sp, #8	; 0x8
30000470:	e1a05000 	mov	r5, r0
    uint addr, tmp, c;

    tmp = get_howmany_para(p);
30000474:	eb0000d1 	bl	300007c0 <get_howmany_para>
30000478:	e1a04000 	mov	r4, r0
    if(tmp != 1 && tmp != 2)
3000047c:	e2443001 	sub	r3, r4, #1	; 0x1
30000480:	e3530001 	cmp	r3, #1	; 0x1
30000484:	e59f005c 	ldr	r0, [pc, #92]	; 300004e8 <.text+0x4e8>
30000488:	e28d1004 	add	r1, sp, #4	; 0x4
3000048c:	8a000012 	bhi	300004dc <rw_byte+0x74>
        goto error;
    p = str_to_hex(p, &addr);
30000490:	e1a00005 	mov	r0, r5
30000494:	eb0000df 	bl	30000818 <str_to_hex>
    if(tmp == 1)
30000498:	e3540001 	cmp	r4, #1	; 0x1
	goto read;
    p = str_to_hex(p, &c);
    c &= 0xff;
write:
    *(unsigned char*)addr = c;
    lprint("write %x to addr %x\r\n", c, addr);
    return;
read:
    lprint("read %x at addr %x\r\n", *(unsigned short*)addr&0xff, addr);
3000049c:	059d3004 	ldreq	r3, [sp, #4]
300004a0:	e1a0100d 	mov	r1, sp
300004a4:	059f0040 	ldreq	r0, [pc, #64]	; 300004ec <.text+0x4ec>
300004a8:	01a02003 	moveq	r2, r3
300004ac:	05d31000 	ldreqb	r1, [r3]
300004b0:	0a000007 	beq	300004d4 <rw_byte+0x6c>
300004b4:	eb0000d7 	bl	30000818 <str_to_hex>
300004b8:	e5dd3000 	ldrb	r3, [sp]
300004bc:	e58d3000 	str	r3, [sp]
300004c0:	e59d3004 	ldr	r3, [sp, #4]
300004c4:	e5dd2000 	ldrb	r2, [sp]
300004c8:	e5c32000 	strb	r2, [r3]
300004cc:	e89d0006 	ldmia	sp, {r1, r2}
300004d0:	e59f0018 	ldr	r0, [pc, #24]	; 300004f0 <.text+0x4f0>
300004d4:	eb00042a 	bl	30001584 <lprint>
    return;
300004d8:	ea000000 	b	300004e0 <rw_byte+0x78>

error:
    lprint("Error para!\r\nrww (hex addr) [value], will write if have value para\r\n");
300004dc:	eb000428 	bl	30001584 <lprint>

}
300004e0:	e28dd008 	add	sp, sp, #8	; 0x8
300004e4:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
300004e8:	3000326c 	andcc	r3, r0, ip, ror #4
300004ec:	300032b4 	strcch	r3, [r0], -r4
300004f0:	300032cc 	andcc	r3, r0, ip, asr #5

300004f4 <rw_word>:

void rw_word(unsigned char *p)
{
300004f4:	e92d4030 	stmdb	sp!, {r4, r5, lr}
300004f8:	e24dd008 	sub	sp, sp, #8	; 0x8
300004fc:	e1a05000 	mov	r5, r0
    uint addr, tmp, c;

    tmp = get_howmany_para(p);
30000500:	eb0000ae 	bl	300007c0 <get_howmany_para>
30000504:	e1a04000 	mov	r4, r0
    if(tmp != 1 && tmp != 2)
30000508:	e2443001 	sub	r3, r4, #1	; 0x1
3000050c:	e3530001 	cmp	r3, #1	; 0x1
30000510:	e59f0064 	ldr	r0, [pc, #100]	; 3000057c <.text+0x57c>
30000514:	e28d1004 	add	r1, sp, #4	; 0x4
30000518:	8a000014 	bhi	30000570 <rw_word+0x7c>
        goto error;
    p = str_to_hex(p, &addr);
3000051c:	e1a00005 	mov	r0, r5
30000520:	eb0000bc 	bl	30000818 <str_to_hex>
    addr &= ~1;
30000524:	e59d3004 	ldr	r3, [sp, #4]
30000528:	e3c33001 	bic	r3, r3, #1	; 0x1
3000052c:	e58d3004 	str	r3, [sp, #4]
    if(tmp == 1)
30000530:	e3540001 	cmp	r4, #1	; 0x1
30000534:	e1a0100d 	mov	r1, sp
30000538:	e1a02003 	mov	r2, r3
	goto read;
    p = str_to_hex(p, &c);
    c &= 0xffff;
write:
    *(unsigned short*)addr = c;
    lprint("write %x to addr %x\r\n", c, addr);
    return;
read:
    lprint("read %x at addr %x\r\n", *(unsigned short*)addr&0xffff, addr);
3000053c:	01d310b0 	ldreqh	r1, [r3]
30000540:	059f0038 	ldreq	r0, [pc, #56]	; 30000580 <.text+0x580>
30000544:	0a000007 	beq	30000568 <rw_word+0x74>
30000548:	eb0000b2 	bl	30000818 <str_to_hex>
3000054c:	e1dd30b0 	ldrh	r3, [sp]
30000550:	e58d3000 	str	r3, [sp]
30000554:	e59d3004 	ldr	r3, [sp, #4]
30000558:	e1dd20b0 	ldrh	r2, [sp]
3000055c:	e1c320b0 	strh	r2, [r3]
30000560:	e89d0006 	ldmia	sp, {r1, r2}
30000564:	e59f0018 	ldr	r0, [pc, #24]	; 30000584 <.text+0x584>
30000568:	eb000405 	bl	30001584 <lprint>
    return;
3000056c:	ea000000 	b	30000574 <rw_word+0x80>

error:
    lprint("Error para!\r\nrww (hex addr) [value], will write if have value para\r\n");
30000570:	eb000403 	bl	30001584 <lprint>

}
30000574:	e28dd008 	add	sp, sp, #8	; 0x8
30000578:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
3000057c:	3000326c 	andcc	r3, r0, ip, ror #4
30000580:	300032b4 	strcch	r3, [r0], -r4
30000584:	300032cc 	andcc	r3, r0, ip, asr #5

30000588 <ndchkbb>:

void ndchkbb(unsigned char *para)
{
30000588:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
	uint i, addr, marked_bad = 0, addr_list[16];
	lprint("I will check all block(0 - 0x%x) on current K9f1208 and find out all marked bad block, please wait!\r\n", 0x4000 * 4096);
3000058c:	e59f0090 	ldr	r0, [pc, #144]	; 30000624 <.text+0x624>
30000590:	e24dd040 	sub	sp, sp, #64	; 0x40
30000594:	e3a01301 	mov	r1, #67108864	; 0x4000000
30000598:	eb0003f9 	bl	30001584 <lprint>
3000059c:	e3a04000 	mov	r4, #0	; 0x0
	i = 4096;
	addr = 0;
	while(i--){
300005a0:	e59f7080 	ldr	r7, [pc, #128]	; 30000628 <.text+0x628>
300005a4:	e1a05004 	mov	r5, r4
300005a8:	e28d6040 	add	r6, sp, #64	; 0x40
		if(is_marked_bad_block(addr)){
300005ac:	e1a00005 	mov	r0, r5
300005b0:	eb0004f1 	bl	3000197c <is_marked_bad_block>
300005b4:	e1a03000 	mov	r3, r0
300005b8:	e3530000 	cmp	r3, #0	; 0x0
300005bc:	e3a00058 	mov	r0, #88	; 0x58
			addr_list[marked_bad++] = addr;
			con_send('X');
		}
		else
			con_send('O');
		addr += 0x4000;
300005c0:	e2477001 	sub	r7, r7, #1	; 0x1
300005c4:	03a0004f 	moveq	r0, #79	; 0x4f
300005c8:	15065040 	strne	r5, [r6, #-64]
300005cc:	12844001 	addne	r4, r4, #1	; 0x1
300005d0:	12866004 	addne	r6, r6, #4	; 0x4
300005d4:	eb0005b9 	bl	30001cc0 <s3c2440_serial_send_byte>
300005d8:	e3770001 	cmn	r7, #1	; 0x1
300005dc:	e2855901 	add	r5, r5, #16384	; 0x4000
300005e0:	1afffff1 	bne	300005ac <ndchkbb+0x24>
	}	
	lprint("\r\ncheck over! %x blocks bad.\r\n", marked_bad);
300005e4:	e1a01004 	mov	r1, r4
300005e8:	e59f003c 	ldr	r0, [pc, #60]	; 3000062c <.text+0x62c>
	i = 0;
	while(marked_bad--)
300005ec:	e2444001 	sub	r4, r4, #1	; 0x1
300005f0:	eb0003e3 	bl	30001584 <lprint>
300005f4:	e3740001 	cmn	r4, #1	; 0x1
300005f8:	0a000007 	beq	3000061c <ndchkbb+0x94>
300005fc:	e28d5040 	add	r5, sp, #64	; 0x40
		lprint("%x\r\n", addr_list[i++]); 
30000600:	e5151040 	ldr	r1, [r5, #-64]
30000604:	e59f0024 	ldr	r0, [pc, #36]	; 30000630 <.text+0x630>
30000608:	e2444001 	sub	r4, r4, #1	; 0x1
3000060c:	eb0003dc 	bl	30001584 <lprint>
30000610:	e3740001 	cmn	r4, #1	; 0x1
30000614:	e2855004 	add	r5, r5, #4	; 0x4
30000618:	1afffff8 	bne	30000600 <ndchkbb+0x78>
3000061c:	e28dd040 	add	sp, sp, #64	; 0x40
30000620:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
30000624:	300032e4 	andcc	r3, r0, r4, ror #5
30000628:	00000fff 	streqd	r0, [r0], -pc
3000062c:	3000334c 	andcc	r3, r0, ip, asr #6
30000630:	3000373c 	andcc	r3, r0, ip, lsr r7

30000634 <go>:
}

void go(unsigned char *para)
{
30000634:	e52de004 	str	lr, [sp, #-4]!
	lprint("This will go at the addr you just used with the 'r' cmd. Any problem please check!\r\n");
30000638:	e59f0010 	ldr	r0, [pc, #16]	; 30000650 <.text+0x650>
3000063c:	eb0003d0 	bl	30001584 <lprint>
	(*((void (*)())mrw_addr))();
30000640:	e59f300c 	ldr	r3, [pc, #12]	; 30000654 <.text+0x654>
30000644:	e1a0e00f 	mov	lr, pc
30000648:	e593f000 	ldr	pc, [r3]
3000064c:	e49df004 	ldr	pc, [sp], #4
30000650:	3000336c 	andcc	r3, r0, ip, ror #6
30000654:	30003e34 	andcc	r3, r0, r4, lsr lr

30000658 <put_file_by_serial>:
}

void put_file_by_serial(unsigned char *p)
{
30000658:	e92d4010 	stmdb	sp!, {r4, lr}
    uint length = 0x80, tmp, i;
3000065c:	e3a03080 	mov	r3, #128	; 0x80
30000660:	e24dd004 	sub	sp, sp, #4	; 0x4
30000664:	e58d3000 	str	r3, [sp]
30000668:	e1a04000 	mov	r4, r0

    tmp = get_howmany_para(p);
3000066c:	eb000053 	bl	300007c0 <get_howmany_para>
    if( tmp > 1)
30000670:	e3500001 	cmp	r0, #1	; 0x1
30000674:	e1a03000 	mov	r3, r0
30000678:	8a00000e 	bhi	300006b8 <put_file_by_serial+0x60>
        goto error;
    if(tmp == 0)
3000067c:	e3530000 	cmp	r3, #0	; 0x0
30000680:	e1a00004 	mov	r0, r4
30000684:	e1a0100d 	mov	r1, sp
30000688:	0a000005 	beq	300006a4 <put_file_by_serial+0x4c>
        goto modemsend;
    str_to_hex(p, &length);
3000068c:	eb000061 	bl	30000818 <str_to_hex>
    length >>= 7;
30000690:	e59d3000 	ldr	r3, [sp]
30000694:	e1a033a3 	mov	r3, r3, lsr #7
    if(!length)
30000698:	e3530000 	cmp	r3, #0	; 0x0
3000069c:	e58d3000 	str	r3, [sp]
300006a0:	0a000004 	beq	300006b8 <put_file_by_serial+0x60>
	goto error;
modemsend:
	xmodem_1k_send((unsigned char*)mrw_addr, length);
300006a4:	e59f301c 	ldr	r3, [pc, #28]	; 300006c8 <.text+0x6c8>
300006a8:	e59d1000 	ldr	r1, [sp]
300006ac:	e5930000 	ldr	r0, [r3]
300006b0:	eb00095a 	bl	30002c20 <xmodem_1k_send>
	return;
300006b4:	ea000001 	b	300006c0 <put_file_by_serial+0x68>
error:
    lprint("Error para!\r\npfbs [length(0x80bytes x n)](default 0x80(16k) if no this argu)\r\n");
300006b8:	e59f000c 	ldr	r0, [pc, #12]	; 300006cc <.text+0x6cc>
300006bc:	eb0003b0 	bl	30001584 <lprint>
} 
300006c0:	e28dd004 	add	sp, sp, #4	; 0x4
300006c4:	e8bd8010 	ldmia	sp!, {r4, pc}
300006c8:	30003e34 	andcc	r3, r0, r4, lsr lr
300006cc:	300033c4 	andcc	r3, r0, r4, asr #7

300006d0 <get_file_by_serial>:

void get_file_by_serial(unsigned char *para)
{
300006d0:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
300006d4:	e1a05000 	mov	r5, r0
	uint tmp;
	lprint("if any other para after 'go', the file will auto go 15s later or any key!\r\n");
300006d8:	e59f0038 	ldr	r0, [pc, #56]	; 30000718 <.text+0x718>
300006dc:	eb0003a8 	bl	30001584 <lprint>
    	tmp = get_howmany_para(para);
300006e0:	e1a00005 	mov	r0, r5
300006e4:	eb000035 	bl	300007c0 <get_howmany_para>
	xmodem_1k_recv((unsigned char*)mrw_addr);
300006e8:	e59f602c 	ldr	r6, [pc, #44]	; 3000071c <.text+0x71c>
300006ec:	e1a04000 	mov	r4, r0
300006f0:	e5960000 	ldr	r0, [r6]
300006f4:	eb0008ed 	bl	30002ab0 <xmodem_1k_recv>
	if(tmp != 0){
300006f8:	e3540000 	cmp	r4, #0	; 0x0
300006fc:	e1a01005 	mov	r1, r5
30000700:	e3a00503 	mov	r0, #12582912	; 0xc00000
30000704:	08bd8070 	ldmeqia	sp!, {r4, r5, r6, pc}
                time_limit_recv_byte(0xc00000, para);
30000708:	eb0008d6 	bl	30002a68 <time_limit_recv_byte>
		(*((void (*)())mrw_addr))();
3000070c:	e1a0e00f 	mov	lr, pc
30000710:	e596f000 	ldr	pc, [r6]
	}
		

/*
	uint i = 1028, tmp = 0x20000, repeat = 36;
	unsigned char *c = (unsigned char*const)0xbf4;

	lprint("\r\nNow start(*0xbf4 = 0 will be test):\r\n\r\n");
	if(*c)
		con_send(0x15);
	else
		lprint("\r\nTest, time is up!\r\n");
	while(tmp--)
		if(is_con_recv())
			break;
	while(i--)
		*c++ = con_recv();
	con_send(0x06);
	*c++ = con_recv();
	con_send(0x06);
*/
}
30000714:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30000718:	30003414 	andcc	r3, r0, r4, lsl r4
3000071c:	30003e34 	andcc	r3, r0, r4, lsr lr

30000720 <print_help>:

void print_help(unsigned char *para)
{
30000720:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    uint i = 0;
    lprint("Clean Boot V%s\r\nAvailable cmd is:\r\n\r\n", CLEAN_BOOT_VERSION);
30000724:	e59f0044 	ldr	r0, [pc, #68]	; 30000770 <.text+0x770>
30000728:	e59f1044 	ldr	r1, [pc, #68]	; 30000774 <.text+0x774>
3000072c:	eb000394 	bl	30001584 <lprint>
    while(1){
30000730:	e59f5040 	ldr	r5, [pc, #64]	; 30000778 <.text+0x778>
30000734:	e3a04000 	mov	r4, #0	; 0x0
            if(cmd_list[i].cmd_name == NULL)
30000738:	e59f3038 	ldr	r3, [pc, #56]	; 30000778 <.text+0x778>
3000073c:	e7943003 	ldr	r3, [r4, r3]
30000740:	e3530000 	cmp	r3, #0	; 0x0
30000744:	e59f0030 	ldr	r0, [pc, #48]	; 3000077c <.text+0x77c>
30000748:	e1a01003 	mov	r1, r3
3000074c:	e284400c 	add	r4, r4, #12	; 0xc
30000750:	0a000003 	beq	30000764 <print_help+0x44>
                    break;
	    lprint("--%s: %s\r\n", cmd_list[i].cmd_name, cmd_list[i].cmd_des);
30000754:	e5952008 	ldr	r2, [r5, #8]
	    //lprint("--%s\r\n\t%s\r\n", cmd_list[i].cmd_name, cmd_list[i].cmd_des);
            i++;
30000758:	e285500c 	add	r5, r5, #12	; 0xc
3000075c:	eb000388 	bl	30001584 <lprint>
30000760:	eafffff4 	b	30000738 <print_help+0x18>
    }
    lprint("\r\n'r' is a special command, if a address followed, it will be set as a memory base for many other command, such as 'pm', and so on\r\nESC will cancel current command\r\n");
30000764:	e59f0014 	ldr	r0, [pc, #20]	; 30000780 <.text+0x780>
30000768:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
3000076c:	ea000384 	b	30001584 <lprint>
30000770:	30003460 	andcc	r3, r0, r0, ror #8
30000774:	30003488 	andcc	r3, r0, r8, lsl #9
30000778:	30002d50 	andcc	r2, r0, r0, asr sp
3000077c:	30003548 	andcc	r3, r0, r8, asr #10
30000780:	30003554 	andcc	r3, r0, r4, asr r5

30000784 <asc_to_hex>:
}

uint asc_to_hex(unsigned char c)
{
30000784:	e20000ff 	and	r0, r0, #255	; 0xff
	uint v;

	if(c >= '0' && c <= '9')
30000788:	e2402030 	sub	r2, r0, #48	; 0x30
3000078c:	e20230ff 	and	r3, r2, #255	; 0xff
30000790:	e3530009 	cmp	r3, #9	; 0x9
30000794:	e2401041 	sub	r1, r0, #65	; 0x41
30000798:	9a000006 	bls	300007b8 <asc_to_hex+0x34>
		return c - '0';	
	if(c >= 'A' && c <= 'F')
3000079c:	e3510005 	cmp	r1, #5	; 0x5
300007a0:	e2403061 	sub	r3, r0, #97	; 0x61
300007a4:	e2402037 	sub	r2, r0, #55	; 0x37
300007a8:	9a000002 	bls	300007b8 <asc_to_hex+0x34>
		return c - 'A' + 10;
	if(c >= 'a' && c <= 'f')
300007ac:	e3530005 	cmp	r3, #5	; 0x5
300007b0:	e2402057 	sub	r2, r0, #87	; 0x57
		return c - 'a' + 10;
	return 0;
300007b4:	83a02000 	movhi	r2, #0	; 0x0
}
300007b8:	e1a00002 	mov	r0, r2
300007bc:	e1a0f00e 	mov	pc, lr

300007c0 <get_howmany_para>:

uint get_howmany_para(unsigned char *s)
{
	uint tmp = 0;
300007c0:	e3a02000 	mov	r2, #0	; 0x0
	while(1){
		while(*s == ' ')
300007c4:	e5d03000 	ldrb	r3, [r0]
300007c8:	e3530020 	cmp	r3, #32	; 0x20
300007cc:	1a000002 	bne	300007dc <get_howmany_para+0x1c>
			s++;
300007d0:	e5f03001 	ldrb	r3, [r0, #1]!
300007d4:	e3530020 	cmp	r3, #32	; 0x20
300007d8:	0afffffc 	beq	300007d0 <get_howmany_para+0x10>
		if(*s)
300007dc:	e5d03000 	ldrb	r3, [r0]
300007e0:	e3530000 	cmp	r3, #0	; 0x0
			tmp++;
300007e4:	12822001 	addne	r2, r2, #1	; 0x1
		while(*s != ' ' && *s)
300007e8:	e3530020 	cmp	r3, #32	; 0x20
300007ec:	13530000 	cmpne	r3, #0	; 0x0
300007f0:	0a000003 	beq	30000804 <get_howmany_para+0x44>
			s++;
300007f4:	e5f03001 	ldrb	r3, [r0, #1]!
300007f8:	e3530020 	cmp	r3, #32	; 0x20
300007fc:	13530000 	cmpne	r3, #0	; 0x0
30000800:	1afffffb 	bne	300007f4 <get_howmany_para+0x34>
		if(!*s)
30000804:	e5d03000 	ldrb	r3, [r0]
30000808:	e3530000 	cmp	r3, #0	; 0x0
3000080c:	01a00002 	moveq	r0, r2
30000810:	01a0f00e 	moveq	pc, lr
30000814:	eaffffea 	b	300007c4 <get_howmany_para+0x4>

30000818 <str_to_hex>:
			return tmp;
	}
}

unsigned char * str_to_hex(unsigned char *s, uint * result)
{
30000818:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
	uint  i = 0;
3000081c:	e3a07000 	mov	r7, #0	; 0x0

	*result = 0;
30000820:	e5817000 	str	r7, [r1]
	while(*s == ' ')s++;
30000824:	e5d03000 	ldrb	r3, [r0]
30000828:	e3530020 	cmp	r3, #32	; 0x20
3000082c:	e1a06001 	mov	r6, r1
30000830:	e1a05000 	mov	r5, r0
30000834:	1a000002 	bne	30000844 <str_to_hex+0x2c>
30000838:	e5f53001 	ldrb	r3, [r5, #1]!
3000083c:	e3530020 	cmp	r3, #32	; 0x20
30000840:	0afffffc 	beq	30000838 <str_to_hex+0x20>
	for(i=0;i<8;i++){
30000844:	e3a07000 	mov	r7, #0	; 0x0
		if(*s == ' ' || *s == 0)
30000848:	e5d53000 	ldrb	r3, [r5]
3000084c:	e3530000 	cmp	r3, #0	; 0x0
30000850:	13530020 	cmpne	r3, #32	; 0x20
30000854:	e1a00003 	mov	r0, r3
30000858:	e2877001 	add	r7, r7, #1	; 0x1
3000085c:	0a000007 	beq	30000880 <str_to_hex+0x68>
			break;
		*result = *result*16 + asc_to_hex(*s++);
30000860:	ebffffc7 	bl	30000784 <asc_to_hex>
30000864:	e5964000 	ldr	r4, [r6]
30000868:	e1a04204 	mov	r4, r4, lsl #4
3000086c:	e0844000 	add	r4, r4, r0
30000870:	e3570007 	cmp	r7, #7	; 0x7
30000874:	e2855001 	add	r5, r5, #1	; 0x1
30000878:	e5864000 	str	r4, [r6]
3000087c:	9afffff1 	bls	30000848 <str_to_hex+0x30>
	}
	while(*s == ' ')s++;
30000880:	e5d53000 	ldrb	r3, [r5]
30000884:	e3530020 	cmp	r3, #32	; 0x20
30000888:	1a000002 	bne	30000898 <str_to_hex+0x80>
3000088c:	e5f53001 	ldrb	r3, [r5, #1]!
30000890:	e3530020 	cmp	r3, #32	; 0x20
30000894:	0afffffc 	beq	3000088c <str_to_hex+0x74>
	return s;
}
30000898:	e1a00005 	mov	r0, r5
3000089c:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}

300008a0 <print_mem>:

void print_mem(unsigned char *cp, uint length)
{
    uint i;

    while(length){
300008a0:	e3510000 	cmp	r1, #0	; 0x0
300008a4:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
300008a8:	e1a04001 	mov	r4, r1
300008ac:	e1a06000 	mov	r6, r0
300008b0:	08bd8070 	ldmeqia	sp!, {r4, r5, r6, pc}
	lprint("\r\n");
300008b4:	e59f0028 	ldr	r0, [pc, #40]	; 300008e4 <.text+0x8e4>
300008b8:	eb000331 	bl	30001584 <lprint>
	for(i=0;i<8;i++){
300008bc:	e3a05000 	mov	r5, #0	; 0x0
		lprint("%x\t", *cp++);
300008c0:	e4d61001 	ldrb	r1, [r6], #1
300008c4:	e59f001c 	ldr	r0, [pc, #28]	; 300008e8 <.text+0x8e8>
300008c8:	eb00032d 	bl	30001584 <lprint>
		length--;
		if(!length)
300008cc:	e2544001 	subs	r4, r4, #1	; 0x1
300008d0:	e2855001 	add	r5, r5, #1	; 0x1
300008d4:	08bd8070 	ldmeqia	sp!, {r4, r5, r6, pc}
300008d8:	e3550007 	cmp	r5, #7	; 0x7
300008dc:	9afffff7 	bls	300008c0 <print_mem+0x20>
300008e0:	eafffff3 	b	300008b4 <print_mem+0x14>
300008e4:	30003b58 	andcc	r3, r0, r8, asr fp
300008e8:	300035fc 	strccd	r3, [r0], -ip

300008ec <pm>:
			break;
	}
    }
}

void pm(unsigned char *p)
{
300008ec:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    uint length = 0x80, tmp, i;
300008f0:	e3a03080 	mov	r3, #128	; 0x80
300008f4:	e24dd004 	sub	sp, sp, #4	; 0x4
300008f8:	e58d3000 	str	r3, [sp]
300008fc:	e1a04000 	mov	r4, r0

    tmp = get_howmany_para(p);
30000900:	ebffffae 	bl	300007c0 <get_howmany_para>
30000904:	e1a03000 	mov	r3, r0
    if( tmp > 1)
30000908:	e3530001 	cmp	r3, #1	; 0x1
3000090c:	e59f504c 	ldr	r5, [pc, #76]	; 30000960 <.text+0x960>
30000910:	e59f004c 	ldr	r0, [pc, #76]	; 30000964 <.text+0x964>
30000914:	8a00000e 	bhi	30000954 <pm+0x68>
        goto error;
    if(tmp == 0)
30000918:	e3530000 	cmp	r3, #0	; 0x0
3000091c:	e1a00004 	mov	r0, r4
30000920:	e1a0100d 	mov	r1, sp
        goto print;
    str_to_hex(p, &length);
30000924:	1bffffbb 	blne	30000818 <str_to_hex>
print:
    lprint("Start print 0x%x mem content @%x:\r\n", length, (uint)mrw_addr);
30000928:	e5952000 	ldr	r2, [r5]
3000092c:	e59d1000 	ldr	r1, [sp]
30000930:	e59f0030 	ldr	r0, [pc, #48]	; 30000968 <.text+0x968>
30000934:	eb000312 	bl	30001584 <lprint>
    print_mem((unsigned char*)mrw_addr, length);
30000938:	e5950000 	ldr	r0, [r5]
3000093c:	e59d1000 	ldr	r1, [sp]
30000940:	ebffffd6 	bl	300008a0 <print_mem>
    lprint("\r\nPrint end @%x.\r\n", (uint)mrw_addr);
30000944:	e5951000 	ldr	r1, [r5]
30000948:	e59f001c 	ldr	r0, [pc, #28]	; 3000096c <.text+0x96c>
3000094c:	eb00030c 	bl	30001584 <lprint>
    return;
30000950:	ea000000 	b	30000958 <pm+0x6c>

error:
    lprint("Error para!\r\npm [length](default 0x80 if no this argu)\r\n");
30000954:	eb00030a 	bl	30001584 <lprint>

}
30000958:	e28dd004 	add	sp, sp, #4	; 0x4
3000095c:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30000960:	30003e34 	andcc	r3, r0, r4, lsr lr
30000964:	30003600 	andcc	r3, r0, r0, lsl #12
30000968:	3000363c 	andcc	r3, r0, ip, lsr r6
3000096c:	30003660 	andcc	r3, r0, r0, ror #12

30000970 <ndbb>:


void ndbb(unsigned char *p)
{
30000970:	e92d4010 	stmdb	sp!, {r4, lr}
30000974:	e24dd004 	sub	sp, sp, #4	; 0x4
30000978:	e1a04000 	mov	r4, r0
    uint addr, tmp;

    tmp = get_howmany_para(p);
3000097c:	ebffff8f 	bl	300007c0 <get_howmany_para>
30000980:	e1a03000 	mov	r3, r0
    if(tmp != 1)
30000984:	e3530001 	cmp	r3, #1	; 0x1
30000988:	e59f0040 	ldr	r0, [pc, #64]	; 300009d0 <.text+0x9d0>
3000098c:	e1a0100d 	mov	r1, sp
30000990:	1a00000b 	bne	300009c4 <ndbb+0x54>
        goto error;
    p = str_to_hex(p, &addr);
30000994:	e1a00004 	mov	r0, r4
30000998:	ebffff9e 	bl	30000818 <str_to_hex>
cp:
    lprint("block %x ", addr);
3000099c:	e59d1000 	ldr	r1, [sp]
300009a0:	e59f002c 	ldr	r0, [pc, #44]	; 300009d4 <.text+0x9d4>
300009a4:	eb0002f6 	bl	30001584 <lprint>
    nand_reset();
300009a8:	eb000327 	bl	3000164c <nand_reset>
    if(is_marked_bad_block(addr))
300009ac:	e59d0000 	ldr	r0, [sp]
300009b0:	eb0003f1 	bl	3000197c <is_marked_bad_block>
300009b4:	e1a03000 	mov	r3, r0
300009b8:	e3530000 	cmp	r3, #0	; 0x0
300009bc:	e59f0014 	ldr	r0, [pc, #20]	; 300009d8 <.text+0x9d8>
	lprint("is Marked bad.\r\n");
    else
    	lprint("is not marked bad!\r\n");
300009c0:	059f0014 	ldreq	r0, [pc, #20]	; 300009dc <.text+0x9dc>
    return;

error:
    lprint("Error para!\r\nnander (hex block addr)\r\n");
300009c4:	eb0002ee 	bl	30001584 <lprint>

}
300009c8:	e28dd004 	add	sp, sp, #4	; 0x4
300009cc:	e8bd8010 	ldmia	sp!, {r4, pc}
300009d0:	30003674 	andcc	r3, r0, r4, ror r6
300009d4:	3000369c 	mulcc	r0, ip, r6
300009d8:	300036a8 	andcc	r3, r0, r8, lsr #13
300009dc:	300036bc 	strcch	r3, [r0], -ip

300009e0 <nandspr>:

void nandspr(unsigned char *p)
{
300009e0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
300009e4:	e24dd004 	sub	sp, sp, #4	; 0x4
300009e8:	e1a04000 	mov	r4, r0
    uint addr, tmp;

    tmp = get_howmany_para(p);
300009ec:	ebffff73 	bl	300007c0 <get_howmany_para>
300009f0:	e1a05000 	mov	r5, r0
    if(tmp != 1)
300009f4:	e3550001 	cmp	r5, #1	; 0x1
300009f8:	e1a0100d 	mov	r1, sp
300009fc:	e1a00004 	mov	r0, r4
30000a00:	1a000009 	bne	30000a2c <nandspr+0x4c>
        goto error;
    p = str_to_hex(p, &addr);
30000a04:	ebffff83 	bl	30000818 <str_to_hex>
cp:
    nand_reset();
30000a08:	eb00030f 	bl	3000164c <nand_reset>
    lprint("%x at nand spare addr %x\r\n", random_read_nand(1, addr), addr);
30000a0c:	e59d1000 	ldr	r1, [sp]
30000a10:	e1a00005 	mov	r0, r5
30000a14:	eb0003ac 	bl	300018cc <random_read_nand>
30000a18:	e59d2000 	ldr	r2, [sp]
30000a1c:	e1a01000 	mov	r1, r0
30000a20:	e59f0014 	ldr	r0, [pc, #20]	; 30000a3c <.text+0xa3c>
30000a24:	eb0002d6 	bl	30001584 <lprint>
    return;
30000a28:	ea000001 	b	30000a34 <nandspr+0x54>

error:
    lprint("Error para!\r\nnandspr (hex addr) random read nand spare\r\n");
30000a2c:	e59f000c 	ldr	r0, [pc, #12]	; 30000a40 <.text+0xa40>
30000a30:	eb0002d3 	bl	30001584 <lprint>

}
30000a34:	e28dd004 	add	sp, sp, #4	; 0x4
30000a38:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30000a3c:	300036d4 	ldrccd	r3, [r0], -r4
30000a40:	300036f0 	strccd	r3, [r0], -r0

30000a44 <nandr>:

void nandr(unsigned char *p)
{
30000a44:	e92d4010 	stmdb	sp!, {r4, lr}
30000a48:	e24dd004 	sub	sp, sp, #4	; 0x4
30000a4c:	e1a04000 	mov	r4, r0
    uint addr, tmp;

    tmp = get_howmany_para(p);
30000a50:	ebffff5a 	bl	300007c0 <get_howmany_para>
30000a54:	e1a03000 	mov	r3, r0
    if(tmp != 1)
30000a58:	e3530001 	cmp	r3, #1	; 0x1
30000a5c:	e1a0100d 	mov	r1, sp
30000a60:	e1a00004 	mov	r0, r4
30000a64:	1a000009 	bne	30000a90 <nandr+0x4c>
        goto error;
    p = str_to_hex(p, &addr);
30000a68:	ebffff6a 	bl	30000818 <str_to_hex>
cp:
    nand_reset();
30000a6c:	eb0002f6 	bl	3000164c <nand_reset>
    lprint("%x at nand addr %x\r\n", random_read_nand(0, addr), addr);
30000a70:	e59d1000 	ldr	r1, [sp]
30000a74:	e3a00000 	mov	r0, #0	; 0x0
30000a78:	eb000393 	bl	300018cc <random_read_nand>
30000a7c:	e59d2000 	ldr	r2, [sp]
30000a80:	e1a01000 	mov	r1, r0
30000a84:	e59f0014 	ldr	r0, [pc, #20]	; 30000aa0 <.text+0xaa0>
30000a88:	eb0002bd 	bl	30001584 <lprint>
    return;
30000a8c:	ea000001 	b	30000a98 <nandr+0x54>

error:
    lprint("Error para!\r\nnandr (hex addr) random read nand\r\n");
30000a90:	e59f000c 	ldr	r0, [pc, #12]	; 30000aa4 <.text+0xaa4>
30000a94:	eb0002ba 	bl	30001584 <lprint>

}
30000a98:	e28dd004 	add	sp, sp, #4	; 0x4
30000a9c:	e8bd8010 	ldmia	sp!, {r4, pc}
30000aa0:	3000372c 	andcc	r3, r0, ip, lsr #14
30000aa4:	30003744 	andcc	r3, r0, r4, asr #14

30000aa8 <nandwb>:

void nandwb(unsigned char *p)
{
30000aa8:	e92d4010 	stmdb	sp!, {r4, lr}
30000aac:	e24dd008 	sub	sp, sp, #8	; 0x8
30000ab0:	e1a04000 	mov	r4, r0
    uint addr, tmp, c;

    tmp = get_howmany_para(p);
30000ab4:	ebffff41 	bl	300007c0 <get_howmany_para>
30000ab8:	e1a03000 	mov	r3, r0
    if(tmp != 2)
30000abc:	e3530002 	cmp	r3, #2	; 0x2
30000ac0:	e59f0044 	ldr	r0, [pc, #68]	; 30000b0c <.text+0xb0c>
30000ac4:	e28d1004 	add	r1, sp, #4	; 0x4
30000ac8:	1a00000c 	bne	30000b00 <nandwb+0x58>
        goto error;
    p = str_to_hex(p, &c);
30000acc:	e1a00004 	mov	r0, r4
30000ad0:	ebffff50 	bl	30000818 <str_to_hex>
    p = str_to_hex(p, &addr);
30000ad4:	e1a0100d 	mov	r1, sp
30000ad8:	ebffff4e 	bl	30000818 <str_to_hex>

    c &= 0xff;
30000adc:	e5dd3004 	ldrb	r3, [sp, #4]
30000ae0:	e58d3004 	str	r3, [sp, #4]
    if(random_write_nand((unsigned char)c, addr) == 0)
30000ae4:	e59d1000 	ldr	r1, [sp]
30000ae8:	e5dd0004 	ldrb	r0, [sp, #4]
30000aec:	eb00033b 	bl	300017e0 <random_write_nand>
30000af0:	e1a03000 	mov	r3, r0
30000af4:	e3530000 	cmp	r3, #0	; 0x0
30000af8:	e59f0010 	ldr	r0, [pc, #16]	; 30000b10 <.text+0xb10>
30000afc:	1a000000 	bne	30000b04 <nandwb+0x5c>
    	lprint("successfully\r\n");
    return;

error:
    lprint("Error para!\r\nnandwb (hex char)(hex addr) random write nand\r\n");
30000b00:	eb00029f 	bl	30001584 <lprint>

}
30000b04:	e28dd008 	add	sp, sp, #8	; 0x8
30000b08:	e8bd8010 	ldmia	sp!, {r4, pc}
30000b0c:	30003778 	andcc	r3, r0, r8, ror r7
30000b10:	300037b8 	strcch	r3, [r0], -r8

30000b14 <nander>:

void nander(unsigned char *p)
{
30000b14:	e92d4010 	stmdb	sp!, {r4, lr}
30000b18:	e24dd004 	sub	sp, sp, #4	; 0x4
30000b1c:	e1a04000 	mov	r4, r0
    uint addr, tmp;

    tmp = get_howmany_para(p);
30000b20:	ebffff26 	bl	300007c0 <get_howmany_para>
30000b24:	e1a03000 	mov	r3, r0
    if(tmp != 1)
30000b28:	e3530001 	cmp	r3, #1	; 0x1
30000b2c:	e59f0044 	ldr	r0, [pc, #68]	; 30000b78 <.text+0xb78>
30000b30:	e1a0100d 	mov	r1, sp
30000b34:	1a00000c 	bne	30000b6c <nander+0x58>
        goto error;
    p = str_to_hex(p, &addr);
30000b38:	e1a00004 	mov	r0, r4
30000b3c:	ebffff35 	bl	30000818 <str_to_hex>
cp:
    nand_reset();
30000b40:	eb0002c1 	bl	3000164c <nand_reset>
    if(nand_erase_ll(addr))
30000b44:	e59d0000 	ldr	r0, [sp]
30000b48:	eb0003a9 	bl	300019f4 <nand_erase_ll>
30000b4c:	e1a03000 	mov	r3, r0
30000b50:	e3530000 	cmp	r3, #0	; 0x0
30000b54:	e59f0020 	ldr	r0, [pc, #32]	; 30000b7c <.text+0xb7c>
30000b58:	1a000003 	bne	30000b6c <nander+0x58>
	lprint("erase error\r\n");
    else
    	lprint("erase nand block 0x%x done!\r\n",addr);
30000b5c:	e59f001c 	ldr	r0, [pc, #28]	; 30000b80 <.text+0xb80>
30000b60:	e59d1000 	ldr	r1, [sp]
30000b64:	eb000286 	bl	30001584 <lprint>
    return;
30000b68:	ea000000 	b	30000b70 <nander+0x5c>

error:
    lprint("Error para!\r\nnander (hex block addr)\r\n");
30000b6c:	eb000284 	bl	30001584 <lprint>

}
30000b70:	e28dd004 	add	sp, sp, #4	; 0x4
30000b74:	e8bd8010 	ldmia	sp!, {r4, pc}
30000b78:	30003674 	andcc	r3, r0, r4, ror r6
30000b7c:	300037c8 	andcc	r3, r0, r8, asr #15
30000b80:	300037d8 	ldrccd	r3, [r0], -r8

30000b84 <nandpp>:

void nandpp(unsigned char *p)
{
30000b84:	e92d4030 	stmdb	sp!, {r4, r5, lr}
30000b88:	e24dd008 	sub	sp, sp, #8	; 0x8
30000b8c:	e1a04000 	mov	r4, r0
    uint addr, pages, tmp;

    tmp = get_howmany_para(p);
30000b90:	ebffff0a 	bl	300007c0 <get_howmany_para>
30000b94:	e1a03000 	mov	r3, r0
    if(tmp != 2)
30000b98:	e3530002 	cmp	r3, #2	; 0x2
30000b9c:	e59f5070 	ldr	r5, [pc, #112]	; 30000c14 <.text+0xc14>
30000ba0:	e59f0070 	ldr	r0, [pc, #112]	; 30000c18 <.text+0xc18>
30000ba4:	e28d1004 	add	r1, sp, #4	; 0x4
30000ba8:	1a000016 	bne	30000c08 <nandpp+0x84>
        goto error;
    p = str_to_hex(p, &addr);
30000bac:	e1a00004 	mov	r0, r4
30000bb0:	ebffff18 	bl	30000818 <str_to_hex>
    str_to_hex(p, &pages);
30000bb4:	e1a0100d 	mov	r1, sp
30000bb8:	ebffff16 	bl	30000818 <str_to_hex>
    addr = addr & 0xfffffe00;
30000bbc:	e59d3004 	ldr	r3, [sp, #4]
30000bc0:	e3c33f7f 	bic	r3, r3, #508	; 0x1fc
30000bc4:	e3c33003 	bic	r3, r3, #3	; 0x3
30000bc8:	e58d3004 	str	r3, [sp, #4]

    nand_reset();
30000bcc:	eb00029e 	bl	3000164c <nand_reset>
    if(nand_write_ll(mrw_addr, addr, 512 * pages)){
30000bd0:	e59d2000 	ldr	r2, [sp]
30000bd4:	e5950000 	ldr	r0, [r5]
30000bd8:	e1a02482 	mov	r2, r2, lsl #9
30000bdc:	e59d1004 	ldr	r1, [sp, #4]
30000be0:	eb0003cd 	bl	30001b1c <nand_write_ll>
30000be4:	e1a03000 	mov	r3, r0
30000be8:	e3530000 	cmp	r3, #0	; 0x0
30000bec:	e59f0028 	ldr	r0, [pc, #40]	; 30000c1c <.text+0xc1c>
30000bf0:	1a000004 	bne	30000c08 <nandpp+0x84>
	lprint("failed\r\n");
	return;
    }
    lprint("program 0x%x pages from memory 0x%x to nand addr %x done!\r\n",pages,mrw_addr,addr);
30000bf4:	e5952000 	ldr	r2, [r5]
30000bf8:	e59f0020 	ldr	r0, [pc, #32]	; 30000c20 <.text+0xc20>
30000bfc:	e89d000a 	ldmia	sp, {r1, r3}
30000c00:	eb00025f 	bl	30001584 <lprint>
    return;
30000c04:	ea000000 	b	30000c0c <nandpp+0x88>

error:
    lprint("Error para!\r\nnandcp (hex addr) (hex pages)\r\n");
30000c08:	eb00025d 	bl	30001584 <lprint>

}
30000c0c:	e28dd008 	add	sp, sp, #8	; 0x8
30000c10:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30000c14:	30003e34 	andcc	r3, r0, r4, lsr lr
30000c18:	300037f8 	strccd	r3, [r0], -r8
30000c1c:	30003828 	andcc	r3, r0, r8, lsr #16
30000c20:	30003834 	andcc	r3, r0, r4, lsr r8

30000c24 <nandcp>:

void nandcp(unsigned char *p)
{
30000c24:	e92d4030 	stmdb	sp!, {r4, r5, lr}
30000c28:	e24dd008 	sub	sp, sp, #8	; 0x8
30000c2c:	e1a04000 	mov	r4, r0
    uint addr, pages, tmp;

    tmp = get_howmany_para(p);
30000c30:	ebfffee2 	bl	300007c0 <get_howmany_para>
30000c34:	e1a03000 	mov	r3, r0
    if(tmp != 2)
30000c38:	e3530002 	cmp	r3, #2	; 0x2
30000c3c:	e59f5060 	ldr	r5, [pc, #96]	; 30000ca4 <.text+0xca4>
30000c40:	e28d1004 	add	r1, sp, #4	; 0x4
30000c44:	e1a00004 	mov	r0, r4
30000c48:	1a000011 	bne	30000c94 <nandcp+0x70>
        goto error;
    p = str_to_hex(p, &addr);
30000c4c:	ebfffef1 	bl	30000818 <str_to_hex>
    str_to_hex(p, &pages);
30000c50:	e1a0100d 	mov	r1, sp
30000c54:	ebfffeef 	bl	30000818 <str_to_hex>
    addr = addr & 0xfffffe00;
30000c58:	e59d3004 	ldr	r3, [sp, #4]
30000c5c:	e3c33f7f 	bic	r3, r3, #508	; 0x1fc
30000c60:	e3c33003 	bic	r3, r3, #3	; 0x3
30000c64:	e58d3004 	str	r3, [sp, #4]
cp:
    nand_reset();
30000c68:	eb000277 	bl	3000164c <nand_reset>
    nand_read_ll(mrw_addr, addr, 512 * pages);
30000c6c:	e59d2000 	ldr	r2, [sp]
30000c70:	e59d1004 	ldr	r1, [sp, #4]
30000c74:	e5950000 	ldr	r0, [r5]
30000c78:	e1a02482 	mov	r2, r2, lsl #9
30000c7c:	eb00028b 	bl	300016b0 <nand_read_ll>
    lprint("cp 0x%x pages from nand addr %x to memory 0x%x done!\r\n",pages,addr,mrw_addr);
30000c80:	e5953000 	ldr	r3, [r5]
30000c84:	e89d0006 	ldmia	sp, {r1, r2}
30000c88:	e59f0018 	ldr	r0, [pc, #24]	; 30000ca8 <.text+0xca8>
30000c8c:	eb00023c 	bl	30001584 <lprint>
    return;
30000c90:	ea000001 	b	30000c9c <nandcp+0x78>

error:
    lprint("Error para!\r\nnandcp (hex addr) (hex pages)\r\n");
30000c94:	e59f0010 	ldr	r0, [pc, #16]	; 30000cac <.text+0xcac>
30000c98:	eb000239 	bl	30001584 <lprint>

}
30000c9c:	e28dd008 	add	sp, sp, #8	; 0x8
30000ca0:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30000ca4:	30003e34 	andcc	r3, r0, r4, lsr lr
30000ca8:	30003870 	andcc	r3, r0, r0, ror r8
30000cac:	300037f8 	strccd	r3, [r0], -r8

30000cb0 <write_mem>:

void write_mem(unsigned char *p)
{
30000cb0:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
30000cb4:	e24dd004 	sub	sp, sp, #4	; 0x4
30000cb8:	e1a06000 	mov	r6, r0
    uint value, tmp;

    tmp = get_howmany_para(p);
30000cbc:	ebfffebf 	bl	300007c0 <get_howmany_para>
30000cc0:	e1a05000 	mov	r5, r0
    if(tmp == 0 || tmp > 2)
30000cc4:	e2453001 	sub	r3, r5, #1	; 0x1
30000cc8:	e3530001 	cmp	r3, #1	; 0x1
30000ccc:	e59f005c 	ldr	r0, [pc, #92]	; 30000d30 <.text+0xd30>
30000cd0:	e1a0100d 	mov	r1, sp
30000cd4:	8a000012 	bhi	30000d24 <write_mem+0x74>
	goto error;
    p = str_to_hex(p, &value);
30000cd8:	e59f4054 	ldr	r4, [pc, #84]	; 30000d34 <.text+0xd34>
30000cdc:	e1a00006 	mov	r0, r6
30000ce0:	ebfffecc 	bl	30000818 <str_to_hex>
    if(tmp == 1)
30000ce4:	e3550001 	cmp	r5, #1	; 0x1
30000ce8:	e1a01004 	mov	r1, r4
30000cec:	0a000003 	beq	30000d00 <write_mem+0x50>
        goto write;
    str_to_hex(p, (uint*)&mrw_addr);
30000cf0:	ebfffec8 	bl	30000818 <str_to_hex>
    mrw_addr = (uint*)((uint)mrw_addr & 0xfffffffc);
30000cf4:	e5943000 	ldr	r3, [r4]
30000cf8:	e3c33003 	bic	r3, r3, #3	; 0x3
30000cfc:	e5843000 	str	r3, [r4]
write:
    *(uint*)mrw_addr = value;
30000d00:	e59f102c 	ldr	r1, [pc, #44]	; 30000d34 <.text+0xd34>
30000d04:	e59d3000 	ldr	r3, [sp]
30000d08:	e5912000 	ldr	r2, [r1]
30000d0c:	e5823000 	str	r3, [r2]
    lprint("Write 0x%x to memory 0x%x done!\r\n",value,mrw_addr);
30000d10:	e59f0020 	ldr	r0, [pc, #32]	; 30000d38 <.text+0xd38>
30000d14:	e5912000 	ldr	r2, [r1]
30000d18:	e59d1000 	ldr	r1, [sp]
30000d1c:	eb000218 	bl	30001584 <lprint>
    return;
30000d20:	ea000000 	b	30000d28 <write_mem+0x78>

error:
    lprint("Error para!\r\nw (hex value) [(hex addr)](last addr if no this argu)\r\n");
30000d24:	eb000216 	bl	30001584 <lprint>

}
30000d28:	e28dd004 	add	sp, sp, #4	; 0x4
30000d2c:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30000d30:	300038a8 	andcc	r3, r0, r8, lsr #17
30000d34:	30003e34 	andcc	r3, r0, r4, lsr lr
30000d38:	300038f0 	strccd	r3, [r0], -r0

30000d3c <read_mem>:


void read_mem(unsigned char *p)
{
30000d3c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
30000d40:	e1a05000 	mov	r5, r0
    uint value, tmp;

    tmp = get_howmany_para(p);
30000d44:	ebfffe9d 	bl	300007c0 <get_howmany_para>
30000d48:	e1a03000 	mov	r3, r0
    if( tmp > 1)
30000d4c:	e3530001 	cmp	r3, #1	; 0x1
30000d50:	e59f0044 	ldr	r0, [pc, #68]	; 30000d9c <.text+0xd9c>
30000d54:	8a00000e 	bhi	30000d94 <read_mem+0x58>
	goto error;
    if(tmp == 0)
30000d58:	e59f4040 	ldr	r4, [pc, #64]	; 30000da0 <.text+0xda0>
30000d5c:	e3530000 	cmp	r3, #0	; 0x0
30000d60:	e1a00005 	mov	r0, r5
30000d64:	e1a01004 	mov	r1, r4
30000d68:	0a000003 	beq	30000d7c <read_mem+0x40>
    	goto read;
    str_to_hex(p, (uint*)&mrw_addr);
30000d6c:	ebfffea9 	bl	30000818 <str_to_hex>
    mrw_addr = (uint*)((uint)mrw_addr & 0xfffffffc);
30000d70:	e5943000 	ldr	r3, [r4]
30000d74:	e3c33003 	bic	r3, r3, #3	; 0x3
30000d78:	e5843000 	str	r3, [r4]
read:
    value = *(uint*)mrw_addr;
30000d7c:	e59f301c 	ldr	r3, [pc, #28]	; 30000da0 <.text+0xda0>
30000d80:	e5932000 	ldr	r2, [r3]
    lprint("Read 0x%x at memory 0x%x\r\n",value,mrw_addr);
30000d84:	e59f0018 	ldr	r0, [pc, #24]	; 30000da4 <.text+0xda4>
30000d88:	e5921000 	ldr	r1, [r2]
30000d8c:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
30000d90:	ea0001fb 	b	30001584 <lprint>

    return;

error:
    lprint("Error para!\r\nr [(hex addr)](last addr if no this argu)\r\n");
30000d94:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
30000d98:	ea0001f9 	b	30001584 <lprint>
30000d9c:	30003914 	andcc	r3, r0, r4, lsl r9
30000da0:	30003e34 	andcc	r3, r0, r4, lsr lr
30000da4:	30003950 	andcc	r3, r0, r0, asr r9

30000da8 <lmemcpy>:

}


unsigned char* lmemcpy(unsigned char *d,unsigned char*s,uint n)
{
	unsigned char *p=d;
	while(n--)*d++=*s++;
30000da8:	e2422001 	sub	r2, r2, #1	; 0x1
30000dac:	e3720001 	cmn	r2, #1	; 0x1
30000db0:	e1a0c000 	mov	ip, r0
30000db4:	0a000004 	beq	30000dcc <lmemcpy+0x24>
30000db8:	e4d13001 	ldrb	r3, [r1], #1
30000dbc:	e2422001 	sub	r2, r2, #1	; 0x1
30000dc0:	e3720001 	cmn	r2, #1	; 0x1
30000dc4:	e4c03001 	strb	r3, [r0], #1
30000dc8:	1afffffa 	bne	30000db8 <lmemcpy+0x10>
	return p;
}
30000dcc:	e1a0000c 	mov	r0, ip
30000dd0:	e1a0f00e 	mov	pc, lr

30000dd4 <lmemset>:

void lmemset(unsigned char *d,unsigned char v,unsigned int n)
{
	while(n--)*d++=v;
30000dd4:	e2422001 	sub	r2, r2, #1	; 0x1
30000dd8:	e3720001 	cmn	r2, #1	; 0x1
30000ddc:	e20110ff 	and	r1, r1, #255	; 0xff
30000de0:	01a0f00e 	moveq	pc, lr
30000de4:	e2422001 	sub	r2, r2, #1	; 0x1
30000de8:	e3720001 	cmn	r2, #1	; 0x1
30000dec:	e4c01001 	strb	r1, [r0], #1
30000df0:	01a0f00e 	moveq	pc, lr
30000df4:	eafffffa 	b	30000de4 <lmemset+0x10>

30000df8 <handle_cmd>:
}

void handle_cmd()
{
30000df8:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    unsigned char i = 0, *p_cmd, *p_buf, *cmd_start;

    lprint("\r\n");
30000dfc:	e59f00c0 	ldr	r0, [pc, #192]	; 30000ec4 <.text+0xec4>
30000e00:	eb0001df 	bl	30001584 <lprint>
    cmd_start = cmd_buf;
30000e04:	e59fe0bc 	ldr	lr, [pc, #188]	; 30000ec8 <.text+0xec8>
    while(*cmd_start == ' ')
30000e08:	e5de3000 	ldrb	r3, [lr]
30000e0c:	e3530020 	cmp	r3, #32	; 0x20
30000e10:	e3a0c000 	mov	ip, #0	; 0x0
30000e14:	1a000002 	bne	30000e24 <handle_cmd+0x2c>
	cmd_start++;
30000e18:	e5fe3001 	ldrb	r3, [lr, #1]!
30000e1c:	e3530020 	cmp	r3, #32	; 0x20
30000e20:	0afffffc 	beq	30000e18 <handle_cmd+0x20>
    if(!*cmd_start)
30000e24:	e5de3000 	ldrb	r3, [lr]
30000e28:	e3530000 	cmp	r3, #0	; 0x0
30000e2c:	08bd8030 	ldmeqia	sp!, {r4, r5, pc}
	return;
    while(1){
	    if(cmd_list[i].cmd_name == NULL)
30000e30:	e59f5094 	ldr	r5, [pc, #148]	; 30000ecc <.text+0xecc>
30000e34:	e1a0408c 	mov	r4, ip, lsl #1
30000e38:	e084300c 	add	r3, r4, ip
30000e3c:	e7953103 	ldr	r3, [r5, r3, lsl #2]
30000e40:	e3530000 	cmp	r3, #0	; 0x0
30000e44:	0a000015 	beq	30000ea0 <handle_cmd+0xa8>
		    break;
	    p_cmd=cmd_list[i].cmd_name;
	    p_buf=cmd_start;
	    while(*p_cmd){
30000e48:	e5d32000 	ldrb	r2, [r3]
30000e4c:	e3520000 	cmp	r2, #0	; 0x0
30000e50:	e1a01003 	mov	r1, r3
30000e54:	e1a0000e 	mov	r0, lr
30000e58:	0a000009 	beq	30000e84 <handle_cmd+0x8c>
		    if(*p_buf != *p_cmd)
30000e5c:	e5d03000 	ldrb	r3, [r0]
30000e60:	e1530002 	cmp	r3, r2
30000e64:	1a000003 	bne	30000e78 <handle_cmd+0x80>
			    break;
		    p_buf++;
		    p_cmd++;
30000e68:	e5f12001 	ldrb	r2, [r1, #1]!
30000e6c:	e3520000 	cmp	r2, #0	; 0x0
30000e70:	e2800001 	add	r0, r0, #1	; 0x1
30000e74:	1afffff8 	bne	30000e5c <handle_cmd+0x64>
	    }
	    if(!(*p_cmd) && (*p_buf == ' ' || !(*p_buf))){
30000e78:	e5d13000 	ldrb	r3, [r1]
30000e7c:	e3530000 	cmp	r3, #0	; 0x0
30000e80:	1a000003 	bne	30000e94 <handle_cmd+0x9c>
30000e84:	e5d03000 	ldrb	r3, [r0]
30000e88:	e3530000 	cmp	r3, #0	; 0x0
30000e8c:	13530020 	cmpne	r3, #32	; 0x20
30000e90:	0a000006 	beq	30000eb0 <handle_cmd+0xb8>
            	    cmd_list[i].cmd_fun(p_buf);
            	    return;
       	    }
	    i++;
30000e94:	e28c3001 	add	r3, ip, #1	; 0x1
30000e98:	e203c0ff 	and	ip, r3, #255	; 0xff
30000e9c:	eaffffe3 	b	30000e30 <handle_cmd+0x38>
    }
    lprint("Unknow command:%s\r\n",cmd_buf);
30000ea0:	e59f0028 	ldr	r0, [pc, #40]	; 30000ed0 <.text+0xed0>
30000ea4:	e59f101c 	ldr	r1, [pc, #28]	; 30000ec8 <.text+0xec8>
30000ea8:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
30000eac:	ea0001b4 	b	30001584 <lprint>
30000eb0:	e084300c 	add	r3, r4, ip
30000eb4:	e0853103 	add	r3, r5, r3, lsl #2
30000eb8:	e1a0e00f 	mov	lr, pc
30000ebc:	e593f004 	ldr	pc, [r3, #4]
}
30000ec0:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30000ec4:	30003b58 	andcc	r3, r0, r8, asr fp
30000ec8:	30003e38 	andcc	r3, r0, r8, lsr lr
30000ecc:	30002d50 	andcc	r2, r0, r0, asr sp
30000ed0:	3000396c 	andcc	r3, r0, ip, ror #18

30000ed4 <get_cmd>:

static void get_cmd()
{
30000ed4:	e52de004 	str	lr, [sp, #-4]!
	unsigned char c;
start_get_cmd:
	lprint("\r\nCleanBoot@%s>", PLATFORM);
30000ed8:	e59f00a8 	ldr	r0, [pc, #168]	; 30000f88 <.text+0xf88>
30000edc:	e59f10a8 	ldr	r1, [pc, #168]	; 30000f8c <.text+0xf8c>
30000ee0:	eb0001a7 	bl	30001584 <lprint>
	lmemset(cmd_buf, 0, COM_MAX_LEN);
30000ee4:	e3a02020 	mov	r2, #32	; 0x20
30000ee8:	e59f00a0 	ldr	r0, [pc, #160]	; 30000f90 <.text+0xf90>
30000eec:	e3a01000 	mov	r1, #0	; 0x0
30000ef0:	ebffffb7 	bl	30000dd4 <lmemset>
	cmd_buf_p = 0;
30000ef4:	e59f3098 	ldr	r3, [pc, #152]	; 30000f94 <.text+0xf94>
30000ef8:	e3a02000 	mov	r2, #0	; 0x0
30000efc:	e5832000 	str	r2, [r3]
	while(1){
		c = con_recv();
30000f00:	eb000378 	bl	30001ce8 <s3c2440_serial_recv_byte>
30000f04:	e20010ff 	and	r1, r0, #255	; 0xff
/*
		if(c == ENTER_CHAR){
			return;
		}else if(c == 0x1b){
			goto start_get_cmd;
		}else{
			if(cmd_buf_p < (COM_MAX_LEN - 1)){
				cmd_buf[cmd_buf_p++] = c;
				con_send(c);
			}
		}
*/

		switch(c){
30000f08:	e351000d 	cmp	r1, #13	; 0xd
30000f0c:	049df004 	ldreq	pc, [sp], #4
30000f10:	ca000003 	bgt	30000f24 <get_cmd+0x50>
30000f14:	e3510008 	cmp	r1, #8	; 0x8
30000f18:	e59fc074 	ldr	ip, [pc, #116]	; 30000f94 <.text+0xf94>
30000f1c:	0a000003 	beq	30000f30 <get_cmd+0x5c>
30000f20:	ea00000d 	b	30000f5c <get_cmd+0x88>
30000f24:	e351001b 	cmp	r1, #27	; 0x1b
30000f28:	0affffea 	beq	30000ed8 <get_cmd+0x4>
30000f2c:	ea00000a 	b	30000f5c <get_cmd+0x88>
			case ENTER_CHAR:
				return;
			case 0x1b:
				goto start_get_cmd;
			case 0x08:
				if(cmd_buf_p > 0){
30000f30:	e59c3000 	ldr	r3, [ip]
30000f34:	e3530000 	cmp	r3, #0	; 0x0
30000f38:	e59f0058 	ldr	r0, [pc, #88]	; 30000f98 <.text+0xf98>
30000f3c:	e2431001 	sub	r1, r3, #1	; 0x1
30000f40:	0affffee 	beq	30000f00 <get_cmd+0x2c>
					cmd_buf[--cmd_buf_p] = 0;
30000f44:	e59f3044 	ldr	r3, [pc, #68]	; 30000f90 <.text+0xf90>
30000f48:	e3a02000 	mov	r2, #0	; 0x0
30000f4c:	e7c32001 	strb	r2, [r3, r1]
30000f50:	e58c1000 	str	r1, [ip]
					print_string("\b \b");
30000f54:	eb00011c 	bl	300013cc <print_string>
				}
				continue;
30000f58:	eaffffe8 	b	30000f00 <get_cmd+0x2c>
			default:
				if(cmd_buf_p < (COM_MAX_LEN - 1)){
30000f5c:	e59fc030 	ldr	ip, [pc, #48]	; 30000f94 <.text+0xf94>
30000f60:	e59c2000 	ldr	r2, [ip]
30000f64:	e352001e 	cmp	r2, #30	; 0x1e
30000f68:	e1a00001 	mov	r0, r1
30000f6c:	e2823001 	add	r3, r2, #1	; 0x1
30000f70:	8affffe2 	bhi	30000f00 <get_cmd+0x2c>
					cmd_buf[cmd_buf_p++] = c;
30000f74:	e58c3000 	str	r3, [ip]
30000f78:	e59f3010 	ldr	r3, [pc, #16]	; 30000f90 <.text+0xf90>
30000f7c:	e7c21003 	strb	r1, [r2, r3]
					con_send(c);
30000f80:	eb00034e 	bl	30001cc0 <s3c2440_serial_send_byte>
30000f84:	eaffffdd 	b	30000f00 <get_cmd+0x2c>
30000f88:	30003980 	andcc	r3, r0, r0, lsl #19
30000f8c:	30003990 	mulcc	r0, r0, r9
30000f90:	30003e38 	andcc	r3, r0, r8, lsr lr
30000f94:	30003e30 	andcc	r3, r0, r0, lsr lr
30000f98:	30003998 	mulcc	r0, r8, r9

30000f9c <run_clean_boot>:
				}
		}

	}
}	

void run_clean_boot()
{
	mrw_addr = 0;
30000f9c:	e59fc040 	ldr	ip, [pc, #64]	; 30000fe4 <.text+0xfe4>
30000fa0:	e92d4010 	stmdb	sp!, {r4, lr}
	lprint("\r\n\r\nHello, this is clean_boot v%sbuild on %s %s.\r\n", CLEAN_BOOT_VERSION,__DATE__,__TIME__);
30000fa4:	e59f303c 	ldr	r3, [pc, #60]	; 30000fe8 <.text+0xfe8>
30000fa8:	e3a04000 	mov	r4, #0	; 0x0
30000fac:	e59f0038 	ldr	r0, [pc, #56]	; 30000fec <.text+0xfec>
30000fb0:	e59f1038 	ldr	r1, [pc, #56]	; 30000ff0 <.text+0xff0>
30000fb4:	e59f2038 	ldr	r2, [pc, #56]	; 30000ff4 <.text+0xff4>
30000fb8:	e58c4000 	str	r4, [ip]
30000fbc:	eb000170 	bl	30001584 <lprint>
	lmemset(cmd_buf, 0, COM_MAX_LEN);
30000fc0:	e59f0030 	ldr	r0, [pc, #48]	; 30000ff8 <.text+0xff8>
30000fc4:	e1a01004 	mov	r1, r4
30000fc8:	e3a02020 	mov	r2, #32	; 0x20
30000fcc:	ebffff80 	bl	30000dd4 <lmemset>
	cmd_buf_p = 0;
30000fd0:	e59f3024 	ldr	r3, [pc, #36]	; 30000ffc <.text+0xffc>
30000fd4:	e5834000 	str	r4, [r3]
	while(1){
		get_cmd();
30000fd8:	ebffffbd 	bl	30000ed4 <get_cmd>
		handle_cmd();
30000fdc:	ebffff85 	bl	30000df8 <handle_cmd>
30000fe0:	eafffffc 	b	30000fd8 <run_clean_boot+0x3c>
30000fe4:	30003e34 	andcc	r3, r0, r4, lsr lr
30000fe8:	3000399c 	mulcc	r0, ip, r9
30000fec:	300039a8 	andcc	r3, r0, r8, lsr #19
30000ff0:	30003488 	andcc	r3, r0, r8, lsl #9
30000ff4:	300039dc 	ldrccd	r3, [r0], -ip
30000ff8:	30003e38 	andcc	r3, r0, r8, lsr lr
30000ffc:	30003e30 	andcc	r3, r0, r0, lsr lr

30001000 <cs8900_halt>:
}

uint cs8900_halt()
{
	mem_w(LineCTL, 0); 
30001000:	e59f3008 	ldr	r3, [pc, #8]	; 30001010 <.text+0x1010>
30001004:	e3a02000 	mov	r2, #0	; 0x0
30001008:	e1c320b0 	strh	r2, [r3]
}
3000100c:	e1a0f00e 	mov	pc, lr
30001010:	18000112 	stmneda	r0, {r1, r4, r8}

30001014 <cs8900_open>:
uint cs8900_open()
{
	/*start rx and tx*/
	mem_w(LineCTL, (1<<LineCTL_SetTxON)|(1<<LineCTL_SetRxON)); 
30001014:	e59f3008 	ldr	r3, [pc, #8]	; 30001024 <.text+0x1024>
30001018:	e3a020c0 	mov	r2, #192	; 0xc0
3000101c:	e1c320b0 	strh	r2, [r3]
}
30001020:	e1a0f00e 	mov	pc, lr
30001024:	18000112 	stmneda	r0, {r1, r4, r8}

30001028 <cs8900_proble>:

uint cs8900_proble()
{
30001028:	e52de004 	str	lr, [sp, #-4]!
3000102c:	e59f3030 	ldr	r3, [pc, #48]	; 30001064 <.text+0x1064>
30001030:	e3a02000 	mov	r2, #0	; 0x0
30001034:	e1c320b0 	strh	r2, [r3]
30001038:	e59f3028 	ldr	r3, [pc, #40]	; 30001068 <.text+0x1068>
3000103c:	e1d320b0 	ldrh	r2, [r3]
30001040:	e59f3024 	ldr	r3, [pc, #36]	; 3000106c <.text+0x106c>
30001044:	e1520003 	cmp	r2, r3
30001048:	e59f0020 	ldr	r0, [pc, #32]	; 30001070 <.text+0x1070>
3000104c:	e3a03000 	mov	r3, #0	; 0x0
30001050:	1a000001 	bne	3000105c <cs8900_proble+0x34>
	if(io_r(PRDID) != CS8900_PRDID)
		return 0;
	lprint("Found cs8900!\r\n");
30001054:	eb00014a 	bl	30001584 <lprint>
	return 1;
30001058:	e3a03001 	mov	r3, #1	; 0x1
}
3000105c:	e1a00003 	mov	r0, r3
30001060:	e49df004 	ldr	pc, [sp], #4
30001064:	1900030a 	stmnedb	r0, {r1, r3, r8, r9}
30001068:	1900030c 	stmnedb	r0, {r2, r3, r8, r9}
3000106c:	0000630e 	andeq	r6, r0, lr, lsl #6
30001070:	300039e8 	andcc	r3, r0, r8, ror #19

30001074 <cs8900_reset>:
uint cs8900_reset()
{
30001074:	e92d4030 	stmdb	sp!, {r4, r5, lr}
30001078:	e59f4048 	ldr	r4, [pc, #72]	; 300010c8 <.text+0x10c8>
3000107c:	e3a02f45 	mov	r2, #276	; 0x114
30001080:	e1c420b0 	strh	r2, [r4]
30001084:	e59f5040 	ldr	r5, [pc, #64]	; 300010cc <.text+0x10cc>
30001088:	e1d530b0 	ldrh	r3, [r5]
3000108c:	e3833040 	orr	r3, r3, #64	; 0x40
30001090:	e1c420b0 	strh	r2, [r4]
	io_w(SelfCTL, io_r(SelfCTL)|(1<<SelfCTL_Reset));

	/*need up 10ms*/
	delay_us(100000);
30001094:	e59f0034 	ldr	r0, [pc, #52]	; 300010d0 <.text+0x10d0>
30001098:	e1c530b0 	strh	r3, [r5]
3000109c:	eb00000e 	bl	300010dc <delay_us>
300010a0:	e59f302c 	ldr	r3, [pc, #44]	; 300010d4 <.text+0x10d4>
300010a4:	e1c430b0 	strh	r3, [r4]
300010a8:	e1d530b0 	ldrh	r3, [r5]
300010ac:	e3933080 	orrs	r3, r3, #128	; 0x80
300010b0:	e59f0020 	ldr	r0, [pc, #32]	; 300010d8 <.text+0x10d8>
300010b4:	0a000001 	beq	300010c0 <cs8900_reset+0x4c>
	if(!(io_r(SelfST)|(1<<SelfST_InitD)))
		return 0;
	lprint("reset cs8900 sucess\r\n");
300010b8:	eb000131 	bl	30001584 <lprint>
	return 1;
300010bc:	e3a03001 	mov	r3, #1	; 0x1
}
300010c0:	e1a00003 	mov	r0, r3
300010c4:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
300010c8:	1900030a 	stmnedb	r0, {r1, r3, r8, r9}
300010cc:	1900030c 	stmnedb	r0, {r2, r3, r8, r9}
300010d0:	000186a0 	andeq	r8, r1, r0, lsr #13
300010d4:	00000136 	andeq	r0, r0, r6, lsr r1
300010d8:	300039f8 	strccd	r3, [r0], -r8

300010dc <delay_us>:
void delay_us(uint d)
{
	while(d--){
300010dc:	e2400001 	sub	r0, r0, #1	; 0x1
300010e0:	e3700001 	cmn	r0, #1	; 0x1
300010e4:	01a0f00e 	moveq	pc, lr
		__asm__ __volatile__("nop\n\rnop\n\tnop\n\t");
300010e8:	e1a00000 	nop			(mov r0,r0)
300010ec:	e1a00000 	nop			(mov r0,r0)
300010f0:	e1a00000 	nop			(mov r0,r0)
300010f4:	e2400001 	sub	r0, r0, #1	; 0x1
300010f8:	e3700001 	cmn	r0, #1	; 0x1
300010fc:	01a0f00e 	moveq	pc, lr
30001100:	eafffff8 	b	300010e8 <delay_us+0xc>

30001104 <cs8900_swi_mem>:
	}
}
uint cs8900_swi_mem()
{
30001104:	e52de004 	str	lr, [sp, #-4]!
30001108:	e59f305c 	ldr	r3, [pc, #92]	; 3000116c <.text+0x116c>
3000110c:	e59f105c 	ldr	r1, [pc, #92]	; 30001170 <.text+0x1170>
30001110:	e59f205c 	ldr	r2, [pc, #92]	; 30001174 <.text+0x1174>
30001114:	e1c130b0 	strh	r3, [r1]
30001118:	e1d230b0 	ldrh	r3, [r2]
3000111c:	e3933b02 	orrs	r3, r3, #2048	; 0x800
30001120:	e59fe050 	ldr	lr, [pc, #80]	; 30001178 <.text+0x1178>
30001124:	e1a0c003 	mov	ip, r3
30001128:	0a00000d 	beq	30001164 <cs8900_swi_mem+0x60>
3000112c:	e1c1e0b0 	strh	lr, [r1]
30001130:	e1d230b0 	ldrh	r3, [r2]
30001134:	e3833c06 	orr	r3, r3, #1536	; 0x600
30001138:	e1c1e0b0 	strh	lr, [r1]
3000113c:	e1c230b0 	strh	r3, [r2]
	if((io_r(SelfST)|(1<<SelfST_ELpres)) == 0)
		return 0;
	/*left memory base addr default zero*/
	io_w(BusCTL, io_r(BusCTL)|(1<<BusCTL_MemE)|(1<<BusCTL_UseSA));
	if(mem_r(PRDID) != CS8900_PRDID)
30001140:	e3a03306 	mov	r3, #402653184	; 0x18000000
30001144:	e1d320b0 	ldrh	r2, [r3]
30001148:	e59f302c 	ldr	r3, [pc, #44]	; 3000117c <.text+0x117c>
3000114c:	e1520003 	cmp	r2, r3
30001150:	e3a0c000 	mov	ip, #0	; 0x0
30001154:	e59f0024 	ldr	r0, [pc, #36]	; 30001180 <.text+0x1180>
30001158:	1a000001 	bne	30001164 <cs8900_swi_mem+0x60>
		return 0;
	lprint("switch to mem mode.\r\n");
3000115c:	eb000108 	bl	30001584 <lprint>
	return 1;
30001160:	e3a0c001 	mov	ip, #1	; 0x1
}
30001164:	e1a0000c 	mov	r0, ip
30001168:	e49df004 	ldr	pc, [sp], #4
3000116c:	00000136 	andeq	r0, r0, r6, lsr r1
30001170:	1900030a 	stmnedb	r0, {r1, r3, r8, r9}
30001174:	1900030c 	stmnedb	r0, {r2, r3, r8, r9}
30001178:	00000116 	andeq	r0, r0, r6, lsl r1
3000117c:	0000630e 	andeq	r6, r0, lr, lsl #6
30001180:	30003a10 	andcc	r3, r0, r0, lsl sl

30001184 <cs8900_setmac>:
void cs8900_setmac(const unsigned char *mac)
{
30001184:	e1a01000 	mov	r1, r0
	unsigned char *ia_p = (unsigned char *)MEM_ADDR(IA);

	lmemcpy(ia_p, mac, 6);
30001188:	e59f0004 	ldr	r0, [pc, #4]	; 30001194 <.text+0x1194>
3000118c:	e3a02006 	mov	r2, #6	; 0x6
30001190:	eaffff04 	b	30000da8 <lmemcpy>
30001194:	18000158 	stmneda	r0, {r3, r4, r6, r8}

30001198 <cs8900_init_reg>:
}
void cs8900_init_reg()
{
	/*receive boardcast & individual & crc ok packages*/
	mem_w(RxCTL, (1<<RxCTL_BoardCastA)|(1<<RxCTL_IndividualA)|(1<<RxCTL_RxOKA));
30001198:	e59f3024 	ldr	r3, [pc, #36]	; 300011c4 <.text+0x11c4>
3000119c:	e3a01c0d 	mov	r1, #3328	; 0xd00
300011a0:	e1c310b0 	strh	r1, [r3]
	/*no interrupt*/
	mem_w(RxCFG, 0);
300011a4:	e59f301c 	ldr	r3, [pc, #28]	; 300011c8 <.text+0x11c8>
300011a8:	e3a02000 	mov	r2, #0	; 0x0
300011ac:	e1c320b0 	strh	r2, [r3]
	mem_w(TxCFG, 0);
300011b0:	e59f3014 	ldr	r3, [pc, #20]	; 300011cc <.text+0x11cc>
300011b4:	e1c320b0 	strh	r2, [r3]
	mem_w(BufCFG, 0);
300011b8:	e59f3010 	ldr	r3, [pc, #16]	; 300011d0 <.text+0x11d0>
300011bc:	e1c320b0 	strh	r2, [r3]
300011c0:	e1a0f00e 	mov	pc, lr
300011c4:	18000104 	stmneda	r0, {r2, r8}
300011c8:	18000102 	stmneda	r0, {r1, r8}
300011cc:	18000106 	stmneda	r0, {r1, r2, r8}
300011d0:	1800010a 	stmneda	r0, {r1, r3, r8}

300011d4 <cs8900_init>:
}
uint cs8900_init(unsigned char * mac)
{
300011d4:	e92d4030 	stmdb	sp!, {r4, r5, lr}
300011d8:	e1a04000 	mov	r4, r0
	lprint("\r\nloading cs8900 driver...");
300011dc:	e59f0060 	ldr	r0, [pc, #96]	; 30001244 <.text+0x1244>
300011e0:	eb0000e7 	bl	30001584 <lprint>
	if(!cs8900_proble())
300011e4:	ebffff8f 	bl	30001028 <cs8900_proble>
300011e8:	e3500000 	cmp	r0, #0	; 0x0
300011ec:	0a000010 	beq	30001234 <cs8900_init+0x60>
		goto error;
	if(!cs8900_reset())
300011f0:	ebffff9f 	bl	30001074 <cs8900_reset>
300011f4:	e3500000 	cmp	r0, #0	; 0x0
300011f8:	0a00000d 	beq	30001234 <cs8900_init+0x60>
		goto error;
	if(!cs8900_swi_mem())
300011fc:	ebffffc0 	bl	30001104 <cs8900_swi_mem>
30001200:	e3a05000 	mov	r5, #0	; 0x0
30001204:	e1a03000 	mov	r3, r0
30001208:	e1530005 	cmp	r3, r5
3000120c:	e1a00004 	mov	r0, r4
30001210:	0a000007 	beq	30001234 <cs8900_init+0x60>
		goto error;
	cs8900_setmac(mac);
30001214:	ebffffda 	bl	30001184 <cs8900_setmac>
	cs8900_init_reg();
30001218:	ebffffde 	bl	30001198 <cs8900_init_reg>
	cs8900_not_ready = 0;
3000121c:	e59f3024 	ldr	r3, [pc, #36]	; 30001248 <.text+0x1248>
	lprint("cs8900 is ready.");
30001220:	e59f0024 	ldr	r0, [pc, #36]	; 3000124c <.text+0x124c>
30001224:	e5835000 	str	r5, [r3]
30001228:	eb0000d5 	bl	30001584 <lprint>
	return 0;
3000122c:	e1a00005 	mov	r0, r5
error:
	lprint("error, cs8900 not in use!\r\n");
	return -1;
}
30001230:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30001234:	e59f0014 	ldr	r0, [pc, #20]	; 30001250 <.text+0x1250>
30001238:	eb0000d1 	bl	30001584 <lprint>
3000123c:	e3e00000 	mvn	r0, #0	; 0x0
30001240:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30001244:	30003a28 	andcc	r3, r0, r8, lsr #20
30001248:	30003e20 	andcc	r3, r0, r0, lsr #28
3000124c:	30003a44 	andcc	r3, r0, r4, asr #20
30001250:	30003a58 	andcc	r3, r0, r8, asr sl

30001254 <cs8900_is_ready>:

uint cs8900_is_ready()
{
	return !cs8900_not_ready;
30001254:	e59f3010 	ldr	r3, [pc, #16]	; 3000126c <.text+0x126c>
30001258:	e5930000 	ldr	r0, [r3]
3000125c:	e3500000 	cmp	r0, #0	; 0x0
30001260:	13a00000 	movne	r0, #0	; 0x0
30001264:	03a00001 	moveq	r0, #1	; 0x1
}
30001268:	e1a0f00e 	mov	pc, lr
3000126c:	30003e20 	andcc	r3, r0, r0, lsr #28

30001270 <cs8900_recv>:

uint cs8900_recv(unsigned short *buf)
{
	uint i, rxlen;
	unsigned short status;

	status = mem_r(RxEvt);
30001270:	e59f3054 	ldr	r3, [pc, #84]	; 300012cc <.text+0x12cc>
30001274:	e1d330b0 	ldrh	r3, [r3]

	if ((status & (1<<RxEvt_RxOK)) == 0)
30001278:	e2133c01 	ands	r3, r3, #256	; 0x100
3000127c:	01a00003 	moveq	r0, r3
		return 0;

	status = rio(RTDATA);		/* stat */
	rxlen = rio(RTDATA);		/* len */

	for (i = rxlen >> 1; i > 0; i--)
		*buf++ = rio(RTDATA);
	if (rxlen & 1)
		*buf++ = rio(RTDATA);

	return rxlen;
}
30001280:	01a0f00e 	moveq	pc, lr
30001284:	e59f3044 	ldr	r3, [pc, #68]	; 300012d0 <.text+0x12d0>
30001288:	e1d320b0 	ldrh	r2, [r3]
3000128c:	e1d330b0 	ldrh	r3, [r3]
30001290:	e1a03803 	mov	r3, r3, lsl #16
30001294:	e1b028a3 	movs	r2, r3, lsr #17
30001298:	e1a01823 	mov	r1, r3, lsr #16
3000129c:	0a000004 	beq	300012b4 <cs8900_recv+0x44>
300012a0:	e59f3028 	ldr	r3, [pc, #40]	; 300012d0 <.text+0x12d0>
300012a4:	e1d330b0 	ldrh	r3, [r3]
300012a8:	e2522001 	subs	r2, r2, #1	; 0x1
300012ac:	e0c030b2 	strh	r3, [r0], #2
300012b0:	1afffffa 	bne	300012a0 <cs8900_recv+0x30>
300012b4:	e3110001 	tst	r1, #1	; 0x1
300012b8:	159f3010 	ldrne	r3, [pc, #16]	; 300012d0 <.text+0x12d0>
300012bc:	11d330b0 	ldrneh	r3, [r3]
300012c0:	11c030b0 	strneh	r3, [r0]
300012c4:	e1a00001 	mov	r0, r1
300012c8:	e1a0f00e 	mov	pc, lr
300012cc:	18000124 	stmneda	r0, {r2, r5, r8}
300012d0:	19000300 	stmnedb	r0, {r8, r9}

300012d4 <cs8900_send>:

uint cs8900_send (unsigned short *buf, uint length)
{
	uint i, delay = 0x10000;
	unsigned short s;
retry:
	/* initiate a transmit sequence */
	wio(TxCmd, TxCmd_TxStart_Full);
300012d4:	e59f3070 	ldr	r3, [pc, #112]	; 3000134c <.text+0x134c>
300012d8:	e52de004 	str	lr, [sp, #-4]!
300012dc:	e3a020c0 	mov	r2, #192	; 0xc0
300012e0:	e1c320b0 	strh	r2, [r3]
	wio(TxLen, length);
300012e4:	e59f3064 	ldr	r3, [pc, #100]	; 30001350 <.text+0x1350>
300012e8:	e1c310b0 	strh	r1, [r3]

	/* Test to see if the chip has allocated memory for the packet */
	if (mem_r(BusST) & (1<<BusST_TxRDY) == 0) 
300012ec:	e59f3060 	ldr	r3, [pc, #96]	; 30001354 <.text+0x1354>
		return 0;	

	/* Write the contents of the packet */
	/* assume even number of bytes */
	for (i = length>>1; i > 0; i--)
300012f0:	e1b0c0a1 	movs	ip, r1, lsr #1
300012f4:	e1d330b0 	ldrh	r3, [r3]
300012f8:	e3a0e801 	mov	lr, #65536	; 0x10000
300012fc:	0a000004 	beq	30001314 <cs8900_send+0x40>
		wio(RTDATA, *buf++);
30001300:	e0d020b2 	ldrh	r2, [r0], #2
30001304:	e59f304c 	ldr	r3, [pc, #76]	; 30001358 <.text+0x1358>
30001308:	e25cc001 	subs	ip, ip, #1	; 0x1
3000130c:	e1c320b0 	strh	r2, [r3]
30001310:	1afffffa 	bne	30001300 <cs8900_send+0x2c>
	if(length&1)
30001314:	e3110001 	tst	r1, #1	; 0x1
		wio(RTDATA, *buf++);
30001318:	11d020b0 	ldrneh	r2, [r0]
3000131c:	159f3034 	ldrne	r3, [pc, #52]	; 30001358 <.text+0x1358>
30001320:	11c320b0 	strneh	r2, [r3]
	/* wait for transfer to succeed */
	while(delay--);
30001324:	e24ee001 	sub	lr, lr, #1	; 0x1
30001328:	e37e0001 	cmn	lr, #1	; 0x1
3000132c:	1afffffc 	bne	30001324 <cs8900_send+0x50>
	delay == 0xe0000;
	while((s=mem_r(TxEvt)) & ~0x1F == 0) {
		if (!delay--)
			break;
30001330:	e59f3024 	ldr	r3, [pc, #36]	; 3000135c <.text+0x135c>
30001334:	e1d300b0 	ldrh	r0, [r3]
	}

	/* nothing */ ;
	if ((s & (1<<TxEvt_CRS | 1<<TxEvt_TxOK)) != 1<<TxEvt_TxOK) 
30001338:	e2000d05 	and	r0, r0, #320	; 0x140
3000133c:	e3500c01 	cmp	r0, #256	; 0x100
30001340:	01a00001 	moveq	r0, r1
30001344:	13a00000 	movne	r0, #0	; 0x0
		return 0;
	return length;
}
30001348:	e49df004 	ldr	pc, [sp], #4
3000134c:	19000304 	stmnedb	r0, {r2, r8, r9}
30001350:	19000306 	stmnedb	r0, {r1, r2, r8, r9}
30001354:	18000138 	stmneda	r0, {r3, r4, r5, r8}
30001358:	19000300 	stmnedb	r0, {r8, r9}
3000135c:	18000128 	stmneda	r0, {r3, r5, r8}

30001360 <io_r>:
30001360:	e59f3014 	ldr	r3, [pc, #20]	; 3000137c <.text+0x137c>
30001364:	e1a00800 	mov	r0, r0, lsl #16
30001368:	e1a00820 	mov	r0, r0, lsr #16
3000136c:	e1c300b0 	strh	r0, [r3]
30001370:	e59f3008 	ldr	r3, [pc, #8]	; 30001380 <.text+0x1380>
30001374:	e1d300b0 	ldrh	r0, [r3]
30001378:	e1a0f00e 	mov	pc, lr
3000137c:	1900030a 	stmnedb	r0, {r1, r3, r8, r9}
30001380:	1900030c 	stmnedb	r0, {r2, r3, r8, r9}

30001384 <io_w>:
30001384:	e59f301c 	ldr	r3, [pc, #28]	; 300013a8 <.text+0x13a8>
30001388:	e1a00800 	mov	r0, r0, lsl #16
3000138c:	e1a00820 	mov	r0, r0, lsr #16
30001390:	e1c300b0 	strh	r0, [r3]
30001394:	e1a01801 	mov	r1, r1, lsl #16
30001398:	e59f300c 	ldr	r3, [pc, #12]	; 300013ac <.text+0x13ac>
3000139c:	e1a01821 	mov	r1, r1, lsr #16
300013a0:	e1c310b0 	strh	r1, [r3]
300013a4:	e1a0f00e 	mov	pc, lr
300013a8:	1900030a 	stmnedb	r0, {r1, r3, r8, r9}
300013ac:	1900030c 	stmnedb	r0, {r2, r3, r8, r9}

300013b0 <main>:

const unsigned char cs8900_mac[]={0x00, 0x43, 0x33, 0x2f, 0xde, 0x22};

void main()
{
300013b0:	e52de004 	str	lr, [sp, #-4]!
	random_init();
300013b4:	eb000275 	bl	30001d90 <random_init>
	cs8900_init(cs8900_mac);
300013b8:	e59f0008 	ldr	r0, [pc, #8]	; 300013c8 <.text+0x13c8>
300013bc:	ebffff84 	bl	300011d4 <cs8900_init>
	run_clean_boot();
300013c0:	e49de004 	ldr	lr, [sp], #4
300013c4:	eafffef4 	b	30000f9c <run_clean_boot>
300013c8:	30002e70 	andcc	r2, r0, r0, ror lr

300013cc <print_string>:
#include "debug.h"
#include "print.h"

void print_string(unsigned char *s)
{
300013cc:	e92d4010 	stmdb	sp!, {r4, lr}
300013d0:	e1a04000 	mov	r4, r0
        unsigned char c;
        while(1){
                if(!(c = *s++))
300013d4:	e4d43001 	ldrb	r3, [r4], #1
300013d8:	e2530000 	subs	r0, r3, #0	; 0x0
300013dc:	08bd8010 	ldmeqia	sp!, {r4, pc}
                        break;
                con_send(c);
300013e0:	eb000236 	bl	30001cc0 <s3c2440_serial_send_byte>
300013e4:	eafffffa 	b	300013d4 <print_string+0x8>

300013e8 <halfbyte2char>:
        }
        return;

}

unsigned char halfbyte2char(unsigned char c)
{
        return ((c & 0x0f) < 0x0a)?(0x30 + c):('A' + c - 0x0a);
300013e8:	e200300f 	and	r3, r0, #15	; 0xf
300013ec:	e20000ff 	and	r0, r0, #255	; 0xff
300013f0:	e3530009 	cmp	r3, #9	; 0x9
300013f4:	e2803030 	add	r3, r0, #48	; 0x30
300013f8:	e2800037 	add	r0, r0, #55	; 0x37
300013fc:	e20330ff 	and	r3, r3, #255	; 0xff
30001400:	c20030ff 	andgt	r3, r0, #255	; 0xff
}
30001404:	e1a00003 	mov	r0, r3
30001408:	e1a0f00e 	mov	pc, lr

3000140c <div>:

uint div(uint beichushu, uint chushu)
{
    uint shang = 0, tmp = 0;
3000140c:	e3a0c000 	mov	ip, #0	; 0x0
30001410:	e52de004 	str	lr, [sp, #-4]!
30001414:	e1a0200c 	mov	r2, ip
    const unsigned char bit_of_uint = 8 * sizeof(uint);
    unsigned char n = bit_of_uint;

    while(n--){
30001418:	e3a0e01f 	mov	lr, #31	; 0x1f
        tmp = (tmp<<1) + (beichushu>>(bit_of_uint - 1));
3000141c:	e24e3001 	sub	r3, lr, #1	; 0x1
30001420:	e203e0ff 	and	lr, r3, #255	; 0xff
30001424:	e1a03fa0 	mov	r3, r0, lsr #31
30001428:	e0832082 	add	r2, r3, r2, lsl #1
        beichushu<<=1;
        shang = shang<<1;
        if(tmp >= chushu){
3000142c:	e1520001 	cmp	r2, r1
30001430:	e1a0c08c 	mov	ip, ip, lsl #1
                tmp = tmp - chushu;
                shang++;
30001434:	228cc001 	addcs	ip, ip, #1	; 0x1
30001438:	20612002 	rsbcs	r2, r1, r2
3000143c:	e35e00ff 	cmp	lr, #255	; 0xff
30001440:	e1a00080 	mov	r0, r0, lsl #1
30001444:	01a0000c 	moveq	r0, ip
30001448:	049df004 	ldreq	pc, [sp], #4
3000144c:	eafffff2 	b	3000141c <div+0x10>

30001450 <num2str>:
        }
    }
    return shang;
}

unsigned char * num2str(uint jt, unsigned char * s, unsigned char n)
{
30001450:	e92d4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
30001454:	e20290ff 	and	r9, r2, #255	; 0xff
        unsigned char * st, k = 1, j;
        uint tmp;

        st = s;
        if(n > 16 || n < 2){
30001458:	e2493002 	sub	r3, r9, #2	; 0x2
3000145c:	e353000e 	cmp	r3, #14	; 0xe
                *st++ = 0x30;
30001460:	83a03030 	movhi	r3, #48	; 0x30
30001464:	85c13000 	strhib	r3, [r1]
                *st = 0;
30001468:	83a03000 	movhi	r3, #0	; 0x0
3000146c:	e1a0b001 	mov	fp, r1
30001470:	e1a07000 	mov	r7, r0
30001474:	e3a05001 	mov	r5, #1	; 0x1
30001478:	e1a0a001 	mov	sl, r1
3000147c:	85c13001 	strhib	r3, [r1, #1]
                return s;
30001480:	8a00001f 	bhi	30001504 <num2str+0xb4>
        }
        tmp = 1;
30001484:	e1a06005 	mov	r6, r5
        while(div(jt, tmp) >= n){
                k++;
                tmp *= n;
30001488:	e1a01006 	mov	r1, r6
3000148c:	e1a00007 	mov	r0, r7
30001490:	ebffffdd 	bl	3000140c <div>
30001494:	e2853001 	add	r3, r5, #1	; 0x1
30001498:	e1500009 	cmp	r0, r9
3000149c:	20060699 	mulcs	r6, r9, r6
300014a0:	220350ff 	andcs	r5, r3, #255	; 0xff
300014a4:	2afffff7 	bcs	30001488 <num2str+0x38>
        }

        while(k--){
300014a8:	e2453001 	sub	r3, r5, #1	; 0x1
300014ac:	e20350ff 	and	r5, r3, #255	; 0xff
300014b0:	e35500ff 	cmp	r5, #255	; 0xff
300014b4:	0a000010 	beq	300014fc <num2str+0xac>
                j = div(jt, tmp);
300014b8:	e1a01006 	mov	r1, r6
300014bc:	e1a00007 	mov	r0, r7
300014c0:	ebffffd1 	bl	3000140c <div>
300014c4:	e20040ff 	and	r4, r0, #255	; 0xff
                *st++ = halfbyte2char(j);
300014c8:	e1a00004 	mov	r0, r4
300014cc:	ebffffc5 	bl	300013e8 <halfbyte2char>
                jt -= tmp * j;
300014d0:	e0030694 	mul	r3, r4, r6
300014d4:	e4ca0001 	strb	r0, [sl], #1
                tmp = div(tmp, n);
300014d8:	e1a01009 	mov	r1, r9
300014dc:	e1a00006 	mov	r0, r6
300014e0:	e0637007 	rsb	r7, r3, r7
300014e4:	ebffffc8 	bl	3000140c <div>
300014e8:	e2453001 	sub	r3, r5, #1	; 0x1
300014ec:	e20350ff 	and	r5, r3, #255	; 0xff
300014f0:	e35500ff 	cmp	r5, #255	; 0xff
300014f4:	e1a06000 	mov	r6, r0
300014f8:	1affffee 	bne	300014b8 <num2str+0x68>
        }
        *st = 0;
300014fc:	e3a03000 	mov	r3, #0	; 0x0
30001500:	e5ca3000 	strb	r3, [sl]
        return s;
}
30001504:	e1a0000b 	mov	r0, fp
30001508:	e8bd8ef0 	ldmia	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}

3000150c <print_uint>:

void print_uint(uint num)
{
3000150c:	e92d4010 	stmdb	sp!, {r4, lr}
30001510:	e24dd00c 	sub	sp, sp, #12	; 0xc
        unsigned char nc[11];
        num2str(num, nc, 10);
30001514:	e1a0100d 	mov	r1, sp
30001518:	e3a0200a 	mov	r2, #10	; 0xa
3000151c:	ebffffcb 	bl	30001450 <num2str>
        print_string(nc);
30001520:	e1a0000d 	mov	r0, sp
30001524:	e1a0400d 	mov	r4, sp
30001528:	ebffffa7 	bl	300013cc <print_string>
3000152c:	e28dd00c 	add	sp, sp, #12	; 0xc
30001530:	e8bd8010 	ldmia	sp!, {r4, pc}

30001534 <print_hex>:
}

void print_hex(uint num)
{
30001534:	e92d4010 	stmdb	sp!, {r4, lr}
30001538:	e24dd00c 	sub	sp, sp, #12	; 0xc
        unsigned char nc[9];
        num2str(num, nc, 16);
3000153c:	e1a0100d 	mov	r1, sp
30001540:	e3a02010 	mov	r2, #16	; 0x10
30001544:	ebffffc1 	bl	30001450 <num2str>
        print_string(nc);
30001548:	e1a0000d 	mov	r0, sp
3000154c:	e1a0400d 	mov	r4, sp
30001550:	ebffff9d 	bl	300013cc <print_string>
30001554:	e28dd00c 	add	sp, sp, #12	; 0xc
30001558:	e8bd8010 	ldmia	sp!, {r4, pc}

3000155c <print_binary>:
}

void print_binary(uint num)
{
3000155c:	e92d4010 	stmdb	sp!, {r4, lr}
30001560:	e24dd024 	sub	sp, sp, #36	; 0x24
        unsigned char nc[33];
        num2str(num, nc, 2);
30001564:	e1a0100d 	mov	r1, sp
30001568:	e3a02002 	mov	r2, #2	; 0x2
3000156c:	ebffffb7 	bl	30001450 <num2str>
        print_string(nc);
30001570:	e1a0000d 	mov	r0, sp
30001574:	e1a0400d 	mov	r4, sp
30001578:	ebffff93 	bl	300013cc <print_string>
3000157c:	e28dd024 	add	sp, sp, #36	; 0x24
30001580:	e8bd8010 	ldmia	sp!, {r4, pc}

30001584 <lprint>:
}

void lprint(const unsigned char * fmt, ...)
{
30001584:	e92d000f 	stmdb	sp!, {r0, r1, r2, r3}
30001588:	e92d4030 	stmdb	sp!, {r4, r5, lr}
3000158c:	e59d400c 	ldr	r4, [sp, #12]
    const unsigned char *s;
    uint d;
    va_list ap;

    va_start(ap, fmt);
    while (*fmt) {
30001590:	e5d40000 	ldrb	r0, [r4]
30001594:	e3500000 	cmp	r0, #0	; 0x0
30001598:	e28d5010 	add	r5, sp, #16	; 0x10
3000159c:	0a000027 	beq	30001640 <lprint+0xbc>
        if (*fmt != '%') {
300015a0:	e20000ff 	and	r0, r0, #255	; 0xff
300015a4:	e3500025 	cmp	r0, #37	; 0x25
300015a8:	e2844001 	add	r4, r4, #1	; 0x1
300015ac:	0a000001 	beq	300015b8 <lprint+0x34>
	    con_send(*fmt++);
300015b0:	eb0001c2 	bl	30001cc0 <s3c2440_serial_send_byte>
            continue;
300015b4:	ea00001e 	b	30001634 <lprint+0xb0>
        }
        switch (*++fmt) {
300015b8:	e5d40000 	ldrb	r0, [r4]
300015bc:	e3500064 	cmp	r0, #100	; 0x64
300015c0:	0a00000d 	beq	300015fc <lprint+0x78>
300015c4:	ca000004 	bgt	300015dc <lprint+0x58>
300015c8:	e3500025 	cmp	r0, #37	; 0x25
300015cc:	0a000016 	beq	3000162c <lprint+0xa8>
300015d0:	e3500062 	cmp	r0, #98	; 0x62
300015d4:	0a00000e 	beq	30001614 <lprint+0x90>
300015d8:	ea000010 	b	30001620 <lprint+0x9c>
300015dc:	e3500073 	cmp	r0, #115	; 0x73
300015e0:	0a000002 	beq	300015f0 <lprint+0x6c>
300015e4:	e3500078 	cmp	r0, #120	; 0x78
300015e8:	0a000006 	beq	30001608 <lprint+0x84>
300015ec:	ea00000b 	b	30001620 <lprint+0x9c>
	    case '%':
	        con_send(*fmt);
		break;
            case 's':
                s = va_arg(ap, const unsigned char *);
300015f0:	e4950004 	ldr	r0, [r5], #4
                print_string(s);
300015f4:	ebffff74 	bl	300013cc <print_string>
                break;
300015f8:	ea00000c 	b	30001630 <lprint+0xac>
            case 'd':
                d = va_arg(ap, int);
300015fc:	e4950004 	ldr	r0, [r5], #4
                print_uint(d);
30001600:	ebffffc1 	bl	3000150c <print_uint>
                break;
30001604:	ea000009 	b	30001630 <lprint+0xac>
	    /*
	    case 'c':
                d = va_arg(ap, char);
                send_int(d);
                break;
	    */
	    case 'x':
                d = va_arg(ap, uint);
30001608:	e4950004 	ldr	r0, [r5], #4
                print_hex(d);
3000160c:	ebffffc8 	bl	30001534 <print_hex>
                break;
30001610:	ea000006 	b	30001630 <lprint+0xac>
	    case 'b':
                d = va_arg(ap, uint);
30001614:	e4950004 	ldr	r0, [r5], #4
                print_binary(d);
30001618:	ebffffcf 	bl	3000155c <print_binary>
                break;
3000161c:	ea000003 	b	30001630 <lprint+0xac>
            /* Add other specifiers here... */             
            default: 
                con_send(*(fmt-1));
30001620:	e5540001 	ldrb	r0, [r4, #-1]
30001624:	eb0001a5 	bl	30001cc0 <s3c2440_serial_send_byte>
		con_send(*fmt);
30001628:	e5d40000 	ldrb	r0, [r4]
3000162c:	eb0001a3 	bl	30001cc0 <s3c2440_serial_send_byte>
                break;
        }
        fmt++;
30001630:	e2844001 	add	r4, r4, #1	; 0x1
30001634:	e5d40000 	ldrb	r0, [r4]
30001638:	e3500000 	cmp	r0, #0	; 0x0
3000163c:	1affffd7 	bne	300015a0 <lprint+0x1c>
    }
    va_end(ap);
    return;   
30001640:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
30001644:	e28dd010 	add	sp, sp, #16	; 0x10
30001648:	e1a0f00e 	mov	pc, lr

3000164c <nand_reset>:

void nand_reset()
{
	uint tmp = 10;
	NFCONF = (7<<12)|(7<<8)|(7<<4)|(0<<0);
3000164c:	e59f204c 	ldr	r2, [pc, #76]	; 300016a0 <.text+0x16a0>
30001650:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001654:	e5832000 	str	r2, [r3]
	NFCONT = (1<<4)|(0<<1)|(1<<0);
30001658:	e59f3044 	ldr	r3, [pc, #68]	; 300016a4 <.text+0x16a4>
3000165c:	e3a02011 	mov	r2, #17	; 0x11
30001660:	e5832000 	str	r2, [r3]
	NFSTAT = 0x4;
30001664:	e59f303c 	ldr	r3, [pc, #60]	; 300016a8 <.text+0x16a8>
30001668:	e3a02004 	mov	r2, #4	; 0x4
3000166c:	e5c32000 	strb	r2, [r3]
	NFCMD = 0xff;
30001670:	e59f3034 	ldr	r3, [pc, #52]	; 300016ac <.text+0x16ac>
30001674:	e3e02000 	mvn	r2, #0	; 0x0
30001678:	e5c32000 	strb	r2, [r3]
3000167c:	e3a0300a 	mov	r3, #10	; 0xa
	while(tmp--);
30001680:	e2433001 	sub	r3, r3, #1	; 0x1
30001684:	e3730001 	cmn	r3, #1	; 0x1
30001688:	059f2014 	ldreq	r2, [pc, #20]	; 300016a4 <.text+0x16a4>
3000168c:	05923000 	ldreq	r3, [r2]
30001690:	03833002 	orreq	r3, r3, #2	; 0x2
30001694:	05823000 	streq	r3, [r2]
30001698:	01a0f00e 	moveq	pc, lr
3000169c:	eafffff7 	b	30001680 <nand_reset+0x34>
300016a0:	00007770 	andeq	r7, r0, r0, ror r7
300016a4:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
300016a8:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
300016ac:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}

300016b0 <nand_read_ll>:
        NAND_CHIP_DISABLE;
}

/* low level nand read function */
int nand_read_ll(unsigned char *buf, unsigned long start_addr, int size)
{
300016b0:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
300016b4:	e1a04001 	mov	r4, r1
300016b8:	e1a06000 	mov	r6, r0
300016bc:	e1a05002 	mov	r5, r2
        int i, j;
	
	lprint("Copy Command:membuf=%x, nandaddr=%x, size=%x\r\n", buf, start_addr, size);
300016c0:	e1a03005 	mov	r3, r5
300016c4:	e59f00f8 	ldr	r0, [pc, #248]	; 300017c4 <.text+0x17c4>
300016c8:	e1a01006 	mov	r1, r6
300016cc:	e1a02004 	mov	r2, r4
300016d0:	ebffffab 	bl	30001584 <lprint>
        if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK)) {
300016d4:	e1a03b84 	mov	r3, r4, lsl #23
300016d8:	e1a03ba3 	mov	r3, r3, lsr #23
300016dc:	e3530000 	cmp	r3, #0	; 0x0
300016e0:	1a000009 	bne	3000170c <nand_read_ll+0x5c>
300016e4:	e1a03b85 	mov	r3, r5, lsl #23
300016e8:	e1a03ba3 	mov	r3, r3, lsr #23
300016ec:	e3530000 	cmp	r3, #0	; 0x0
300016f0:	1a000005 	bne	3000170c <nand_read_ll+0x5c>
                return -1;      /* invalid alignment */
        }
	if(!(NFSTAT&0x1)){
300016f4:	e59f30cc 	ldr	r3, [pc, #204]	; 300017c8 <.text+0x17c8>
300016f8:	e5d33000 	ldrb	r3, [r3]
300016fc:	e3130001 	tst	r3, #1	; 0x1
30001700:	1a000003 	bne	30001714 <nand_read_ll+0x64>
		lprint("nand flash may have some problem, quit!\r\n");
30001704:	e59f00c0 	ldr	r0, [pc, #192]	; 300017cc <.text+0x17cc>
30001708:	ebffff9d 	bl	30001584 <lprint>
		return -1;
3000170c:	e3e00000 	mvn	r0, #0	; 0x0
	}

        NAND_CHIP_ENABLE;

        for(i=start_addr; i < (start_addr + size);) {
                /* READ0 */
                NAND_CLEAR_RB;
                NFCMD = 0;

                /* Write Address */
                NFADDR = i & 0xff;
                NFADDR = (i >> 9) & 0xff;
                NFADDR = (i >> 17) & 0xff;
                NFADDR = (i >> 25) & 0xff;

                NAND_DETECT_RB;

                for(j=0; j < NAND_SECTOR_SIZE; j++, i++) {
                        *buf = (NFDATA & 0xff);
                        buf++;
                }
		if(!((i>>9) & 0x3f))
			s3c2440_serial_send_byte('>');
        }
        NAND_CHIP_DISABLE;
        return 0;
}
30001710:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30001714:	e59f20b4 	ldr	r2, [pc, #180]	; 300017d0 <.text+0x17d0>
30001718:	e5923000 	ldr	r3, [r2]
3000171c:	e0845005 	add	r5, r4, r5
30001720:	e3c33002 	bic	r3, r3, #2	; 0x2
30001724:	e1540005 	cmp	r4, r5
30001728:	e5823000 	str	r3, [r2]
3000172c:	2a00001e 	bcs	300017ac <nand_read_ll+0xfc>
30001730:	e59f2090 	ldr	r2, [pc, #144]	; 300017c8 <.text+0x17c8>
30001734:	e5d23000 	ldrb	r3, [r2]
30001738:	e3833004 	orr	r3, r3, #4	; 0x4
3000173c:	e5c23000 	strb	r3, [r2]
30001740:	e59f108c 	ldr	r1, [pc, #140]	; 300017d4 <.text+0x17d4>
30001744:	e59f308c 	ldr	r3, [pc, #140]	; 300017d8 <.text+0x17d8>
30001748:	e1a004c4 	mov	r0, r4, asr #9
3000174c:	e1a0c8c4 	mov	ip, r4, asr #17
30001750:	e1a0ecc4 	mov	lr, r4, asr #25
30001754:	e3a02000 	mov	r2, #0	; 0x0
30001758:	e5c32000 	strb	r2, [r3]
3000175c:	e5c14000 	strb	r4, [r1]
30001760:	e5c10000 	strb	r0, [r1]
30001764:	e5c1c000 	strb	ip, [r1]
30001768:	e5c1e000 	strb	lr, [r1]
3000176c:	e59f3054 	ldr	r3, [pc, #84]	; 300017c8 <.text+0x17c8>
30001770:	e5d33000 	ldrb	r3, [r3]
30001774:	e3130004 	tst	r3, #4	; 0x4
30001778:	0afffffb 	beq	3000176c <nand_read_ll+0xbc>
3000177c:	e3a02c02 	mov	r2, #512	; 0x200
30001780:	e59f3054 	ldr	r3, [pc, #84]	; 300017dc <.text+0x17dc>
30001784:	e5d33000 	ldrb	r3, [r3]
30001788:	e2522001 	subs	r2, r2, #1	; 0x1
3000178c:	e4c63001 	strb	r3, [r6], #1
30001790:	e2844001 	add	r4, r4, #1	; 0x1
30001794:	1afffff9 	bne	30001780 <nand_read_ll+0xd0>
30001798:	e3140c7e 	tst	r4, #32256	; 0x7e00
3000179c:	03a0003e 	moveq	r0, #62	; 0x3e
300017a0:	0b000146 	bleq	30001cc0 <s3c2440_serial_send_byte>
300017a4:	e1540005 	cmp	r4, r5
300017a8:	3affffe0 	bcc	30001730 <nand_read_ll+0x80>
300017ac:	e59f201c 	ldr	r2, [pc, #28]	; 300017d0 <.text+0x17d0>
300017b0:	e5923000 	ldr	r3, [r2]
300017b4:	e3a00000 	mov	r0, #0	; 0x0
300017b8:	e3833002 	orr	r3, r3, #2	; 0x2
300017bc:	e5823000 	str	r3, [r2]
300017c0:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
300017c4:	30003a74 	andcc	r3, r0, r4, ror sl
300017c8:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
300017cc:	30003aa4 	andcc	r3, r0, r4, lsr #21
300017d0:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
300017d4:	4e00000c 	cdpmi	0, 0, cr0, cr0, cr12, {0}
300017d8:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
300017dc:	4e000010 	mcrmi	0, 0, r0, cr0, cr0, {0}

300017e0 <random_write_nand>:

#define ERASE_BLOCK_ADDR_MASK (512 * 32 -1)
uint random_write_nand(unsigned char c, uint addr)
{
300017e0:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
        NAND_CHIP_ENABLE;
300017e4:	e59f20c8 	ldr	r2, [pc, #200]	; 300018b4 <.text+0x18b4>
300017e8:	e5923000 	ldr	r3, [r2]
300017ec:	e3c33002 	bic	r3, r3, #2	; 0x2
300017f0:	e5823000 	str	r3, [r2]
        NAND_CLEAR_RB;
300017f4:	e59f40bc 	ldr	r4, [pc, #188]	; 300018b8 <.text+0x18b8>
300017f8:	e5d43000 	ldrb	r3, [r4]
	NFCMD = 0x80;
300017fc:	e59f60b8 	ldr	r6, [pc, #184]	; 300018bc <.text+0x18bc>
30001800:	e3833004 	orr	r3, r3, #4	; 0x4
30001804:	e5c43000 	strb	r3, [r4]
30001808:	e3e0307f 	mvn	r3, #127	; 0x7f
3000180c:	e5c63000 	strb	r3, [r6]
        NFADDR = (addr) & 0xff;
30001810:	e59f20a8 	ldr	r2, [pc, #168]	; 300018c0 <.text+0x18c0>
        NFADDR = (addr >> 9) & 0xff;
        NFADDR = (addr >> 17) & 0xff;
        NFADDR = (addr >> 25) & 0xff;
	NFDATA = c;
30001814:	e59f30a8 	ldr	r3, [pc, #168]	; 300018c4 <.text+0x18c4>
30001818:	e20000ff 	and	r0, r0, #255	; 0xff
3000181c:	e1a05ca1 	mov	r5, r1, lsr #25
30001820:	e1a0c4a1 	mov	ip, r1, lsr #9
30001824:	e1a0e8a1 	mov	lr, r1, lsr #17
30001828:	e5c21000 	strb	r1, [r2]
3000182c:	e5c2c000 	strb	ip, [r2]
30001830:	e5c2e000 	strb	lr, [r2]
30001834:	e5c25000 	strb	r5, [r2]
30001838:	e5c30000 	strb	r0, [r3]
	NFCMD = 0x10;
3000183c:	e3a03010 	mov	r3, #16	; 0x10
30001840:	e5c63000 	strb	r3, [r6]
        NAND_DETECT_RB;
30001844:	e59f306c 	ldr	r3, [pc, #108]	; 300018b8 <.text+0x18b8>
30001848:	e5d33000 	ldrb	r3, [r3]
3000184c:	e3130004 	tst	r3, #4	; 0x4
30001850:	0afffffb 	beq	30001844 <random_write_nand+0x64>
	while(!(NFSTAT & 0x1));
30001854:	e59f305c 	ldr	r3, [pc, #92]	; 300018b8 <.text+0x18b8>
30001858:	e5d33000 	ldrb	r3, [r3]
3000185c:	e3130001 	tst	r3, #1	; 0x1
30001860:	0afffffb 	beq	30001854 <random_write_nand+0x74>
	NFCMD = 0x70;
30001864:	e59f3050 	ldr	r3, [pc, #80]	; 300018bc <.text+0x18bc>
30001868:	e3a02070 	mov	r2, #112	; 0x70
3000186c:	e5c32000 	strb	r2, [r3]
	if(NFDATA & 0x1){
30001870:	e59f304c 	ldr	r3, [pc, #76]	; 300018c4 <.text+0x18c4>
30001874:	e5d33000 	ldrb	r3, [r3]
30001878:	e2130001 	ands	r0, r3, #1	; 0x1
3000187c:	0a000007 	beq	300018a0 <random_write_nand+0xc0>
		lprint("program failed! may get bad.\r\n");
30001880:	e59f0040 	ldr	r0, [pc, #64]	; 300018c8 <.text+0x18c8>
30001884:	ebffff3e 	bl	30001584 <lprint>
        	NAND_CHIP_DISABLE;
30001888:	e59f2024 	ldr	r2, [pc, #36]	; 300018b4 <.text+0x18b4>
3000188c:	e5923000 	ldr	r3, [r2]
		return -1;
30001890:	e3e00000 	mvn	r0, #0	; 0x0
30001894:	e3833002 	orr	r3, r3, #2	; 0x2
30001898:	e5823000 	str	r3, [r2]
	}
        NAND_CHIP_DISABLE;
	return 0;
}
3000189c:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
300018a0:	e59f200c 	ldr	r2, [pc, #12]	; 300018b4 <.text+0x18b4>
300018a4:	e5923000 	ldr	r3, [r2]
300018a8:	e3833002 	orr	r3, r3, #2	; 0x2
300018ac:	e5823000 	str	r3, [r2]
300018b0:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
300018b4:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
300018b8:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
300018bc:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
300018c0:	4e00000c 	cdpmi	0, 0, cr0, cr0, cr12, {0}
300018c4:	4e000010 	mcrmi	0, 0, r0, cr0, cr0, {0}
300018c8:	30003ad0 	ldrccd	r3, [r0], -r0

300018cc <random_read_nand>:
uint random_read_nand(uint spare, uint addr)
{
	uint tmd;
	if(spare) 
300018cc:	e3500000 	cmp	r0, #0	; 0x0
300018d0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
300018d4:	e1a04001 	mov	r4, r1
300018d8:	13a05050 	movne	r5, #80	; 0x50
300018dc:	1a000002 	bne	300018ec <random_read_nand+0x20>
		tmd = 0x50;
	else if(addr & 0x100)
300018e0:	e2113c01 	ands	r3, r1, #256	; 0x100
300018e4:	01a05003 	moveq	r5, r3
300018e8:	13a05001 	movne	r5, #1	; 0x1
		tmd = 0x01;
	else	
		tmd = 0;
        NAND_CHIP_ENABLE;
300018ec:	e59f2074 	ldr	r2, [pc, #116]	; 30001968 <.text+0x1968>
300018f0:	e5923000 	ldr	r3, [r2]
300018f4:	e3c33002 	bic	r3, r3, #2	; 0x2
300018f8:	e5823000 	str	r3, [r2]
        NAND_CLEAR_RB;
300018fc:	e59f1068 	ldr	r1, [pc, #104]	; 3000196c <.text+0x196c>
30001900:	e5d13000 	ldrb	r3, [r1]
30001904:	e3833004 	orr	r3, r3, #4	; 0x4
30001908:	e5c13000 	strb	r3, [r1]
	NFCMD = tmd;
        NFADDR = (addr) & 0xff;
3000190c:	e59f205c 	ldr	r2, [pc, #92]	; 30001970 <.text+0x1970>
30001910:	e59f305c 	ldr	r3, [pc, #92]	; 30001974 <.text+0x1974>
        NFADDR = (addr >> 9) & 0xff;
        NFADDR = (addr >> 17) & 0xff;
        NFADDR = (addr >> 25) & 0xff;
30001914:	e1a0eca4 	mov	lr, r4, lsr #25
30001918:	e1a004a4 	mov	r0, r4, lsr #9
3000191c:	e1a0c8a4 	mov	ip, r4, lsr #17
30001920:	e5c35000 	strb	r5, [r3]
30001924:	e5c24000 	strb	r4, [r2]
30001928:	e5c20000 	strb	r0, [r2]
3000192c:	e5c2c000 	strb	ip, [r2]
30001930:	e5c2e000 	strb	lr, [r2]
        NAND_DETECT_RB;
30001934:	e59f3030 	ldr	r3, [pc, #48]	; 3000196c <.text+0x196c>
30001938:	e5d33000 	ldrb	r3, [r3]
3000193c:	e3130004 	tst	r3, #4	; 0x4
30001940:	0afffffb 	beq	30001934 <random_read_nand+0x68>
	tmd =  NFDATA & 0xff;
30001944:	e59f302c 	ldr	r3, [pc, #44]	; 30001978 <.text+0x1978>
        NAND_CHIP_DISABLE;
30001948:	e59f1018 	ldr	r1, [pc, #24]	; 30001968 <.text+0x1968>
3000194c:	e5d32000 	ldrb	r2, [r3]
30001950:	e5913000 	ldr	r3, [r1]
30001954:	e20250ff 	and	r5, r2, #255	; 0xff
30001958:	e3833002 	orr	r3, r3, #2	; 0x2
	return tmd;
}
3000195c:	e1a00005 	mov	r0, r5
30001960:	e5813000 	str	r3, [r1]
30001964:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30001968:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
3000196c:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
30001970:	4e00000c 	cdpmi	0, 0, cr0, cr0, cr12, {0}
30001974:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
30001978:	4e000010 	mcrmi	0, 0, r0, cr0, cr0, {0}

3000197c <is_marked_bad_block>:
	
int is_marked_bad_block(uint addr)
{
3000197c:	e92d4010 	stmdb	sp!, {r4, lr}
	unsigned char a;
	uint i;

	addr &= ~ERASE_BLOCK_ADDR_MASK;
        if(!(NFSTAT&0x1)){
30001980:	e59f3064 	ldr	r3, [pc, #100]	; 300019ec <.text+0x19ec>
30001984:	e1a04000 	mov	r4, r0
30001988:	e5d33000 	ldrb	r3, [r3]
3000198c:	e3c44dff 	bic	r4, r4, #16320	; 0x3fc0
30001990:	e3c4403f 	bic	r4, r4, #63	; 0x3f
30001994:	e3130001 	tst	r3, #1	; 0x1
30001998:	e59f0050 	ldr	r0, [pc, #80]	; 300019f0 <.text+0x19f0>
3000199c:	e2841005 	add	r1, r4, #5	; 0x5
300019a0:	1a000002 	bne	300019b0 <is_marked_bad_block+0x34>
                lprint("nand flash may have some problem, quit!\r\n");
300019a4:	ebfffef6 	bl	30001584 <lprint>
                return -1;
300019a8:	e3e03000 	mvn	r3, #0	; 0x0
300019ac:	ea00000c 	b	300019e4 <is_marked_bad_block+0x68>
        }
	if(random_read_nand(1, addr+5) != 0xff || 
300019b0:	e3a00001 	mov	r0, #1	; 0x1
300019b4:	ebffffc4 	bl	300018cc <random_read_nand>
300019b8:	e1a03000 	mov	r3, r0
300019bc:	e2841f81 	add	r1, r4, #516	; 0x204
300019c0:	e35300ff 	cmp	r3, #255	; 0xff
300019c4:	e2811001 	add	r1, r1, #1	; 0x1
300019c8:	e3a00001 	mov	r0, #1	; 0x1
300019cc:	1a000003 	bne	300019e0 <is_marked_bad_block+0x64>
300019d0:	ebffffbd 	bl	300018cc <random_read_nand>
300019d4:	e35000ff 	cmp	r0, #255	; 0xff
300019d8:	e3a03000 	mov	r3, #0	; 0x0
300019dc:	0a000000 	beq	300019e4 <is_marked_bad_block+0x68>
		random_read_nand(1, addr+5+512) != 0xff)
		return 1;
300019e0:	e3a03001 	mov	r3, #1	; 0x1

	return 0;	
}
300019e4:	e1a00003 	mov	r0, r3
300019e8:	e8bd8010 	ldmia	sp!, {r4, pc}
300019ec:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
300019f0:	30003aa4 	andcc	r3, r0, r4, lsr #21

300019f4 <nand_erase_ll>:

#if 0
int is_marked_bad_block(uint addr)
{
	unsigned char a;
	uint i;

	addr &= ~ERASE_BLOCK_ADDR_MASK;
        if(!(NFSTAT&0x1)){
                lprint("nand flash may have some problem, quit!\r\n");
                return -1;
        }
        NAND_CHIP_ENABLE;
        NAND_CLEAR_RB;
	NFCMD = 0x50;
        NFADDR = (addr) & 0xff;
        NFADDR = (addr >> 9) & 0xff;
        NFADDR = (addr >> 17) & 0xff;
        NFADDR = (addr >> 25) & 0xff;
        NAND_DETECT_RB;
	i = 5;
	while(i--){
		a = NFDATA;
#ifdef NAND_DEBUG
		lprint("%x\r\n", a);
#endif  
	}
	a = NFDATA;
#ifdef NAND_DEBUG
	lprint("%x\r\n", a);
#endif  
	if(a != 0xff){
#ifdef NAND_DEBUG
		lprint("marded bad\r\n");
#endif  
		return 1;
	}
	i = 15;
	while(i--){
		a = NFDATA;
#ifdef NAND_DEBUG
		lprint("%x\r\n", a);
#endif  
	}
	a = NFDATA;
#ifdef NAND_DEBUG
	lprint("%x\r\n", a);
#endif  
	if(a != 0xff){
#ifdef NAND_DEBUG
		lprint("marded bad\r\n");
#endif  
		return 1;
	}
	i = 10;
	while(i--){
		a = NFDATA;
#ifdef NAND_DEBUG
		lprint("%x\r\n", a);
#endif  
	}
#ifdef NAND_DEBUG
	lprint("not marked bad\r\n");
#endif  
        NAND_CHIP_DISABLE;
	return 0;	
}
#endif /*if 0*/

int nand_erase_ll(uint addr)
{
300019f4:	e92d4030 	stmdb	sp!, {r4, r5, lr}
        lprint("Erase Command:addr=%x\r\n", addr);
300019f8:	e1a01000 	mov	r1, r0
300019fc:	e1a04000 	mov	r4, r0
30001a00:	e59f00ec 	ldr	r0, [pc, #236]	; 30001af4 <.text+0x1af4>
30001a04:	ebfffede 	bl	30001584 <lprint>
	if(addr & ERASE_BLOCK_ADDR_MASK){
30001a08:	e1a03904 	mov	r3, r4, lsl #18
30001a0c:	e1a03923 	mov	r3, r3, lsr #18
30001a10:	e3530000 	cmp	r3, #0	; 0x0
30001a14:	159f00dc 	ldrne	r0, [pc, #220]	; 30001af8 <.text+0x1af8>
30001a18:	1a000004 	bne	30001a30 <nand_erase_ll+0x3c>
		lprint("erase addr not correct!\r\n");
		return -1;
	}	
        if(!(NFSTAT&0x1)){
30001a1c:	e59f50d8 	ldr	r5, [pc, #216]	; 30001afc <.text+0x1afc>
30001a20:	e5d53000 	ldrb	r3, [r5]
30001a24:	e3130001 	tst	r3, #1	; 0x1
30001a28:	1a000003 	bne	30001a3c <nand_erase_ll+0x48>
                lprint("nand flash may have some problem, quit!\r\n");
30001a2c:	e59f00cc 	ldr	r0, [pc, #204]	; 30001b00 <.text+0x1b00>
30001a30:	ebfffed3 	bl	30001584 <lprint>
                return -1;
30001a34:	e3e00000 	mvn	r0, #0	; 0x0
        }
/*
	if(is_marked_bad_block(addr)){
                lprint("block %x is bad block, quit!\r\n",addr);
                return -1;
	}
*/
        NAND_CHIP_ENABLE;
        NAND_CLEAR_RB;
	NFCMD = 0x60;
        NFADDR = (addr >> 9) & 0xff;
        NFADDR = (addr >> 17) & 0xff;
        NFADDR = (addr >> 25) & 0xff;
	NFCMD = 0xd0;
	while(!(NFSTAT & 0x1)){
#ifdef NAND_DEBUG
		lprint("%x\r\n", NFSTAT);
#endif	
	}
	NFCMD = 0x70;
	if(NFDATA & 0x1){
		lprint("erase failed! may get bad.\r\n");
        	NAND_CHIP_DISABLE;
		return -1;
	}
	lprint("erase successfully! \r\n");
        NAND_CHIP_DISABLE;
	return 0;
}
30001a38:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30001a3c:	e59f20c0 	ldr	r2, [pc, #192]	; 30001b04 <.text+0x1b04>
30001a40:	e5923000 	ldr	r3, [r2]
30001a44:	e3c33002 	bic	r3, r3, #2	; 0x2
30001a48:	e5823000 	str	r3, [r2]
30001a4c:	e5d53000 	ldrb	r3, [r5]
30001a50:	e59fc0b0 	ldr	ip, [pc, #176]	; 30001b08 <.text+0x1b08>
30001a54:	e3833004 	orr	r3, r3, #4	; 0x4
30001a58:	e5c53000 	strb	r3, [r5]
30001a5c:	e59f20a8 	ldr	r2, [pc, #168]	; 30001b0c <.text+0x1b0c>
30001a60:	e3a03060 	mov	r3, #96	; 0x60
30001a64:	e5cc3000 	strb	r3, [ip]
30001a68:	e1a0eca4 	mov	lr, r4, lsr #25
30001a6c:	e1a014a4 	mov	r1, r4, lsr #9
30001a70:	e1a008a4 	mov	r0, r4, lsr #17
30001a74:	e3e0302f 	mvn	r3, #47	; 0x2f
30001a78:	e5c21000 	strb	r1, [r2]
30001a7c:	e5c20000 	strb	r0, [r2]
30001a80:	e5c2e000 	strb	lr, [r2]
30001a84:	e5cc3000 	strb	r3, [ip]
30001a88:	e59f306c 	ldr	r3, [pc, #108]	; 30001afc <.text+0x1afc>
30001a8c:	e5d33000 	ldrb	r3, [r3]
30001a90:	e3130001 	tst	r3, #1	; 0x1
30001a94:	0afffffb 	beq	30001a88 <nand_erase_ll+0x94>
30001a98:	e59f3068 	ldr	r3, [pc, #104]	; 30001b08 <.text+0x1b08>
30001a9c:	e3a02070 	mov	r2, #112	; 0x70
30001aa0:	e5c32000 	strb	r2, [r3]
30001aa4:	e59f3064 	ldr	r3, [pc, #100]	; 30001b10 <.text+0x1b10>
30001aa8:	e5d33000 	ldrb	r3, [r3]
30001aac:	e2134001 	ands	r4, r3, #1	; 0x1
30001ab0:	0a000007 	beq	30001ad4 <nand_erase_ll+0xe0>
30001ab4:	e59f0058 	ldr	r0, [pc, #88]	; 30001b14 <.text+0x1b14>
30001ab8:	ebfffeb1 	bl	30001584 <lprint>
30001abc:	e59f2040 	ldr	r2, [pc, #64]	; 30001b04 <.text+0x1b04>
30001ac0:	e5923000 	ldr	r3, [r2]
30001ac4:	e3e00000 	mvn	r0, #0	; 0x0
30001ac8:	e3833002 	orr	r3, r3, #2	; 0x2
30001acc:	e5823000 	str	r3, [r2]
30001ad0:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30001ad4:	e59f003c 	ldr	r0, [pc, #60]	; 30001b18 <.text+0x1b18>
30001ad8:	ebfffea9 	bl	30001584 <lprint>
30001adc:	e59f2020 	ldr	r2, [pc, #32]	; 30001b04 <.text+0x1b04>
30001ae0:	e5923000 	ldr	r3, [r2]
30001ae4:	e1a00004 	mov	r0, r4
30001ae8:	e3833002 	orr	r3, r3, #2	; 0x2
30001aec:	e5823000 	str	r3, [r2]
30001af0:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
30001af4:	30003af0 	strccd	r3, [r0], -r0
30001af8:	30003b08 	andcc	r3, r0, r8, lsl #22
30001afc:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
30001b00:	30003aa4 	andcc	r3, r0, r4, lsr #21
30001b04:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
30001b08:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
30001b0c:	4e00000c 	cdpmi	0, 0, cr0, cr0, cr12, {0}
30001b10:	4e000010 	mcrmi	0, 0, r0, cr0, cr0, {0}
30001b14:	30003b24 	andcc	r3, r0, r4, lsr #22
30001b18:	30003b44 	andcc	r3, r0, r4, asr #22

30001b1c <nand_write_ll>:

int nand_write_ll(unsigned char *buf, unsigned long start_addr, int size)
{
30001b1c:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
30001b20:	e1a04001 	mov	r4, r1
30001b24:	e1a06000 	mov	r6, r0
30001b28:	e1a05002 	mov	r5, r2
        uint i, j;

        lprint("Write Command:membuf=%x, nandaddr=%x, size=%x\r\n", buf, start_addr, size);
30001b2c:	e1a03005 	mov	r3, r5
30001b30:	e59f0164 	ldr	r0, [pc, #356]	; 30001c9c <.text+0x1c9c>
30001b34:	e1a01006 	mov	r1, r6
30001b38:	e1a02004 	mov	r2, r4
30001b3c:	ebfffe90 	bl	30001584 <lprint>
        if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK)) {
30001b40:	e1a03b84 	mov	r3, r4, lsl #23
30001b44:	e1a03ba3 	mov	r3, r3, lsr #23
30001b48:	e3530000 	cmp	r3, #0	; 0x0
30001b4c:	1a000009 	bne	30001b78 <nand_write_ll+0x5c>
30001b50:	e1a03b85 	mov	r3, r5, lsl #23
30001b54:	e1a03ba3 	mov	r3, r3, lsr #23
30001b58:	e3530000 	cmp	r3, #0	; 0x0
30001b5c:	1a000005 	bne	30001b78 <nand_write_ll+0x5c>
                return -1;      /* invalid alignment */
        }
        if(!(NFSTAT&0x1)){
30001b60:	e59f3138 	ldr	r3, [pc, #312]	; 30001ca0 <.text+0x1ca0>
30001b64:	e5d33000 	ldrb	r3, [r3]
30001b68:	e3130001 	tst	r3, #1	; 0x1
30001b6c:	1a00000e 	bne	30001bac <nand_write_ll+0x90>
                lprint("nand flash may have some problem, quit!\r\n");
30001b70:	e59f012c 	ldr	r0, [pc, #300]	; 30001ca4 <.text+0x1ca4>
30001b74:	ebfffe82 	bl	30001584 <lprint>
                return -1;
30001b78:	e3e00000 	mvn	r0, #0	; 0x0
        }

        NAND_CHIP_ENABLE;

        for(i=start_addr; i < (start_addr + size);) {
                /* READ0 */
                NAND_CLEAR_RB;
                NFCMD = 0x80;

                /* Write Address */
                NFADDR = i & 0xff;
                NFADDR = (i >> 9) & 0xff;
                NFADDR = (i >> 17) & 0xff;
                NFADDR = (i >> 25) & 0xff;


                for(j=0; j < NAND_SECTOR_SIZE; j++, i++) {
                        NFDATA = *buf++;
                }
		NFCMD = 0x10;
        	NAND_DETECT_RB;
		
		while(!NFSTAT&0x1);
		NFCMD = 0x70;
		if(NFDATA & 0x1){
			lprint("current block(%x)program failed! may get bad.\r\n", (i-512)&~ERASE_BLOCK_ADDR_MASK);
        		NAND_CHIP_DISABLE;
			return -1;
		}	
		
                if(!((i>>9) & 0x3f))
                        s3c2440_serial_send_byte('<');
        }
        NAND_CHIP_DISABLE;
        return 0;
}
30001b7c:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30001b80:	e2441c02 	sub	r1, r4, #512	; 0x200
30001b84:	e3c11dff 	bic	r1, r1, #16320	; 0x3fc0
30001b88:	e59f0118 	ldr	r0, [pc, #280]	; 30001ca8 <.text+0x1ca8>
30001b8c:	e3c1103f 	bic	r1, r1, #63	; 0x3f
30001b90:	ebfffe7b 	bl	30001584 <lprint>
30001b94:	e59f2110 	ldr	r2, [pc, #272]	; 30001cac <.text+0x1cac>
30001b98:	e5923000 	ldr	r3, [r2]
30001b9c:	e3e00000 	mvn	r0, #0	; 0x0
30001ba0:	e3833002 	orr	r3, r3, #2	; 0x2
30001ba4:	e5823000 	str	r3, [r2]
30001ba8:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30001bac:	e59f20f8 	ldr	r2, [pc, #248]	; 30001cac <.text+0x1cac>
30001bb0:	e5923000 	ldr	r3, [r2]
30001bb4:	e0845005 	add	r5, r4, r5
30001bb8:	e3c33002 	bic	r3, r3, #2	; 0x2
30001bbc:	e1540005 	cmp	r4, r5
30001bc0:	e5823000 	str	r3, [r2]
30001bc4:	2a00002e 	bcs	30001c84 <nand_write_ll+0x168>
30001bc8:	e59f20d0 	ldr	r2, [pc, #208]	; 30001ca0 <.text+0x1ca0>
30001bcc:	e5d23000 	ldrb	r3, [r2]
30001bd0:	e3833004 	orr	r3, r3, #4	; 0x4
30001bd4:	e5c23000 	strb	r3, [r2]
30001bd8:	e59f10d0 	ldr	r1, [pc, #208]	; 30001cb0 <.text+0x1cb0>
30001bdc:	e59f30d0 	ldr	r3, [pc, #208]	; 30001cb4 <.text+0x1cb4>
30001be0:	e1a004a4 	mov	r0, r4, lsr #9
30001be4:	e3e0207f 	mvn	r2, #127	; 0x7f
30001be8:	e5c32000 	strb	r2, [r3]
30001bec:	e1a0c8a4 	mov	ip, r4, lsr #17
30001bf0:	e5c14000 	strb	r4, [r1]
30001bf4:	e1a0eca4 	mov	lr, r4, lsr #25
30001bf8:	e5c10000 	strb	r0, [r1]
30001bfc:	e59f00b4 	ldr	r0, [pc, #180]	; 30001cb8 <.text+0x1cb8>
30001c00:	e5c1c000 	strb	ip, [r1]
30001c04:	e5c1e000 	strb	lr, [r1]
30001c08:	e3a01000 	mov	r1, #0	; 0x0
30001c0c:	e4d62001 	ldrb	r2, [r6], #1
30001c10:	e2811001 	add	r1, r1, #1	; 0x1
30001c14:	e59f30a0 	ldr	r3, [pc, #160]	; 30001cbc <.text+0x1cbc>
30001c18:	e1510000 	cmp	r1, r0
30001c1c:	e5c32000 	strb	r2, [r3]
30001c20:	e2844001 	add	r4, r4, #1	; 0x1
30001c24:	9afffff8 	bls	30001c0c <nand_write_ll+0xf0>
30001c28:	e59f3084 	ldr	r3, [pc, #132]	; 30001cb4 <.text+0x1cb4>
30001c2c:	e3a02010 	mov	r2, #16	; 0x10
30001c30:	e5c32000 	strb	r2, [r3]
30001c34:	e59f3064 	ldr	r3, [pc, #100]	; 30001ca0 <.text+0x1ca0>
30001c38:	e5d33000 	ldrb	r3, [r3]
30001c3c:	e3130004 	tst	r3, #4	; 0x4
30001c40:	0afffffb 	beq	30001c34 <nand_write_ll+0x118>
30001c44:	e59f3054 	ldr	r3, [pc, #84]	; 30001ca0 <.text+0x1ca0>
30001c48:	e5d33000 	ldrb	r3, [r3]
30001c4c:	e3530000 	cmp	r3, #0	; 0x0
30001c50:	0afffffb 	beq	30001c44 <nand_write_ll+0x128>
30001c54:	e59f3058 	ldr	r3, [pc, #88]	; 30001cb4 <.text+0x1cb4>
30001c58:	e3a02070 	mov	r2, #112	; 0x70
30001c5c:	e5c32000 	strb	r2, [r3]
30001c60:	e59f3054 	ldr	r3, [pc, #84]	; 30001cbc <.text+0x1cbc>
30001c64:	e5d33000 	ldrb	r3, [r3]
30001c68:	e3130001 	tst	r3, #1	; 0x1
30001c6c:	1affffc3 	bne	30001b80 <nand_write_ll+0x64>
30001c70:	e3140c7e 	tst	r4, #32256	; 0x7e00
30001c74:	03a0003c 	moveq	r0, #60	; 0x3c
30001c78:	0b000010 	bleq	30001cc0 <s3c2440_serial_send_byte>
30001c7c:	e1540005 	cmp	r4, r5
30001c80:	3affffd0 	bcc	30001bc8 <nand_write_ll+0xac>
30001c84:	e59f2020 	ldr	r2, [pc, #32]	; 30001cac <.text+0x1cac>
30001c88:	e5923000 	ldr	r3, [r2]
30001c8c:	e3a00000 	mov	r0, #0	; 0x0
30001c90:	e3833002 	orr	r3, r3, #2	; 0x2
30001c94:	e5823000 	str	r3, [r2]
30001c98:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
30001c9c:	30003b5c 	andcc	r3, r0, ip, asr fp
30001ca0:	4e000020 	cdpmi	0, 0, cr0, cr0, cr0, {1}
30001ca4:	30003aa4 	andcc	r3, r0, r4, lsr #21
30001ca8:	30003b8c 	andcc	r3, r0, ip, lsl #23
30001cac:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
30001cb0:	4e00000c 	cdpmi	0, 0, cr0, cr0, cr12, {0}
30001cb4:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
30001cb8:	000001ff 	streqd	r0, [r0], -pc
30001cbc:	4e000010 	mcrmi	0, 0, r0, cr0, cr0, {0}

30001cc0 <s3c2440_serial_send_byte>:
                    

/*
void s3c2440_serial_init(){
	GPHCON = 0xaaa0;
	GPHUP = 0x7ff;
	ULCON0 = 0x3;
	UCCON0 = 0x5;
	UBRDIV0 = 18;//set bautrate 9600bps
}
*/
void s3c2440_serial_send_byte(unsigned char c)
{
30001cc0:	e20000ff 	and	r0, r0, #255	; 0xff
        while(!(USCON0 & 0x2));
30001cc4:	e59f3014 	ldr	r3, [pc, #20]	; 30001ce0 <.text+0x1ce0>
30001cc8:	e5933000 	ldr	r3, [r3]
30001ccc:	e3130002 	tst	r3, #2	; 0x2
30001cd0:	159f300c 	ldrne	r3, [pc, #12]	; 30001ce4 <.text+0x1ce4>
30001cd4:	15830000 	strne	r0, [r3]
30001cd8:	11a0f00e 	movne	pc, lr
30001cdc:	eafffff8 	b	30001cc4 <s3c2440_serial_send_byte+0x4>
30001ce0:	50000010 	andpl	r0, r0, r0, lsl r0
30001ce4:	50000020 	andpl	r0, r0, r0, lsr #32

30001ce8 <s3c2440_serial_recv_byte>:
        UTXH0 = c;
}

static unsigned short random[16];
static uint newrandom = 0, userandom = 0, runner = 0;
unsigned char s3c2440_serial_recv_byte()
{
        while(!(USCON0 & 0x1))
30001ce8:	e59f0074 	ldr	r0, [pc, #116]	; 30001d64 <.text+0x1d64>
30001cec:	e5903000 	ldr	r3, [r0]
30001cf0:	e3130001 	tst	r3, #1	; 0x1
30001cf4:	1a000006 	bne	30001d14 <s3c2440_serial_recv_byte+0x2c>
		runner++;
30001cf8:	e59f1068 	ldr	r1, [pc, #104]	; 30001d68 <.text+0x1d68>
30001cfc:	e5902000 	ldr	r2, [r0]
30001d00:	e5913000 	ldr	r3, [r1]
30001d04:	e3120001 	tst	r2, #1	; 0x1
30001d08:	e2833001 	add	r3, r3, #1	; 0x1
30001d0c:	e5813000 	str	r3, [r1]
30001d10:	0afffff8 	beq	30001cf8 <s3c2440_serial_recv_byte+0x10>
	if(((newrandom - userandom)&0xf) != 15)/*random not full*/
30001d14:	e59f1050 	ldr	r1, [pc, #80]	; 30001d6c <.text+0x1d6c>
30001d18:	e59f3050 	ldr	r3, [pc, #80]	; 30001d70 <.text+0x1d70>
30001d1c:	e5912000 	ldr	r2, [r1]
30001d20:	e5933000 	ldr	r3, [r3]
30001d24:	e0633002 	rsb	r3, r3, r2
30001d28:	e203300f 	and	r3, r3, #15	; 0xf
30001d2c:	e353000f 	cmp	r3, #15	; 0xf
30001d30:	0a000007 	beq	30001d54 <s3c2440_serial_recv_byte+0x6c>
		random[(newrandom++)&0xf]=runner&0xffff;	
30001d34:	e2823001 	add	r3, r2, #1	; 0x1
30001d38:	e5813000 	str	r3, [r1]
30001d3c:	e59f1024 	ldr	r1, [pc, #36]	; 30001d68 <.text+0x1d68>
30001d40:	e202200f 	and	r2, r2, #15	; 0xf
30001d44:	e59f3028 	ldr	r3, [pc, #40]	; 30001d74 <.text+0x1d74>
30001d48:	e1d110b0 	ldrh	r1, [r1]
30001d4c:	e1a02082 	mov	r2, r2, lsl #1
30001d50:	e18210b3 	strh	r1, [r2, r3]
        return URXH0;
30001d54:	e59f301c 	ldr	r3, [pc, #28]	; 30001d78 <.text+0x1d78>
30001d58:	e5930000 	ldr	r0, [r3]
30001d5c:	e20000ff 	and	r0, r0, #255	; 0xff
}
30001d60:	e1a0f00e 	mov	pc, lr
30001d64:	50000010 	andpl	r0, r0, r0, lsl r0
30001d68:	30003e60 	andcc	r3, r0, r0, ror #28
30001d6c:	30003e58 	andcc	r3, r0, r8, asr lr
30001d70:	30003e5c 	andcc	r3, r0, ip, asr lr
30001d74:	30003e64 	andcc	r3, r0, r4, ror #28
30001d78:	50000024 	andpl	r0, r0, r4, lsr #32

30001d7c <s3c2440_is_serial_recv>:

uint s3c2440_is_serial_recv()
{
	return (USCON0 & 0x1);
30001d7c:	e59f3008 	ldr	r3, [pc, #8]	; 30001d8c <.text+0x1d8c>
30001d80:	e5930000 	ldr	r0, [r3]
30001d84:	e2000001 	and	r0, r0, #1	; 0x1
}
30001d88:	e1a0f00e 	mov	pc, lr
30001d8c:	50000010 	andpl	r0, r0, r0, lsl r0

30001d90 <random_init>:
void random_init()
{
	userandom = 0;
30001d90:	e59fc01c 	ldr	ip, [pc, #28]	; 30001db4 <.text+0x1db4>
30001d94:	e3a03000 	mov	r3, #0	; 0x0
30001d98:	e58c3000 	str	r3, [ip]
	newrandom = 0;
	lmemset(random, 0, 32);
30001d9c:	e59f0014 	ldr	r0, [pc, #20]	; 30001db8 <.text+0x1db8>
30001da0:	e59fc014 	ldr	ip, [pc, #20]	; 30001dbc <.text+0x1dbc>
30001da4:	e1a01003 	mov	r1, r3
30001da8:	e3a02020 	mov	r2, #32	; 0x20
30001dac:	e58c3000 	str	r3, [ip]
30001db0:	eafffc07 	b	30000dd4 <lmemset>
30001db4:	30003e5c 	andcc	r3, r0, ip, asr lr
30001db8:	30003e64 	andcc	r3, r0, r4, ror #28
30001dbc:	30003e58 	andcc	r3, r0, r8, asr lr

30001dc0 <random_u16>:
}
unsigned short random_u16()
{
	if((userandom&0xf) != (newrandom&0xf))/*random not empty*/
30001dc0:	e59fc034 	ldr	ip, [pc, #52]	; 30001dfc <.text+0x1dfc>
30001dc4:	e59f3034 	ldr	r3, [pc, #52]	; 30001e00 <.text+0x1e00>
30001dc8:	e59c1000 	ldr	r1, [ip]
30001dcc:	e5933000 	ldr	r3, [r3]
30001dd0:	e201200f 	and	r2, r1, #15	; 0xf
30001dd4:	e203300f 	and	r3, r3, #15	; 0xf
30001dd8:	e1520003 	cmp	r2, r3
		return random[(userandom++)&0xf];
30001ddc:	159f3020 	ldrne	r3, [pc, #32]	; 30001e04 <.text+0x1e04>
30001de0:	e1a00082 	mov	r0, r2, lsl #1
30001de4:	119030b3 	ldrneh	r3, [r0, r3]
30001de8:	e2811001 	add	r1, r1, #1	; 0x1
30001dec:	11a00003 	movne	r0, r3
	return 0;
30001df0:	03a00000 	moveq	r0, #0	; 0x0
30001df4:	158c1000 	strne	r1, [ip]
}
30001df8:	e1a0f00e 	mov	pc, lr
30001dfc:	30003e5c 	andcc	r3, r0, ip, asr lr
30001e00:	30003e58 	andcc	r3, r0, r8, asr lr
30001e04:	30003e64 	andcc	r3, r0, r4, ror #28

30001e08 <random_st>:
uint random_st()
{
	return (newrandom - userandom)&0xf;
30001e08:	e59f3014 	ldr	r3, [pc, #20]	; 30001e24 <.text+0x1e24>
30001e0c:	e5930000 	ldr	r0, [r3]
30001e10:	e59f3010 	ldr	r3, [pc, #16]	; 30001e28 <.text+0x1e28>
30001e14:	e5933000 	ldr	r3, [r3]
30001e18:	e0630000 	rsb	r0, r3, r0
30001e1c:	e200000f 	and	r0, r0, #15	; 0xf
}
30001e20:	e1a0f00e 	mov	pc, lr
30001e24:	30003e58 	andcc	r3, r0, r8, asr lr
30001e28:	30003e5c 	andcc	r3, r0, ip, asr lr

30001e2c <test_random>:
void test_random()
{
30001e2c:	e52de004 	str	lr, [sp, #-4]!
	lprint("ready pointer is 0x%x, now to use is 0x%x\r\n", newrandom&0xf, userandom&0xf);
30001e30:	e59f3028 	ldr	r3, [pc, #40]	; 30001e60 <.text+0x1e60>
30001e34:	e5931000 	ldr	r1, [r3]
30001e38:	e59f3024 	ldr	r3, [pc, #36]	; 30001e64 <.text+0x1e64>
30001e3c:	e5932000 	ldr	r2, [r3]
30001e40:	e201100f 	and	r1, r1, #15	; 0xf
30001e44:	e202200f 	and	r2, r2, #15	; 0xf
30001e48:	e59f0018 	ldr	r0, [pc, #24]	; 30001e68 <.text+0x1e68>
30001e4c:	ebfffdcc 	bl	30001584 <lprint>
	print_mem(random, 32);
30001e50:	e59f0014 	ldr	r0, [pc, #20]	; 30001e6c <.text+0x1e6c>
30001e54:	e3a01020 	mov	r1, #32	; 0x20
30001e58:	e49de004 	ldr	lr, [sp], #4
30001e5c:	eafffa8f 	b	300008a0 <print_mem>
30001e60:	30003e58 	andcc	r3, r0, r8, asr lr
30001e64:	30003e5c 	andcc	r3, r0, ip, asr lr
30001e68:	30003bbc 	strcch	r3, [r0], -ip
30001e6c:	30003e64 	andcc	r3, r0, r4, ror #28

30001e70 <irq_handle>:
}

void irq_handle()
{
30001e70:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	lprint("\r\n---Entering IRQ---\r\nSRCPND = 0x%x\r\nINTPND = 0x%x\r\n", SRCPND, INTPND);
30001e74:	e59f5034 	ldr	r5, [pc, #52]	; 30001eb0 <.text+0x1eb0>
30001e78:	e3a0444a 	mov	r4, #1241513984	; 0x4a000000
30001e7c:	e5941000 	ldr	r1, [r4]
30001e80:	e59f002c 	ldr	r0, [pc, #44]	; 30001eb4 <.text+0x1eb4>
30001e84:	e5952000 	ldr	r2, [r5]
30001e88:	ebfffdbd 	bl	30001584 <lprint>
	INTPND = INTPND;
30001e8c:	e5953000 	ldr	r3, [r5]
30001e90:	e5853000 	str	r3, [r5]
	SRCPND = SRCPND;
30001e94:	e5943000 	ldr	r3, [r4]
30001e98:	e5843000 	str	r3, [r4]
	lprint("after clear:\r\nSRCPND = 0x%x\r\nINTPND = 0x%x\r\n--- Return IRQ ---", SRCPND, INTPND);
30001e9c:	e59f0014 	ldr	r0, [pc, #20]	; 30001eb8 <.text+0x1eb8>
30001ea0:	e5941000 	ldr	r1, [r4]
30001ea4:	e5952000 	ldr	r2, [r5]
30001ea8:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
30001eac:	eafffdb4 	b	30001584 <lprint>
30001eb0:	4a000010 	bmi	30001ef8 <for_check+0x3c>
30001eb4:	30003be8 	andcc	r3, r0, r8, ror #23
30001eb8:	30003c20 	andcc	r3, r0, r0, lsr #24

30001ebc <for_check>:
static unsigned short ipid = 1;

unsigned short for_check(unsigned char *crcdata,uint len)
{
        unsigned short *t,sum=0,new_sum;
30001ebc:	e3a02000 	mov	r2, #0	; 0x0
        uint jw=0,i;

        t = (unsigned short *)crcdata;
    	for(i=0;i<len/2;i++){
30001ec0:	e1a010a1 	mov	r1, r1, lsr #1
30001ec4:	e1520001 	cmp	r2, r1
30001ec8:	e52de004 	str	lr, [sp, #-4]!
30001ecc:	e1a0c002 	mov	ip, r2
30001ed0:	e1a0e002 	mov	lr, r2
30001ed4:	2a00000a 	bcs	30001f04 <for_check+0x48>
                new_sum = *t + sum;
30001ed8:	e1d030b0 	ldrh	r3, [r0]
30001edc:	e0823003 	add	r3, r2, r3
30001ee0:	e1a03803 	mov	r3, r3, lsl #16
30001ee4:	e1a03823 	mov	r3, r3, lsr #16
                if(new_sum<sum)jw++;
30001ee8:	e1530002 	cmp	r3, r2
30001eec:	e28cc001 	add	ip, ip, #1	; 0x1
30001ef0:	328ee001 	addcc	lr, lr, #1	; 0x1
                sum=new_sum;
30001ef4:	e15c0001 	cmp	ip, r1
30001ef8:	e1a02003 	mov	r2, r3
30001efc:	e2800002 	add	r0, r0, #2	; 0x2
30001f00:	3afffff4 	bcc	30001ed8 <for_check+0x1c>
                t++;
        }
    	sum+=jw;
30001f04:	e082300e 	add	r3, r2, lr
30001f08:	e1a03803 	mov	r3, r3, lsl #16
        sum=~sum;
30001f0c:	e1e03823 	mvn	r3, r3, lsr #16
30001f10:	e1a03803 	mov	r3, r3, lsl #16
30001f14:	e1a02823 	mov	r2, r3, lsr #16
        //*(unsigned int xdata*)crccode = sum;
        return sum;
}
30001f18:	e1a00002 	mov	r0, r2
30001f1c:	e49df004 	ldr	pc, [sp], #4

30001f20 <lstrlen>:

uint lstrlen(unsigned char*s)
{
	uint l = 0;
	while(*s++)
30001f20:	e4d03001 	ldrb	r3, [r0], #1
30001f24:	e3530000 	cmp	r3, #0	; 0x0
30001f28:	e3a02000 	mov	r2, #0	; 0x0
30001f2c:	0a000003 	beq	30001f40 <lstrlen+0x20>
		l++;
30001f30:	e4d03001 	ldrb	r3, [r0], #1
30001f34:	e3530000 	cmp	r3, #0	; 0x0
30001f38:	e2822001 	add	r2, r2, #1	; 0x1
30001f3c:	1afffffb 	bne	30001f30 <lstrlen+0x10>
	return l;
}
30001f40:	e1a00002 	mov	r0, r2
30001f44:	e1a0f00e 	mov	pc, lr

30001f48 <lmemequ>:

uint lmemequ(unsigned char *a, unsigned char * b, uint len)
{
	while(len--)
30001f48:	e242c001 	sub	ip, r2, #1	; 0x1
30001f4c:	e37c0001 	cmn	ip, #1	; 0x1
30001f50:	0a000007 	beq	30001f74 <lmemequ+0x2c>
		if(*a++ != *b++)
30001f54:	e4d02001 	ldrb	r2, [r0], #1
30001f58:	e4d13001 	ldrb	r3, [r1], #1
30001f5c:	e1520003 	cmp	r2, r3
30001f60:	e24cc001 	sub	ip, ip, #1	; 0x1
30001f64:	13a00000 	movne	r0, #0	; 0x0
			return 0;
	return 1;
}
30001f68:	11a0f00e 	movne	pc, lr
30001f6c:	e37c0001 	cmn	ip, #1	; 0x1
30001f70:	1afffff7 	bne	30001f54 <lmemequ+0xc>
30001f74:	e3a00001 	mov	r0, #1	; 0x1
30001f78:	e1a0f00e 	mov	pc, lr

30001f7c <lstrcpy>:

void lstrcpy(unsigned char *d, unsigned char*s)
{
	while(*d++ = *s++);
30001f7c:	e4d13001 	ldrb	r3, [r1], #1
30001f80:	e3530000 	cmp	r3, #0	; 0x0
30001f84:	e4c03001 	strb	r3, [r0], #1
30001f88:	01a0f00e 	moveq	pc, lr
30001f8c:	eafffffa 	b	30001f7c <lstrcpy>

30001f90 <change_end>:
}

unsigned short change_end(unsigned short a)
{
30001f90:	e1a03800 	mov	r3, r0, lsl #16
30001f94:	e1a03823 	mov	r3, r3, lsr #16
	return ((0xff & a)<<8) + ((0xff00 & a)>>8);
30001f98:	e1a00423 	mov	r0, r3, lsr #8
30001f9c:	e1a00800 	mov	r0, r0, lsl #16
30001fa0:	e1800c03 	orr	r0, r0, r3, lsl #24
30001fa4:	e1a00820 	mov	r0, r0, lsr #16
}	
30001fa8:	e1a0f00e 	mov	pc, lr

30001fac <tftp_put>:

void tftp_put(unsigned char* name, uint sz, unsigned char *buf)
{
30001fac:	e92d4010 	stmdb	sp!, {r4, lr}
	/*init t_s*/
	t_s.block_n = 0;
30001fb0:	e59f302c 	ldr	r3, [pc, #44]	; 30001fe4 <.text+0x1fe4>
30001fb4:	e3a0e000 	mov	lr, #0	; 0x0
	t_s.filename = name;
	t_s.membase = buf;
	t_s.operation = 0;//put file to server
	t_s.filesize = sz;
	t_s.max_block = (t_s.filesize>>9) + 1;
30001fb8:	e1a0c4a1 	mov	ip, r1, lsr #9
30001fbc:	e28cc001 	add	ip, ip, #1	; 0x1
30001fc0:	e1a0400e 	mov	r4, lr
30001fc4:	e1c3c0ba 	strh	ip, [r3, #10]
30001fc8:	e1c3e0b8 	strh	lr, [r3, #8]
30001fcc:	e583000c 	str	r0, [r3, #12]
30001fd0:	e5832010 	str	r2, [r3, #16]
30001fd4:	e5c3e015 	strb	lr, [r3, #21]
30001fd8:	e5831000 	str	r1, [r3]
	tftp_run();
30001fdc:	e8bd4010 	ldmia	sp!, {r4, lr}
30001fe0:	ea000240 	b	300028e8 <tftp_run>
30001fe4:	30003e84 	andcc	r3, r0, r4, lsl #29

30001fe8 <tftp_get>:
}
	
void tftp_get(unsigned char* name, unsigned char *buf)
{
	/*init t_s*/
	t_s.block_n = 1;
30001fe8:	e59f3014 	ldr	r3, [pc, #20]	; 30002004 <.text+0x2004>
30001fec:	e3a02001 	mov	r2, #1	; 0x1
	t_s.filename = name;
	t_s.membase = buf;
	t_s.operation = 1;//get file from server
30001ff0:	e5c32015 	strb	r2, [r3, #21]
30001ff4:	e583000c 	str	r0, [r3, #12]
30001ff8:	e5831010 	str	r1, [r3, #16]
30001ffc:	e1c320b8 	strh	r2, [r3, #8]
	tftp_run();
30002000:	ea000238 	b	300028e8 <tftp_run>
30002004:	30003e84 	andcc	r3, r0, r4, lsl #29

30002008 <setup_arp_req>:
}

static void setup_arp_req(unsigned char * buf)
{
30002008:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
	struct eth_h* tmp_ep = (struct eth_h*)buf;
	struct arp_p *arp_p_p = (struct arp_p *)tmp_ep->datas;
	/*clear buffer*/
	lmemset(buf, 0, 60);
3000200c:	e3a01000 	mov	r1, #0	; 0x0
30002010:	e1a04000 	mov	r4, r0
30002014:	e3a0203c 	mov	r2, #60	; 0x3c
	/*set 802.3 header*/
	lmemset(tmp_ep->dest_mac, 0xff, 6);
	lmemcpy(tmp_ep->src_mac, cs8900_mac, 6);
30002018:	e59f70a4 	ldr	r7, [pc, #164]	; 300020c4 <.text+0x20c4>
3000201c:	ebfffb6c 	bl	30000dd4 <lmemset>
30002020:	e1a00004 	mov	r0, r4
30002024:	e3a010ff 	mov	r1, #255	; 0xff
30002028:	e3a02006 	mov	r2, #6	; 0x6
3000202c:	ebfffb68 	bl	30000dd4 <lmemset>
30002030:	e2840006 	add	r0, r4, #6	; 0x6
30002034:	e1a01007 	mov	r1, r7
30002038:	e3a02006 	mov	r2, #6	; 0x6
3000203c:	ebfffb59 	bl	30000da8 <lmemcpy>
	tmp_ep->protocol = 0x0608;
30002040:	e59f3080 	ldr	r3, [pc, #128]	; 300020c8 <.text+0x20c8>
30002044:	e284200e 	add	r2, r4, #14	; 0xe
30002048:	e1c430bc 	strh	r3, [r4, #12]
	/*setup arp package*/
	arp_p_p->hardware = 0x100;
3000204c:	e3a0cc01 	mov	ip, #256	; 0x100
	arp_p_p->protocol = 0x08;
30002050:	e3a03008 	mov	r3, #8	; 0x8
    	arp_p_p->hardware_addr_len = 6;
30002054:	e3a05006 	mov	r5, #6	; 0x6
    	arp_p_p->protocol_addr_len = 4;
30002058:	e3a06004 	mov	r6, #4	; 0x4
3000205c:	e1c230b2 	strh	r3, [r2, #2]
    	arp_p_p->operation = 0x100;
30002060:	e1c2c0b6 	strh	ip, [r2, #6]
30002064:	e1c4c0be 	strh	ip, [r4, #14]
	lmemcpy(arp_p_p->sender_mac, cs8900_mac, 6);
30002068:	e2840016 	add	r0, r4, #22	; 0x16
3000206c:	e1a01007 	mov	r1, r7
30002070:	e5c25004 	strb	r5, [r2, #4]
30002074:	e5c26005 	strb	r6, [r2, #5]
30002078:	e1a02005 	mov	r2, r5
3000207c:	ebfffb49 	bl	30000da8 <lmemcpy>
	lmemset(arp_p_p->target_mac, 0x0, 6);
30002080:	e2840020 	add	r0, r4, #32	; 0x20
30002084:	e1a02005 	mov	r2, r5
30002088:	e3a01000 	mov	r1, #0	; 0x0
3000208c:	ebfffb50 	bl	30000dd4 <lmemset>
    	lmemcpy(arp_p_p->sender_ip, &local_ip, 4);
30002090:	e284001c 	add	r0, r4, #28	; 0x1c
30002094:	e59f1030 	ldr	r1, [pc, #48]	; 300020cc <.text+0x20cc>
30002098:	e1a02006 	mov	r2, r6
    	lmemcpy(arp_p_p->target_ip, &server_ip, 4);
3000209c:	e2844026 	add	r4, r4, #38	; 0x26
300020a0:	ebfffb40 	bl	30000da8 <lmemcpy>
300020a4:	e1a02006 	mov	r2, r6
300020a8:	e1a00004 	mov	r0, r4
300020ac:	e59f101c 	ldr	r1, [pc, #28]	; 300020d0 <.text+0x20d0>
300020b0:	ebfffb3c 	bl	30000da8 <lmemcpy>
	send_len = 60;
300020b4:	e59f3018 	ldr	r3, [pc, #24]	; 300020d4 <.text+0x20d4>
300020b8:	e3a0203c 	mov	r2, #60	; 0x3c
300020bc:	e5832000 	str	r2, [r3]
300020c0:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
300020c4:	30002e70 	andcc	r2, r0, r0, ror lr
300020c8:	00000608 	andeq	r0, r0, r8, lsl #12
300020cc:	30003e18 	andcc	r3, r0, r8, lsl lr
300020d0:	30003e1c 	andcc	r3, r0, ip, lsl lr
300020d4:	30004ac4 	andcc	r4, r0, r4, asr #21

300020d8 <anlz_arq>:
}
	
uint anlz_arq()
{
300020d8:	e92d4010 	stmdb	sp!, {r4, lr}
	struct arp_p *arp_p_p = (struct arp_p *)rep->datas;
300020dc:	e59f305c 	ldr	r3, [pc, #92]	; 30002140 <.text+0x2140>
300020e0:	e5934000 	ldr	r4, [r3]
	if(rep->protocol != 0x0608 || arp_p_p->operation != 0x0200 \
300020e4:	e59f3058 	ldr	r3, [pc, #88]	; 30002144 <.text+0x2144>
300020e8:	e1d420bc 	ldrh	r2, [r4, #12]
300020ec:	e1520003 	cmp	r2, r3
300020f0:	e284300e 	add	r3, r4, #14	; 0xe
300020f4:	1a00000c 	bne	3000212c <anlz_arq+0x54>
300020f8:	e1d330b6 	ldrh	r3, [r3, #6]
300020fc:	e3530c02 	cmp	r3, #512	; 0x200
30002100:	e59f1040 	ldr	r1, [pc, #64]	; 30002148 <.text+0x2148>
30002104:	e284001c 	add	r0, r4, #28	; 0x1c
30002108:	e3a02004 	mov	r2, #4	; 0x4
3000210c:	1a000006 	bne	3000212c <anlz_arq+0x54>
30002110:	ebffff8c 	bl	30001f48 <lmemequ>
30002114:	e1a03000 	mov	r3, r0
30002118:	e3530000 	cmp	r3, #0	; 0x0
3000211c:	e59f0028 	ldr	r0, [pc, #40]	; 3000214c <.text+0x214c>
30002120:	e2841016 	add	r1, r4, #22	; 0x16
30002124:	e3a02006 	mov	r2, #6	; 0x6
30002128:	1a000001 	bne	30002134 <anlz_arq+0x5c>
				|| !lmemequ(arp_p_p->sender_ip, (unsigned char*)&server_ip, 4))
		return 0;//failed
3000212c:	e3a00000 	mov	r0, #0	; 0x0
	lmemcpy(server_mac, arp_p_p->sender_mac, 6);
	return 1;
}
30002130:	e8bd8010 	ldmia	sp!, {r4, pc}
30002134:	ebfffb1b 	bl	30000da8 <lmemcpy>
30002138:	e3a00001 	mov	r0, #1	; 0x1
3000213c:	e8bd8010 	ldmia	sp!, {r4, pc}
30002140:	30003e28 	andcc	r3, r0, r8, lsr #28
30002144:	00000608 	andeq	r0, r0, r8, lsl #12
30002148:	30003e1c 	andcc	r3, r0, ip, lsl lr
3000214c:	30004ab4 	strcch	r4, [r0], -r4

30002150 <recv_p>:

uint recv_p()
{
30002150:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
	struct eth_h*tmp_ep = (struct eth_h*)rsp_arp_buf;
	struct arp_p *arp_p_p = (struct arp_p *)rep->datas, *rsp_arp = (struct arp_p *)tmp_ep->datas;
30002154:	e59f70e4 	ldr	r7, [pc, #228]	; 30002240 <.text+0x2240>
	uint len;

	len = cs8900_recv(r_buf);
30002158:	e59f00e4 	ldr	r0, [pc, #228]	; 30002244 <.text+0x2244>
3000215c:	e5974000 	ldr	r4, [r7]
30002160:	ebfffc42 	bl	30001270 <cs8900_recv>
	if(!len)
30002164:	e3500000 	cmp	r0, #0	; 0x0
30002168:	e284100e 	add	r1, r4, #14	; 0xe
3000216c:	e59f50d4 	ldr	r5, [pc, #212]	; 30002248 <.text+0x2248>
30002170:	08bd80f0 	ldmeqia	sp!, {r4, r5, r6, r7, pc}
		return 0;
	if(rep->protocol == 0x0608 && arp_p_p->operation == 0x0100){
30002174:	e5973000 	ldr	r3, [r7]
30002178:	e1d320bc 	ldrh	r2, [r3, #12]
3000217c:	e59f30c8 	ldr	r3, [pc, #200]	; 3000224c <.text+0x224c>
30002180:	e1520003 	cmp	r2, r3
30002184:	18bd80f0 	ldmneia	sp!, {r4, r5, r6, r7, pc}
30002188:	e1d130b6 	ldrh	r3, [r1, #6]
3000218c:	e3530c01 	cmp	r3, #256	; 0x100
30002190:	18bd80f0 	ldmneia	sp!, {r4, r5, r6, r7, pc}
		if( lmemequ(arp_p_p->target_ip, &local_ip, 4)
30002194:	e2840026 	add	r0, r4, #38	; 0x26
30002198:	e59f10b0 	ldr	r1, [pc, #176]	; 30002250 <.text+0x2250>
3000219c:	e3a02004 	mov	r2, #4	; 0x4
300021a0:	ebffff68 	bl	30001f48 <lmemequ>
300021a4:	e3500000 	cmp	r0, #0	; 0x0
300021a8:	0a000022 	beq	30002238 <recv_p+0xe8>
300021ac:	e284601c 	add	r6, r4, #28	; 0x1c
300021b0:	e59f109c 	ldr	r1, [pc, #156]	; 30002254 <.text+0x2254>
300021b4:	e1a00006 	mov	r0, r6
300021b8:	e3a02004 	mov	r2, #4	; 0x4
300021bc:	ebffff61 	bl	30001f48 <lmemequ>
300021c0:	e3500000 	cmp	r0, #0	; 0x0
300021c4:	0a00001b 	beq	30002238 <recv_p+0xe8>
		    && lmemequ(arp_p_p->sender_ip, &server_ip, 4)){
			setup_arp_req(rsp_arp_buf);
300021c8:	e245000e 	sub	r0, r5, #14	; 0xe
300021cc:	ebffff8d 	bl	30002008 <setup_arp_req>
			lmemcpy(tmp_ep->dest_mac, rep->src_mac, 6);
300021d0:	e5971000 	ldr	r1, [r7]
300021d4:	e3a02006 	mov	r2, #6	; 0x6
300021d8:	e2811006 	add	r1, r1, #6	; 0x6
300021dc:	e245000e 	sub	r0, r5, #14	; 0xe
300021e0:	ebfffaf0 	bl	30000da8 <lmemcpy>
    			rsp_arp->operation = 0x200;
300021e4:	e3a03c02 	mov	r3, #512	; 0x200
			lmemcpy(rsp_arp->target_mac, arp_p_p->sender_mac, 6);
300021e8:	e2841016 	add	r1, r4, #22	; 0x16
300021ec:	e3a02006 	mov	r2, #6	; 0x6
300021f0:	e2850012 	add	r0, r5, #18	; 0x12
300021f4:	e1c530b6 	strh	r3, [r5, #6]
300021f8:	ebfffaea 	bl	30000da8 <lmemcpy>
    			lmemcpy(rsp_arp->target_ip, arp_p_p->sender_ip, 4);
300021fc:	e1a01006 	mov	r1, r6
30002200:	e3a02004 	mov	r2, #4	; 0x4
30002204:	e2850018 	add	r0, r5, #24	; 0x18
30002208:	ebfffae6 	bl	30000da8 <lmemcpy>
			if(cs8900_send(rsp_arp_buf, 60) != 60)
3000220c:	e245000e 	sub	r0, r5, #14	; 0xe
30002210:	e3a0103c 	mov	r1, #60	; 0x3c
30002214:	ebfffc2e 	bl	300012d4 <cs8900_send>
30002218:	e350003c 	cmp	r0, #60	; 0x3c
3000221c:	0a000002 	beq	3000222c <recv_p+0xdc>
				lprint("answer asp failed!\r\n");
30002220:	e59f0030 	ldr	r0, [pc, #48]	; 30002258 <.text+0x2258>
30002224:	ebfffcd6 	bl	30001584 <lprint>
30002228:	ea000001 	b	30002234 <recv_p+0xe4>
			else
				lprint("recv asp and answered\r\n");
3000222c:	e59f0028 	ldr	r0, [pc, #40]	; 3000225c <.text+0x225c>
30002230:	ebfffcd3 	bl	30001584 <lprint>
			while(1);
30002234:	eafffffe 	b	30002234 <recv_p+0xe4>
		}
		return 0;
30002238:	e3a00000 	mov	r0, #0	; 0x0
	}
	return len;
}
3000223c:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
30002240:	30003e28 	andcc	r3, r0, r8, lsr #28
30002244:	300044c6 	andcc	r4, r0, r6, asr #9
30002248:	30003eaa 	andcc	r3, r0, sl, lsr #29
3000224c:	00000608 	andeq	r0, r0, r8, lsl #12
30002250:	30003e18 	andcc	r3, r0, r8, lsl lr
30002254:	30003e1c 	andcc	r3, r0, ip, lsl lr
30002258:	30003c60 	andcc	r3, r0, r0, ror #24
3000225c:	30003c78 	andcc	r3, r0, r8, ror ip

30002260 <get_response>:
	
uint get_response(uint (*anlz)(), uint try)
{
30002260:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
30002264:	e1a07000 	mov	r7, r0
30002268:	e1a06001 	mov	r6, r1
	uint len, wait;
	
send:
        len = cs8900_send(s_buf, send_len);
3000226c:	e59f40a8 	ldr	r4, [pc, #168]	; 3000231c <.text+0x231c>
30002270:	e59f00a8 	ldr	r0, [pc, #168]	; 30002320 <.text+0x2320>
30002274:	e5941000 	ldr	r1, [r4]
30002278:	ebfffc15 	bl	300012d4 <cs8900_send>
        if(len != send_len){
3000227c:	e5943000 	ldr	r3, [r4]
30002280:	e1500003 	cmp	r0, r3
30002284:	e1a05000 	mov	r5, r0
30002288:	0a000003 	beq	3000229c <get_response+0x3c>
                lprint("send packages error\r\n");
3000228c:	e59f0090 	ldr	r0, [pc, #144]	; 30002324 <.text+0x2324>
30002290:	ebfffcbb 	bl	30001584 <lprint>
                return 0;
30002294:	e3a00000 	mov	r0, #0	; 0x0
        }
try_recv:
        wait = 300;
        while(!(len = recv_p())){
                delay_us(10000);
                if(!wait--)
                        break;
        }
        if(!len){
		if(try--){
                	lprint("no response, retrying\r\n");
        	        delay_us(1000000);
       		        goto send;
		}
		else{
                	lprint("give up.\r\n");
			return 0;
		}
        }
        if(!(*anlz)())
                goto try_recv;
	return 1;
}	
30002298:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
3000229c:	e3a04f4b 	mov	r4, #300	; 0x12c
300022a0:	ea000002 	b	300022b0 <get_response+0x50>
300022a4:	ebfffb8c 	bl	300010dc <delay_us>
300022a8:	e3740001 	cmn	r4, #1	; 0x1
300022ac:	0a000006 	beq	300022cc <get_response+0x6c>
300022b0:	ebffffa6 	bl	30002150 <recv_p>
300022b4:	e1a05000 	mov	r5, r0
300022b8:	e3550000 	cmp	r5, #0	; 0x0
300022bc:	e2444001 	sub	r4, r4, #1	; 0x1
300022c0:	e59f0060 	ldr	r0, [pc, #96]	; 30002328 <.text+0x2328>
300022c4:	0afffff6 	beq	300022a4 <get_response+0x44>
300022c8:	ea00000d 	b	30002304 <get_response+0xa4>
300022cc:	e3550000 	cmp	r5, #0	; 0x0
300022d0:	1a00000b 	bne	30002304 <get_response+0xa4>
300022d4:	e2466001 	sub	r6, r6, #1	; 0x1
300022d8:	e3760001 	cmn	r6, #1	; 0x1
300022dc:	0a000004 	beq	300022f4 <get_response+0x94>
300022e0:	e59f0044 	ldr	r0, [pc, #68]	; 3000232c <.text+0x232c>
300022e4:	ebfffca6 	bl	30001584 <lprint>
300022e8:	e59f0040 	ldr	r0, [pc, #64]	; 30002330 <.text+0x2330>
300022ec:	ebfffb7a 	bl	300010dc <delay_us>
300022f0:	eaffffdd 	b	3000226c <get_response+0xc>
300022f4:	e59f0038 	ldr	r0, [pc, #56]	; 30002334 <.text+0x2334>
300022f8:	ebfffca1 	bl	30001584 <lprint>
300022fc:	e1a00005 	mov	r0, r5
30002300:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
30002304:	e1a0e00f 	mov	lr, pc
30002308:	e1a0f007 	mov	pc, r7
3000230c:	e3500000 	cmp	r0, #0	; 0x0
30002310:	13a00001 	movne	r0, #1	; 0x1
30002314:	18bd80f0 	ldmneia	sp!, {r4, r5, r6, r7, pc}
30002318:	eaffffdf 	b	3000229c <get_response+0x3c>
3000231c:	30004ac4 	andcc	r4, r0, r4, asr #21
30002320:	30003ed8 	ldrccd	r3, [r0], -r8
30002324:	30003c90 	mulcc	r0, r0, ip
30002328:	00002710 	andeq	r2, r0, r0, lsl r7
3000232c:	30003ca8 	andcc	r3, r0, r8, lsr #25
30002330:	000f4240 	andeq	r4, pc, r0, asr #4
30002334:	30003cc0 	andcc	r3, r0, r0, asr #25

30002338 <setup_tftp_package>:

void setup_tftp_package()
{
30002338:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
	unsigned char * s;
	unsigned short local_port, udp_len, data_len;

	/*setup tftp req package*/
	lmemset(s_buf, 0, MAX_PACKAGE);
3000233c:	e3a01000 	mov	r1, #0	; 0x0
30002340:	e59f235c 	ldr	r2, [pc, #860]	; 300026a4 <.text+0x26a4>
	lmemcpy(s_buf, tftp_req, 64);
	/*set 802.3 header*/
	lmemcpy(sep->dest_mac, server_mac, 6);
30002344:	e59f535c 	ldr	r5, [pc, #860]	; 300026a8 <.text+0x26a8>
30002348:	e59f035c 	ldr	r0, [pc, #860]	; 300026ac <.text+0x26ac>
3000234c:	ebfffaa0 	bl	30000dd4 <lmemset>
30002350:	e59f1358 	ldr	r1, [pc, #856]	; 300026b0 <.text+0x26b0>
30002354:	e3a02040 	mov	r2, #64	; 0x40
30002358:	e59f034c 	ldr	r0, [pc, #844]	; 300026ac <.text+0x26ac>
3000235c:	ebfffa91 	bl	30000da8 <lmemcpy>
30002360:	e59f134c 	ldr	r1, [pc, #844]	; 300026b4 <.text+0x26b4>
30002364:	e3a02006 	mov	r2, #6	; 0x6
30002368:	e5950000 	ldr	r0, [r5]
3000236c:	ebfffa8d 	bl	30000da8 <lmemcpy>
	lmemcpy(sep->src_mac, cs8900_mac, 6);
30002370:	e5950000 	ldr	r0, [r5]

    	lmemcpy(siutp->ip_header.sender_ip, &local_ip, 4);
30002374:	e59f633c 	ldr	r6, [pc, #828]	; 300026b8 <.text+0x26b8>
30002378:	e59f133c 	ldr	r1, [pc, #828]	; 300026bc <.text+0x26bc>
3000237c:	e3a02006 	mov	r2, #6	; 0x6
30002380:	e2800006 	add	r0, r0, #6	; 0x6
30002384:	ebfffa87 	bl	30000da8 <lmemcpy>
30002388:	e5960000 	ldr	r0, [r6]
3000238c:	e59f132c 	ldr	r1, [pc, #812]	; 300026c0 <.text+0x26c0>
30002390:	e3a02004 	mov	r2, #4	; 0x4
30002394:	e280000c 	add	r0, r0, #12	; 0xc
30002398:	ebfffa82 	bl	30000da8 <lmemcpy>
    	lmemcpy(siutp->ip_header.target_ip, &server_ip, 4);
3000239c:	e5960000 	ldr	r0, [r6]
300023a0:	e59f131c 	ldr	r1, [pc, #796]	; 300026c4 <.text+0x26c4>
300023a4:	e3a02004 	mov	r2, #4	; 0x4
300023a8:	e2800010 	add	r0, r0, #16	; 0x10
300023ac:	ebfffa7d 	bl	30000da8 <lmemcpy>
    	siutp->udp_header.check_sum = 0;
300023b0:	e5963000 	ldr	r3, [r6]
300023b4:	e3a01000 	mov	r1, #0	; 0x0
300023b8:	e1c311ba 	strh	r1, [r3, #26]
	siutp->udp_header.dest_port = change_end(t_s.server_port);
300023bc:	e59f7304 	ldr	r7, [pc, #772]	; 300026c8 <.text+0x26c8>
300023c0:	e1d700b6 	ldrh	r0, [r7, #6]
300023c4:	ebfffef1 	bl	30001f90 <change_end>
300023c8:	e5964000 	ldr	r4, [r6]
300023cc:	e1c401b6 	strh	r0, [r4, #22]
	if(t_s.running == 0){
300023d0:	e5d73014 	ldrb	r3, [r7, #20]
300023d4:	e3530000 	cmp	r3, #0	; 0x0
300023d8:	1a000043 	bne	300024ec <setup_tftp_package+0x1b4>
    		local_port = random_u16();
300023dc:	ebfffe77 	bl	30001dc0 <random_u16>
   	 	while(local_port < 2000)
300023e0:	e59f22e4 	ldr	r2, [pc, #740]	; 300026cc <.text+0x26cc>
300023e4:	e1a00800 	mov	r0, r0, lsl #16
300023e8:	e1a03820 	mov	r3, r0, lsr #16
300023ec:	e1530002 	cmp	r3, r2
300023f0:	8a000004 	bhi	30002408 <setup_tftp_package+0xd0>
			local_port *= 3;
300023f4:	e0833083 	add	r3, r3, r3, lsl #1
300023f8:	e1a03803 	mov	r3, r3, lsl #16
300023fc:	e1a03823 	mov	r3, r3, lsr #16
30002400:	e1530002 	cmp	r3, r2
30002404:	9afffffa 	bls	300023f4 <setup_tftp_package+0xbc>
		t_s.port = local_port;
		siutp->udp_header.src_port = change_end(local_port);
30002408:	e1a00003 	mov	r0, r3
3000240c:	e1c730b4 	strh	r3, [r7, #4]
30002410:	ebfffede 	bl	30001f90 <change_end>
30002414:	e5964000 	ldr	r4, [r6]
30002418:	e1c401b4 	strh	r0, [r4, #20]
    		udp_len = 17 + lstrlen(t_s.filename);
3000241c:	e597000c 	ldr	r0, [r7, #12]
30002420:	ebfffebe 	bl	30001f20 <lstrlen>
30002424:	e2804011 	add	r4, r0, #17	; 0x11
30002428:	e1a04804 	mov	r4, r4, lsl #16
3000242c:	e1a04824 	mov	r4, r4, lsr #16
    		siutp->udp_header.length = change_end(udp_len);
30002430:	e1a00004 	mov	r0, r4
30002434:	ebfffed5 	bl	30001f90 <change_end>
30002438:	e5965000 	ldr	r5, [r6]
		/*setup ip header*/
    		siutp->ip_header.id = change_end(ipid++);
3000243c:	e59f228c 	ldr	r2, [pc, #652]	; 300026d0 <.text+0x26d0>
30002440:	e1c501b8 	strh	r0, [r5, #24]
30002444:	e1d230b0 	ldrh	r3, [r2]
30002448:	e1a00003 	mov	r0, r3
3000244c:	e2833001 	add	r3, r3, #1	; 0x1
30002450:	e1c230b0 	strh	r3, [r2]
30002454:	ebfffecd 	bl	30001f90 <change_end>
    		siutp->ip_header.total_len = change_end(20+udp_len);
30002458:	e2844014 	add	r4, r4, #20	; 0x14
3000245c:	e5965000 	ldr	r5, [r6]
30002460:	e1a04804 	mov	r4, r4, lsl #16
30002464:	e1a04824 	mov	r4, r4, lsr #16
30002468:	e1c500b4 	strh	r0, [r5, #4]
3000246c:	e1a00004 	mov	r0, r4
30002470:	ebfffec6 	bl	30001f90 <change_end>
30002474:	e5964000 	ldr	r4, [r6]
30002478:	e1c400b2 	strh	r0, [r4, #2]
		if(t_s.operation){
3000247c:	e5d73015 	ldrb	r3, [r7, #21]
30002480:	e3530000 	cmp	r3, #0	; 0x0
    			siutp->tftp_packet.operation = change_end(1);
30002484:	13a00001 	movne	r0, #1	; 0x1
		}
		else{
    			siutp->tftp_packet.operation = change_end(2);
30002488:	03a00002 	moveq	r0, #2	; 0x2
3000248c:	ebfffebf 	bl	30001f90 <change_end>
30002490:	e5964000 	ldr	r4, [r6]
30002494:	e1c401bc 	strh	r0, [r4, #28]
		}
		/*setup filename */
    		s = (char*)&siutp->tftp_packet.block_n;
30002498:	e5963000 	ldr	r3, [r6]
3000249c:	e283401e 	add	r4, r3, #30	; 0x1e
    		s = (char*)&siutp->tftp_packet.block_n;
    		lstrcpy(s, t_s.filename);
300024a0:	e597100c 	ldr	r1, [r7, #12]
300024a4:	e1a00004 	mov	r0, r4
300024a8:	ebfffeb3 	bl	30001f7c <lstrcpy>
		s += lstrlen(s) + 1;
300024ac:	e1a00004 	mov	r0, r4
300024b0:	ebfffe9a 	bl	30001f20 <lstrlen>
300024b4:	e0840000 	add	r0, r4, r0
300024b8:	e2804001 	add	r4, r0, #1	; 0x1
	    	lstrcpy(s, "octet");
300024bc:	e1a00004 	mov	r0, r4
300024c0:	e59f120c 	ldr	r1, [pc, #524]	; 300026d4 <.text+0x26d4>
300024c4:	ebfffeac 	bl	30001f7c <lstrcpy>
		send_len = 51 + lstrlen(t_s.filename);
300024c8:	e597000c 	ldr	r0, [r7, #12]
300024cc:	ebfffe93 	bl	30001f20 <lstrlen>
300024d0:	e2800033 	add	r0, r0, #51	; 0x33
300024d4:	e59f51fc 	ldr	r5, [pc, #508]	; 300026d8 <.text+0x26d8>
		if(send_len < 60)
300024d8:	e350003b 	cmp	r0, #59	; 0x3b
300024dc:	93a0303c 	movls	r3, #60	; 0x3c
300024e0:	e5850000 	str	r0, [r5]
300024e4:	95853000 	strls	r3, [r5]
300024e8:	ea000063 	b	3000267c <setup_tftp_package+0x344>
			send_len = 60;
	}
	else if(t_s.operation == 1){
300024ec:	e5d73015 	ldrb	r3, [r7, #21]
300024f0:	e3530001 	cmp	r3, #1	; 0x1
300024f4:	1a00001e 	bne	30002574 <setup_tftp_package+0x23c>
		//setup ack package
		siutp->udp_header.src_port = change_end(t_s.port);
300024f8:	e1d700b4 	ldrh	r0, [r7, #4]
300024fc:	ebfffea3 	bl	30001f90 <change_end>
30002500:	e5964000 	ldr	r4, [r6]
30002504:	e1c401b4 	strh	r0, [r4, #20]
		/*setup ip header*/
		siutp->ip_header.total_len = change_end(32);
30002508:	e3a00020 	mov	r0, #32	; 0x20
3000250c:	ebfffe9f 	bl	30001f90 <change_end>
30002510:	e5964000 	ldr	r4, [r6]
		siutp->ip_header.id = change_end(ipid++);
30002514:	e59f21b4 	ldr	r2, [pc, #436]	; 300026d0 <.text+0x26d0>
30002518:	e1c400b2 	strh	r0, [r4, #2]
3000251c:	e1d230b0 	ldrh	r3, [r2]
30002520:	e1a00003 	mov	r0, r3
30002524:	e2833001 	add	r3, r3, #1	; 0x1
30002528:	e1c230b0 	strh	r3, [r2]
3000252c:	ebfffe97 	bl	30001f90 <change_end>
30002530:	e5964000 	ldr	r4, [r6]
30002534:	e1c400b4 	strh	r0, [r4, #4]
		/*udp & tftp*/
		siutp->udp_header.length = change_end(12);
30002538:	e3a0000c 	mov	r0, #12	; 0xc
3000253c:	ebfffe93 	bl	30001f90 <change_end>
30002540:	e5964000 	ldr	r4, [r6]
30002544:	e1c401b8 	strh	r0, [r4, #24]
		siutp->tftp_packet.operation = 0x400;
30002548:	e5963000 	ldr	r3, [r6]
3000254c:	e3a02b01 	mov	r2, #1024	; 0x400
30002550:	e1c321bc 	strh	r2, [r3, #28]
		siutp->tftp_packet.block_n = change_end(t_s.block_n);
30002554:	e1d700b8 	ldrh	r0, [r7, #8]
30002558:	ebfffe8c 	bl	30001f90 <change_end>
3000255c:	e5963000 	ldr	r3, [r6]
30002560:	e1c301be 	strh	r0, [r3, #30]

		send_len = 60;
30002564:	e59f316c 	ldr	r3, [pc, #364]	; 300026d8 <.text+0x26d8>
30002568:	e3a0203c 	mov	r2, #60	; 0x3c
3000256c:	e5832000 	str	r2, [r3]
30002570:	ea000041 	b	3000267c <setup_tftp_package+0x344>
		
	}
	else if(t_s.operation == 0){
30002574:	e3530000 	cmp	r3, #0	; 0x0
30002578:	1a00003f 	bne	3000267c <setup_tftp_package+0x344>
		data_len = (t_s.filesize > 512)?512:t_s.filesize;		
3000257c:	e5974000 	ldr	r4, [r7]
30002580:	e3540c02 	cmp	r4, #512	; 0x200
30002584:	23a04c02 	movcs	r4, #512	; 0x200
		lmemcpy(siutp->tftp_packet.tftp_data, t_s.membase, data_len);
30002588:	e5960000 	ldr	r0, [r6]
3000258c:	e1a04804 	mov	r4, r4, lsl #16
30002590:	e1a04824 	mov	r4, r4, lsr #16
30002594:	e1a02004 	mov	r2, r4
30002598:	e5971010 	ldr	r1, [r7, #16]
3000259c:	e2800020 	add	r0, r0, #32	; 0x20
300025a0:	ebfffa00 	bl	30000da8 <lmemcpy>
		t_s.membase += data_len;
300025a4:	e5973010 	ldr	r3, [r7, #16]
		t_s.filesize -= data_len;
300025a8:	e597c000 	ldr	ip, [r7]
300025ac:	e0833004 	add	r3, r3, r4
300025b0:	e064c00c 	rsb	ip, r4, ip
		/*set 802.3 header*/
		lmemcpy(sep->dest_mac, server_mac, 6);
300025b4:	e5950000 	ldr	r0, [r5]
300025b8:	e59f10f4 	ldr	r1, [pc, #244]	; 300026b4 <.text+0x26b4>
300025bc:	e3a02006 	mov	r2, #6	; 0x6
300025c0:	e587c000 	str	ip, [r7]
300025c4:	e5873010 	str	r3, [r7, #16]
300025c8:	ebfff9f6 	bl	30000da8 <lmemcpy>
		lmemcpy(sep->src_mac, cs8900_mac, 6);
300025cc:	e5950000 	ldr	r0, [r5]
300025d0:	e59f10e4 	ldr	r1, [pc, #228]	; 300026bc <.text+0x26bc>
300025d4:	e3a02006 	mov	r2, #6	; 0x6
300025d8:	e2800006 	add	r0, r0, #6	; 0x6
300025dc:	ebfff9f1 	bl	30000da8 <lmemcpy>

		siutp->udp_header.src_port = change_end(t_s.port);
300025e0:	e1d700b4 	ldrh	r0, [r7, #4]
300025e4:	ebfffe69 	bl	30001f90 <change_end>
300025e8:	e5965000 	ldr	r5, [r6]
300025ec:	e1a03000 	mov	r3, r0
		/*setup ip header*/
		siutp->ip_header.total_len = change_end(32 + data_len);
300025f0:	e2840020 	add	r0, r4, #32	; 0x20
300025f4:	e1a00800 	mov	r0, r0, lsl #16
300025f8:	e1c531b4 	strh	r3, [r5, #20]
300025fc:	e1a00820 	mov	r0, r0, lsr #16
30002600:	ebfffe62 	bl	30001f90 <change_end>
30002604:	e5965000 	ldr	r5, [r6]
		siutp->ip_header.id = change_end(ipid++);
30002608:	e59f20c0 	ldr	r2, [pc, #192]	; 300026d0 <.text+0x26d0>
3000260c:	e1c500b2 	strh	r0, [r5, #2]
30002610:	e1d230b0 	ldrh	r3, [r2]
30002614:	e1a00003 	mov	r0, r3
30002618:	e2833001 	add	r3, r3, #1	; 0x1
3000261c:	e1c230b0 	strh	r3, [r2]
30002620:	ebfffe5a 	bl	30001f90 <change_end>
30002624:	e5965000 	ldr	r5, [r6]
30002628:	e1a03000 	mov	r3, r0
		/*udp & tftp*/
		siutp->udp_header.length = change_end(data_len + 12);		
3000262c:	e284000c 	add	r0, r4, #12	; 0xc
30002630:	e1a00800 	mov	r0, r0, lsl #16
30002634:	e1c530b4 	strh	r3, [r5, #4]
30002638:	e1a00820 	mov	r0, r0, lsr #16
3000263c:	ebfffe53 	bl	30001f90 <change_end>
30002640:	e5965000 	ldr	r5, [r6]
30002644:	e1c501b8 	strh	r0, [r5, #24]
		siutp->tftp_packet.operation = 0x300;
30002648:	e5963000 	ldr	r3, [r6]
3000264c:	e3a01c03 	mov	r1, #768	; 0x300
30002650:	e1c311bc 	strh	r1, [r3, #28]
		siutp->tftp_packet.block_n = change_end(t_s.block_n);
30002654:	e1d700b8 	ldrh	r0, [r7, #8]
30002658:	ebfffe4c 	bl	30001f90 <change_end>

		send_len = 46 + data_len;
3000265c:	e284402e 	add	r4, r4, #46	; 0x2e
30002660:	e5963000 	ldr	r3, [r6]
30002664:	e59f206c 	ldr	r2, [pc, #108]	; 300026d8 <.text+0x26d8>
		if(send_len<60)
30002668:	e354003b 	cmp	r4, #59	; 0x3b
3000266c:	e1c301be 	strh	r0, [r3, #30]
			send_len = 60;
30002670:	93a0303c 	movls	r3, #60	; 0x3c
30002674:	e5824000 	str	r4, [r2]
30002678:	95823000 	strls	r3, [r2]
		
	}
	siutp->ip_header.check_sum = 0;
3000267c:	e59f2034 	ldr	r2, [pc, #52]	; 300026b8 <.text+0x26b8>
30002680:	e5923000 	ldr	r3, [r2]
30002684:	e3a01000 	mov	r1, #0	; 0x0
30002688:	e1c310ba 	strh	r1, [r3, #10]
	siutp->ip_header.check_sum = for_check(&siutp->ip_header.ipv_hdl, 20);
3000268c:	e5924000 	ldr	r4, [r2]
30002690:	e3a01014 	mov	r1, #20	; 0x14
30002694:	e1a00004 	mov	r0, r4
30002698:	ebfffe07 	bl	30001ebc <for_check>
3000269c:	e1c400ba 	strh	r0, [r4, #10]
300026a0:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
300026a4:	000005ee 	andeq	r0, r0, lr, ror #11
300026a8:	30003e24 	andcc	r3, r0, r4, lsr #28
300026ac:	30003ed8 	ldrccd	r3, [r0], -r8
300026b0:	30002e76 	andcc	r2, r0, r6, ror lr
300026b4:	30004ab4 	strcch	r4, [r0], -r4
300026b8:	30004abc 	strcch	r4, [r0], -ip
300026bc:	30002e70 	andcc	r2, r0, r0, ror lr
300026c0:	30003e18 	andcc	r3, r0, r8, lsl lr
300026c4:	30003e1c 	andcc	r3, r0, ip, lsl lr
300026c8:	30003e84 	andcc	r3, r0, r4, lsl #29
300026cc:	000007cf 	andeq	r0, r0, pc, asr #15
300026d0:	30003e2c 	andcc	r3, r0, ip, lsr #28
300026d4:	30003ccc 	andcc	r3, r0, ip, asr #25
300026d8:	30004ac4 	andcc	r4, r0, r4, asr #21

300026dc <anlz_tftp>:
}
	
uint anlz_tftp()
{
300026dc:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
	unsigned short data_len;
	uint tmp;
	if(rep->protocol != 0x0008 || riutp->ip_header.protocol != 0x11 
300026e0:	e59f31dc 	ldr	r3, [pc, #476]	; 300028c4 <.text+0x28c4>
300026e4:	e5933000 	ldr	r3, [r3]
300026e8:	e1d330bc 	ldrh	r3, [r3, #12]
300026ec:	e3530008 	cmp	r3, #8	; 0x8
300026f0:	1a00002a 	bne	300027a0 <anlz_tftp+0xc4>
300026f4:	e59f71cc 	ldr	r7, [pc, #460]	; 300028c8 <.text+0x28c8>
300026f8:	e5974000 	ldr	r4, [r7]
300026fc:	e5d43009 	ldrb	r3, [r4, #9]
30002700:	e3530011 	cmp	r3, #17	; 0x11
30002704:	1a000025 	bne	300027a0 <anlz_tftp+0xc4>
30002708:	e59f51bc 	ldr	r5, [pc, #444]	; 300028cc <.text+0x28cc>
3000270c:	e1d500b4 	ldrh	r0, [r5, #4]
30002710:	ebfffe1e 	bl	30001f90 <change_end>
30002714:	e1d431b6 	ldrh	r3, [r4, #22]
30002718:	e1a00800 	mov	r0, r0, lsl #16
3000271c:	e1530820 	cmp	r3, r0, lsr #16
30002720:	1a00001e 	bne	300027a0 <anlz_tftp+0xc4>
				   || riutp->udp_header.dest_port != change_end(t_s.port))
		return 0;
	if(riutp->tftp_packet.operation == 0x500){
30002724:	e1d431bc 	ldrh	r3, [r4, #28]
30002728:	e3530c05 	cmp	r3, #1280	; 0x500
3000272c:	1a00000a 	bne	3000275c <anlz_tftp+0x80>
		t_s.running = 0;
30002730:	e3a03000 	mov	r3, #0	; 0x0
30002734:	e5c53014 	strb	r3, [r5, #20]
		lprint("Error message from server: code %x, '%s'\r\n", change_end(riutp->tftp_packet.block_n),riutp->tftp_packet.tftp_data); 
30002738:	e1d401be 	ldrh	r0, [r4, #30]
3000273c:	ebfffe13 	bl	30001f90 <change_end>
30002740:	e1a01000 	mov	r1, r0
30002744:	e1a01801 	mov	r1, r1, lsl #16
30002748:	e1a01821 	mov	r1, r1, lsr #16
3000274c:	e2842020 	add	r2, r4, #32	; 0x20
30002750:	e59f0178 	ldr	r0, [pc, #376]	; 300028d0 <.text+0x28d0>
30002754:	ebfffb8a 	bl	30001584 <lprint>
		return 1;
30002758:	ea00004e 	b	30002898 <anlz_tftp+0x1bc>
	}
	t_s.server_port = change_end(riutp->udp_header.src_port);
3000275c:	e1d401b4 	ldrh	r0, [r4, #20]
30002760:	ebfffe0a 	bl	30001f90 <change_end>
	if(t_s.operation){
30002764:	e5d56015 	ldrb	r6, [r5, #21]
30002768:	e1c500b6 	strh	r0, [r5, #6]
3000276c:	e3560000 	cmp	r6, #0	; 0x0
30002770:	e1d431bc 	ldrh	r3, [r4, #28]
30002774:	0a000034 	beq	3000284c <anlz_tftp+0x170>
		//tftp get case
		if(riutp->tftp_packet.operation != 0x300 
30002778:	e3530c03 	cmp	r3, #768	; 0x300
3000277c:	1a000005 	bne	30002798 <anlz_tftp+0xbc>
30002780:	e1d401be 	ldrh	r0, [r4, #30]
30002784:	ebfffe01 	bl	30001f90 <change_end>
30002788:	e1d530b8 	ldrh	r3, [r5, #8]
3000278c:	e1a00800 	mov	r0, r0, lsl #16
30002790:	e1530820 	cmp	r3, r0, lsr #16
30002794:	0a000003 	beq	300027a8 <anlz_tftp+0xcc>
			|| change_end(riutp->tftp_packet.block_n) != t_s.block_n){
			lprint("Unusual error!\r\n");
30002798:	e59f0134 	ldr	r0, [pc, #308]	; 300028d4 <.text+0x28d4>
3000279c:	ebfffb78 	bl	30001584 <lprint>
			return 0;
300027a0:	e3a00000 	mov	r0, #0	; 0x0
		}
		t_s.running = 1;	
		setup_tftp_package();
		data_len = change_end(riutp->udp_header.length) - 12;		
		con_send('.');
		lmemcpy(t_s.membase, riutp->tftp_packet.tftp_data, data_len);
		t_s.membase += 512;
		if(data_len != 512){
			t_s.running = 0;
        		cs8900_send(s_buf, send_len);
			lprint("\r\nfile size:0x%x(%d)\r\n", t_s.filesize = (t_s.block_n-1)*512 + data_len, t_s.filesize);
		}
		t_s.block_n++;
		return 1;
	}
	else{
		//tftp put case
		if(riutp->tftp_packet.operation != 0x400 
			|| change_end(riutp->tftp_packet.block_n) != t_s.block_n){
			lprint("Unusual error!\r\n");
			return 0;
		}
		if(t_s.block_n == t_s.max_block){
			t_s.running = 0;
			lprint("\r\n");
			return 1;
		}
		t_s.running = 1;
		t_s.block_n++;
		con_send('`');
		setup_tftp_package();
		return 1;
	}
	return 0;
}
300027a4:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
300027a8:	e3a06001 	mov	r6, #1	; 0x1
300027ac:	e5c56014 	strb	r6, [r5, #20]
300027b0:	ebfffee0 	bl	30002338 <setup_tftp_package>
300027b4:	e5973000 	ldr	r3, [r7]
300027b8:	e1d301b8 	ldrh	r0, [r3, #24]
300027bc:	ebfffdf3 	bl	30001f90 <change_end>
300027c0:	e1a03000 	mov	r3, r0
300027c4:	e243300c 	sub	r3, r3, #12	; 0xc
300027c8:	e1a03803 	mov	r3, r3, lsl #16
300027cc:	e3a0002e 	mov	r0, #46	; 0x2e
300027d0:	e1a04823 	mov	r4, r3, lsr #16
300027d4:	ebfffd39 	bl	30001cc0 <s3c2440_serial_send_byte>
300027d8:	e5971000 	ldr	r1, [r7]
300027dc:	e5950010 	ldr	r0, [r5, #16]
300027e0:	e2811020 	add	r1, r1, #32	; 0x20
300027e4:	e1a02004 	mov	r2, r4
300027e8:	ebfff96e 	bl	30000da8 <lmemcpy>
300027ec:	e5953010 	ldr	r3, [r5, #16]
300027f0:	e3540c02 	cmp	r4, #512	; 0x200
300027f4:	e2833c02 	add	r3, r3, #512	; 0x200
300027f8:	e5853010 	str	r3, [r5, #16]
300027fc:	0a00000d 	beq	30002838 <anlz_tftp+0x15c>
30002800:	e59f30d0 	ldr	r3, [pc, #208]	; 300028d8 <.text+0x28d8>
30002804:	e59f00d0 	ldr	r0, [pc, #208]	; 300028dc <.text+0x28dc>
30002808:	e5931000 	ldr	r1, [r3]
3000280c:	e3a03000 	mov	r3, #0	; 0x0
30002810:	e5c53014 	strb	r3, [r5, #20]
30002814:	ebfffaae 	bl	300012d4 <cs8900_send>
30002818:	e1d530b8 	ldrh	r3, [r5, #8]
3000281c:	e0843483 	add	r3, r4, r3, lsl #9
30002820:	e2433c02 	sub	r3, r3, #512	; 0x200
30002824:	e1a01003 	mov	r1, r3
30002828:	e59f00b0 	ldr	r0, [pc, #176]	; 300028e0 <.text+0x28e0>
3000282c:	e1a02003 	mov	r2, r3
30002830:	e5853000 	str	r3, [r5]
30002834:	ebfffb52 	bl	30001584 <lprint>
30002838:	e1d530b8 	ldrh	r3, [r5, #8]
3000283c:	e1a00006 	mov	r0, r6
30002840:	e2833001 	add	r3, r3, #1	; 0x1
30002844:	e1c530b8 	strh	r3, [r5, #8]
30002848:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
3000284c:	e3530b01 	cmp	r3, #1024	; 0x400
30002850:	1a000006 	bne	30002870 <anlz_tftp+0x194>
30002854:	e1d401be 	ldrh	r0, [r4, #30]
30002858:	ebfffdcc 	bl	30001f90 <change_end>
3000285c:	e1d520b8 	ldrh	r2, [r5, #8]
30002860:	e1a00800 	mov	r0, r0, lsl #16
30002864:	e1a00820 	mov	r0, r0, lsr #16
30002868:	e1500002 	cmp	r0, r2
3000286c:	0a000003 	beq	30002880 <anlz_tftp+0x1a4>
30002870:	e59f005c 	ldr	r0, [pc, #92]	; 300028d4 <.text+0x28d4>
30002874:	ebfffb42 	bl	30001584 <lprint>
30002878:	e1a00006 	mov	r0, r6
3000287c:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
30002880:	e1d530ba 	ldrh	r3, [r5, #10]
30002884:	e1500003 	cmp	r0, r3
30002888:	1a000004 	bne	300028a0 <anlz_tftp+0x1c4>
3000288c:	e59f0050 	ldr	r0, [pc, #80]	; 300028e4 <.text+0x28e4>
30002890:	e5c56014 	strb	r6, [r5, #20]
30002894:	ebfffb3a 	bl	30001584 <lprint>
30002898:	e3a00001 	mov	r0, #1	; 0x1
3000289c:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
300028a0:	e2823001 	add	r3, r2, #1	; 0x1
300028a4:	e3a04001 	mov	r4, #1	; 0x1
300028a8:	e3a00060 	mov	r0, #96	; 0x60
300028ac:	e1c530b8 	strh	r3, [r5, #8]
300028b0:	e5c54014 	strb	r4, [r5, #20]
300028b4:	ebfffd01 	bl	30001cc0 <s3c2440_serial_send_byte>
300028b8:	ebfffe9e 	bl	30002338 <setup_tftp_package>
300028bc:	e1a00004 	mov	r0, r4
300028c0:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
300028c4:	30003e28 	andcc	r3, r0, r8, lsr #28
300028c8:	30004ac0 	andcc	r4, r0, r0, asr #21
300028cc:	30003e84 	andcc	r3, r0, r4, lsl #29
300028d0:	30003cd4 	ldrccd	r3, [r0], -r4
300028d4:	30003d00 	andcc	r3, r0, r0, lsl #26
300028d8:	30004ac4 	andcc	r4, r0, r4, asr #21
300028dc:	30003ed8 	ldrccd	r3, [r0], -r8
300028e0:	30003d14 	andcc	r3, r0, r4, lsl sp
300028e4:	30003b58 	andcc	r3, r0, r8, asr fp

300028e8 <tftp_run>:
	
static void tftp_run()
{
300028e8:	e92d4030 	stmdb	sp!, {r4, r5, lr}
        sep = (struct eth_h*)s_buf; 
300028ec:	e59f40d8 	ldr	r4, [pc, #216]	; 300029cc <.text+0x29cc>
	rep = (struct eth_h*)r_buf;
        siutp = (struct ip_udp_tftp*) sep->datas;
300028f0:	e59f30d8 	ldr	r3, [pc, #216]	; 300029d0 <.text+0x29d0>
300028f4:	e59f00d8 	ldr	r0, [pc, #216]	; 300029d4 <.text+0x29d4>
300028f8:	e284200e 	add	r2, r4, #14	; 0xe
300028fc:	e5832000 	str	r2, [r3]
        riutp = (struct ip_udp_tftp*) rep->datas;
30002900:	e59f30d0 	ldr	r3, [pc, #208]	; 300029d8 <.text+0x29d8>
30002904:	e280100e 	add	r1, r0, #14	; 0xe
30002908:	e5831000 	str	r1, [r3]
3000290c:	e59f30c8 	ldr	r3, [pc, #200]	; 300029dc <.text+0x29dc>
30002910:	e5834000 	str	r4, [r3]
30002914:	e59f30c4 	ldr	r3, [pc, #196]	; 300029e0 <.text+0x29e0>

	t_s.server_port = 69;
30002918:	e59f50c4 	ldr	r5, [pc, #196]	; 300029e4 <.text+0x29e4>
	t_s.port = 0;
3000291c:	e3a0c000 	mov	ip, #0	; 0x0
30002920:	e5830000 	str	r0, [r3]
30002924:	e3a03045 	mov	r3, #69	; 0x45
	t_s.running = 0;
30002928:	e5c5c014 	strb	ip, [r5, #20]
3000292c:	e1c530b6 	strh	r3, [r5, #6]
30002930:	e1c5c0b4 	strh	ip, [r5, #4]
	if(!cs8900_is_ready()){
30002934:	ebfffa46 	bl	30001254 <cs8900_is_ready>
30002938:	e3500000 	cmp	r0, #0	; 0x0
3000293c:	059f00a4 	ldreq	r0, [pc, #164]	; 300029e8 <.text+0x29e8>
30002940:	0a000018 	beq	300029a8 <tftp_run+0xc0>
		lprint("cs8900 not ready!\r\n");
		return;
	}
	cs8900_open();
30002944:	ebfff9b2 	bl	30001014 <cs8900_open>
	setup_arp_req(s_buf);	
30002948:	e1a00004 	mov	r0, r4
3000294c:	ebfffdad 	bl	30002008 <setup_arp_req>
	if(!get_response(anlz_arq, 3)){
30002950:	e59f0094 	ldr	r0, [pc, #148]	; 300029ec <.text+0x29ec>
30002954:	e3a01003 	mov	r1, #3	; 0x3
30002958:	ebfffe40 	bl	30002260 <get_response>
3000295c:	e3500000 	cmp	r0, #0	; 0x0
30002960:	059f0088 	ldreq	r0, [pc, #136]	; 300029f0 <.text+0x29f0>
30002964:	0a00000f 	beq	300029a8 <tftp_run+0xc0>
		lprint("server no response!\r\n");
		return;
	}
	setup_tftp_package();
30002968:	ebfffe72 	bl	30002338 <setup_tftp_package>
	if(!get_response(anlz_tftp,0)){
3000296c:	e59f0080 	ldr	r0, [pc, #128]	; 300029f4 <.text+0x29f4>
30002970:	e3a01000 	mov	r1, #0	; 0x0
30002974:	ebfffe39 	bl	30002260 <get_response>
30002978:	e3500000 	cmp	r0, #0	; 0x0
3000297c:	059f0074 	ldreq	r0, [pc, #116]	; 300029f8 <.text+0x29f8>
30002980:	0a000008 	beq	300029a8 <tftp_run+0xc0>
		lprint("server no tftp response!\r\n");
		return;
	}
	while(t_s.running){
30002984:	e5d53014 	ldrb	r3, [r5, #20]
30002988:	e3530000 	cmp	r3, #0	; 0x0
3000298c:	0a00000a 	beq	300029bc <tftp_run+0xd4>
		if(!get_response(anlz_tftp, 0)){
30002990:	e59f005c 	ldr	r0, [pc, #92]	; 300029f4 <.text+0x29f4>
30002994:	e3a01000 	mov	r1, #0	; 0x0
30002998:	ebfffe30 	bl	30002260 <get_response>
3000299c:	e3500000 	cmp	r0, #0	; 0x0
300029a0:	1a000002 	bne	300029b0 <tftp_run+0xc8>
			lprint("lost connection with server while transfering!\r\n");
300029a4:	e59f0050 	ldr	r0, [pc, #80]	; 300029fc <.text+0x29fc>
300029a8:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
300029ac:	eafffaf4 	b	30001584 <lprint>
			return;
300029b0:	e5d53014 	ldrb	r3, [r5, #20]
300029b4:	e3530000 	cmp	r3, #0	; 0x0
300029b8:	1afffff4 	bne	30002990 <tftp_run+0xa8>
		}
	}
	cs8900_halt();
300029bc:	ebfff98f 	bl	30001000 <cs8900_halt>
	lprint("tftp operation finished successfully!\r\n");
300029c0:	e59f0038 	ldr	r0, [pc, #56]	; 30002a00 <.text+0x2a00>
300029c4:	ebfffaee 	bl	30001584 <lprint>
	return;
300029c8:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
300029cc:	30003ed8 	ldrccd	r3, [r0], -r8
300029d0:	30004abc 	strcch	r4, [r0], -ip
300029d4:	300044c6 	andcc	r4, r0, r6, asr #9
300029d8:	30004ac0 	andcc	r4, r0, r0, asr #21
300029dc:	30003e24 	andcc	r3, r0, r4, lsr #28
300029e0:	30003e28 	andcc	r3, r0, r8, lsr #28
300029e4:	30003e84 	andcc	r3, r0, r4, lsl #29
300029e8:	30003d2c 	andcc	r3, r0, ip, lsr #26
300029ec:	300020d8 	ldrccd	r2, [r0], -r8
300029f0:	30003d40 	andcc	r3, r0, r0, asr #26
300029f4:	300026dc 	ldrccd	r2, [r0], -ip
300029f8:	30003d58 	andcc	r3, r0, r8, asr sp
300029fc:	30003d74 	andcc	r3, r0, r4, ror sp
30002a00:	30003da8 	andcc	r3, r0, r8, lsr #27

30002a04 <crc16>:
uint crc16(unsigned char *c, uint len)
{
	uint crc16_check = 0, j;

	while(len--)
30002a04:	e2411001 	sub	r1, r1, #1	; 0x1
30002a08:	e3710001 	cmn	r1, #1	; 0x1
30002a0c:	e52de004 	str	lr, [sp, #-4]!
30002a10:	e1a0e000 	mov	lr, r0
30002a14:	e3a00000 	mov	r0, #0	; 0x0
30002a18:	0a00000e 	beq	30002a58 <crc16+0x54>
	{
		crc16_check = crc16_check ^ (uint)*c++ << 8;
30002a1c:	e4de3001 	ldrb	r3, [lr], #1
		for (j=0;j<8;j++)
30002a20:	e3a0c000 	mov	ip, #0	; 0x0
30002a24:	e0200403 	eor	r0, r0, r3, lsl #8
		{
			if(crc16_check & 0x8000)
30002a28:	e59f3034 	ldr	r3, [pc, #52]	; 30002a64 <.text+0x2a64>
30002a2c:	e1a02080 	mov	r2, r0, lsl #1
30002a30:	e3100902 	tst	r0, #32768	; 0x8000
30002a34:	e0220003 	eor	r0, r2, r3
30002a38:	e28c3001 	add	r3, ip, #1	; 0x1
				crc16_check = crc16_check << 1 ^ 0x1021;
			else
				crc16_check <<= 1;
30002a3c:	01a00002 	moveq	r0, r2
30002a40:	e3530007 	cmp	r3, #7	; 0x7
30002a44:	e1a0c003 	mov	ip, r3
30002a48:	9afffff6 	bls	30002a28 <crc16+0x24>
30002a4c:	e2411001 	sub	r1, r1, #1	; 0x1
30002a50:	e3710001 	cmn	r1, #1	; 0x1
30002a54:	1afffff0 	bne	30002a1c <crc16+0x18>
		}
	}
	return crc16_check & 0xffff;
30002a58:	e1a00800 	mov	r0, r0, lsl #16
30002a5c:	e1a00820 	mov	r0, r0, lsr #16
}
30002a60:	e49df004 	ldr	pc, [sp], #4
30002a64:	00001021 	andeq	r1, r0, r1, lsr #32

30002a68 <time_limit_recv_byte>:

uint time_limit_recv_byte(uint limit, unsigned char * c)
{
30002a68:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	while(limit--){
30002a6c:	e2404001 	sub	r4, r0, #1	; 0x1
30002a70:	e3740001 	cmn	r4, #1	; 0x1
30002a74:	e1a05001 	mov	r5, r1
30002a78:	0a000009 	beq	30002aa4 <time_limit_recv_byte+0x3c>
		if(is_con_recv()){
30002a7c:	ebfffcbe 	bl	30001d7c <s3c2440_is_serial_recv>
30002a80:	e3500000 	cmp	r0, #0	; 0x0
30002a84:	e2444001 	sub	r4, r4, #1	; 0x1
30002a88:	0a000003 	beq	30002a9c <time_limit_recv_byte+0x34>
			*c = con_recv();
30002a8c:	ebfffc95 	bl	30001ce8 <s3c2440_serial_recv_byte>
			return 0;
30002a90:	e3a03000 	mov	r3, #0	; 0x0
30002a94:	e5c50000 	strb	r0, [r5]
30002a98:	ea000002 	b	30002aa8 <time_limit_recv_byte+0x40>
30002a9c:	e3740001 	cmn	r4, #1	; 0x1
30002aa0:	1afffff5 	bne	30002a7c <time_limit_recv_byte+0x14>
		}
	}
	return 1;
30002aa4:	e3a03001 	mov	r3, #1	; 0x1
}
30002aa8:	e1a00003 	mov	r0, r3
30002aac:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

30002ab0 <xmodem_1k_recv>:

uint xmodem_1k_recv(unsigned char*p)
{
30002ab0:	e92d46f0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, lr}
        uint i = 128, tmp = 0xa0000, repeat = 66, packages = 0;
30002ab4:	e3a0a000 	mov	sl, #0	; 0x0
30002ab8:	e24dd004 	sub	sp, sp, #4	; 0x4
	unsigned char recved = 0, index = 1, check_sum = 0, *c;
30002abc:	e5cda003 	strb	sl, [sp, #3]

	c = p;
30002ac0:	e1a09000 	mov	r9, r0
30002ac4:	e3a04042 	mov	r4, #66	; 0x42
30002ac8:	e3a07001 	mov	r7, #1	; 0x1
	do{
                con_send(0x15);
30002acc:	e3a00015 	mov	r0, #21	; 0x15
30002ad0:	ebfffc7a 	bl	30001cc0 <s3c2440_serial_send_byte>
		if(time_limit_recv_byte(0x80000, &recved) == 0)
30002ad4:	e3a00702 	mov	r0, #524288	; 0x80000
30002ad8:	e28d1003 	add	r1, sp, #3	; 0x3
30002adc:	ebffffe1 	bl	30002a68 <time_limit_recv_byte>
30002ae0:	e3500000 	cmp	r0, #0	; 0x0
30002ae4:	0a000002 	beq	30002af4 <xmodem_1k_recv+0x44>
			break;
	}while(repeat--);
30002ae8:	e2444001 	sub	r4, r4, #1	; 0x1
30002aec:	e3740001 	cmn	r4, #1	; 0x1
30002af0:	1afffff5 	bne	30002acc <xmodem_1k_recv+0x1c>
	if(!repeat){
30002af4:	e3540000 	cmp	r4, #0	; 0x0
30002af8:	1a000003 	bne	30002b0c <xmodem_1k_recv+0x5c>
		con_send(CAN);
30002afc:	e3a00018 	mov	r0, #24	; 0x18
30002b00:	ebfffc6e 	bl	30001cc0 <s3c2440_serial_send_byte>
		return 1;
30002b04:	e3a00001 	mov	r0, #1	; 0x1
30002b08:	ea000041 	b	30002c14 <xmodem_1k_recv+0x164>
	}
start_recv_package:
	if(recved != SOH){
30002b0c:	e5dd3003 	ldrb	r3, [sp, #3]
30002b10:	e3530001 	cmp	r3, #1	; 0x1
30002b14:	1a00003b 	bne	30002c08 <xmodem_1k_recv+0x158>
		con_send(CAN);
		return 2;
	}
	if(time_limit_recv_byte(0x20000, &recved) == 1){
30002b18:	e28d6003 	add	r6, sp, #3	; 0x3
30002b1c:	e3a00802 	mov	r0, #131072	; 0x20000
30002b20:	e1a01006 	mov	r1, r6
30002b24:	ebffffcf 	bl	30002a68 <time_limit_recv_byte>
30002b28:	e3500001 	cmp	r0, #1	; 0x1
30002b2c:	0a000035 	beq	30002c08 <xmodem_1k_recv+0x158>
		con_send(CAN);
		return 2;
	}
	if(recved != index){
30002b30:	e5dd3003 	ldrb	r3, [sp, #3]
30002b34:	e1530007 	cmp	r3, r7
30002b38:	1a000032 	bne	30002c08 <xmodem_1k_recv+0x158>
		con_send(CAN);
		return 2;
	}
	if(time_limit_recv_byte(0x20000, &recved) == 1){
30002b3c:	e3a00802 	mov	r0, #131072	; 0x20000
30002b40:	e1a01006 	mov	r1, r6
30002b44:	ebffffc7 	bl	30002a68 <time_limit_recv_byte>
30002b48:	e3500001 	cmp	r0, #1	; 0x1
30002b4c:	0a00002d 	beq	30002c08 <xmodem_1k_recv+0x158>
		con_send(CAN);
		return 2;
	}
	if((recved + index) != 0xff){
30002b50:	e5dd3003 	ldrb	r3, [sp, #3]
30002b54:	e0833007 	add	r3, r3, r7
30002b58:	e35300ff 	cmp	r3, #255	; 0xff
30002b5c:	1a000029 	bne	30002c08 <xmodem_1k_recv+0x158>
		con_send(CAN);
		return 2;
	}
	i = 128;
	check_sum = 0;
30002b60:	e3a05000 	mov	r5, #0	; 0x0
	while(i--){
30002b64:	e3a0407f 	mov	r4, #127	; 0x7f
		if(time_limit_recv_byte(0x20000, &recved) == 1){
30002b68:	e3a00802 	mov	r0, #131072	; 0x20000
30002b6c:	e1a01006 	mov	r1, r6
30002b70:	ebffffbc 	bl	30002a68 <time_limit_recv_byte>
30002b74:	e3500001 	cmp	r0, #1	; 0x1
30002b78:	e2444001 	sub	r4, r4, #1	; 0x1
30002b7c:	0a000021 	beq	30002c08 <xmodem_1k_recv+0x158>
			con_send(CAN);
			return 2;
		}
		*c++ = recved;
30002b80:	e5dd2003 	ldrb	r2, [sp, #3]
		check_sum += recved;
30002b84:	e3740001 	cmn	r4, #1	; 0x1
30002b88:	e0853002 	add	r3, r5, r2
30002b8c:	e20350ff 	and	r5, r3, #255	; 0xff
30002b90:	e4c92001 	strb	r2, [r9], #1
30002b94:	1afffff3 	bne	30002b68 <xmodem_1k_recv+0xb8>
	}
	if(time_limit_recv_byte(0x20000, &recved) == 1){
30002b98:	e3a00802 	mov	r0, #131072	; 0x20000
30002b9c:	e1a01006 	mov	r1, r6
30002ba0:	ebffffb0 	bl	30002a68 <time_limit_recv_byte>
30002ba4:	e3500001 	cmp	r0, #1	; 0x1
30002ba8:	0a000016 	beq	30002c08 <xmodem_1k_recv+0x158>
		con_send(CAN);
		return 2;
	}
	if(recved != check_sum){
30002bac:	e5dd3003 	ldrb	r3, [sp, #3]
30002bb0:	e1530005 	cmp	r3, r5
30002bb4:	1a000013 	bne	30002c08 <xmodem_1k_recv+0x158>
		con_send(CAN);
		return 2;
	}
	con_send(ACK);
30002bb8:	e3a00006 	mov	r0, #6	; 0x6
30002bbc:	ebfffc3f 	bl	30001cc0 <s3c2440_serial_send_byte>
	if(time_limit_recv_byte(0x20000, &recved) == 1){
30002bc0:	e1a01006 	mov	r1, r6
30002bc4:	e3a00802 	mov	r0, #131072	; 0x20000
30002bc8:	ebffffa6 	bl	30002a68 <time_limit_recv_byte>
30002bcc:	e3500001 	cmp	r0, #1	; 0x1
30002bd0:	0a00000c 	beq	30002c08 <xmodem_1k_recv+0x158>
		con_send(CAN);
		return 2;
	}
	packages++;
	if(recved == EOT){
30002bd4:	e5dd3003 	ldrb	r3, [sp, #3]
30002bd8:	e3530004 	cmp	r3, #4	; 0x4
		con_send(ACK);
		lprint("\r\nreceive 0x%x bytes successfully\r\n", 128*packages);
		return 0;
	}
	index++;
30002bdc:	12873001 	addne	r3, r7, #1	; 0x1
30002be0:	e28aa001 	add	sl, sl, #1	; 0x1
30002be4:	120370ff 	andne	r7, r3, #255	; 0xff
	goto start_recv_package;
30002be8:	1affffc7 	bne	30002b0c <xmodem_1k_recv+0x5c>
30002bec:	e3a00006 	mov	r0, #6	; 0x6
30002bf0:	ebfffc32 	bl	30001cc0 <s3c2440_serial_send_byte>
30002bf4:	e1a0138a 	mov	r1, sl, lsl #7
30002bf8:	e59f001c 	ldr	r0, [pc, #28]	; 30002c1c <.text+0x2c1c>
30002bfc:	ebfffa60 	bl	30001584 <lprint>
30002c00:	e3a00000 	mov	r0, #0	; 0x0
30002c04:	ea000002 	b	30002c14 <xmodem_1k_recv+0x164>
30002c08:	e3a00018 	mov	r0, #24	; 0x18
30002c0c:	ebfffc2b 	bl	30001cc0 <s3c2440_serial_send_byte>
30002c10:	e3a00002 	mov	r0, #2	; 0x2
}
30002c14:	e28dd004 	add	sp, sp, #4	; 0x4
30002c18:	e8bd86f0 	ldmia	sp!, {r4, r5, r6, r7, r9, sl, pc}
30002c1c:	30003dd0 	ldrccd	r3, [r0], -r0

30002c20 <xmodem_1k_send>:

uint xmodem_1k_send(unsigned char*c, uint len)
{
30002c20:	e92d4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
30002c24:	e1a05000 	mov	r5, r0
30002c28:	e24dd008 	sub	sp, sp, #8	; 0x8
        uint i = 128, check_way = 0; /*0-crc16 1-checksum*/
30002c2c:	e3a0a000 	mov	sl, #0	; 0x0
	unsigned char tmpchar = 0, index = 1, check_sum = 0, *clast;
	uint check_crc16;

	lprint("Please get the receiver ready!\r\n");
30002c30:	e59f0114 	ldr	r0, [pc, #276]	; 30002d4c <.text+0x2d4c>
30002c34:	e58d1000 	str	r1, [sp]
30002c38:	e5cda007 	strb	sl, [sp, #7]
30002c3c:	e3a07001 	mov	r7, #1	; 0x1
30002c40:	ebfffa4f 	bl	30001584 <lprint>
	while(1){
		tmpchar = con_recv();
30002c44:	ebfffc27 	bl	30001ce8 <s3c2440_serial_recv_byte>
30002c48:	e5cd0007 	strb	r0, [sp, #7]
		if(tmpchar == 'C'){
30002c4c:	e5dd3007 	ldrb	r3, [sp, #7]
30002c50:	e3530043 	cmp	r3, #67	; 0x43
30002c54:	0a000002 	beq	30002c64 <xmodem_1k_send+0x44>
			break;
		}
		if(tmpchar == NACK){
30002c58:	e3530015 	cmp	r3, #21	; 0x15
30002c5c:	1afffff8 	bne	30002c44 <xmodem_1k_send+0x24>
			check_way = 1;
30002c60:	e3a0a001 	mov	sl, #1	; 0x1
			break;
		}
	}
start_send_package:
	if(index > len){
30002c64:	e59d3000 	ldr	r3, [sp]
30002c68:	e1570003 	cmp	r7, r3
30002c6c:	8a00002d 	bhi	30002d28 <xmodem_1k_send+0x108>
		con_send(EOT);
		con_recv();
		time_limit_recv_byte(0x20000, &tmpchar);
		return 0;
	}
	con_send(SOH);
30002c70:	e3a00001 	mov	r0, #1	; 0x1
30002c74:	ebfffc11 	bl	30001cc0 <s3c2440_serial_send_byte>
	con_send(index);
30002c78:	e1a00007 	mov	r0, r7
30002c7c:	ebfffc0f 	bl	30001cc0 <s3c2440_serial_send_byte>
	con_send(~index & 0xff);
30002c80:	e1e00007 	mvn	r0, r7
30002c84:	e20000ff 	and	r0, r0, #255	; 0xff
30002c88:	ebfffc0c 	bl	30001cc0 <s3c2440_serial_send_byte>
	i = 128;
	check_sum = 0;
	if(!check_way)
30002c8c:	e35a0000 	cmp	sl, #0	; 0x0
30002c90:	e3a04080 	mov	r4, #128	; 0x80
30002c94:	e3a06000 	mov	r6, #0	; 0x0
30002c98:	1a000003 	bne	30002cac <xmodem_1k_send+0x8c>
		check_crc16 = crc16(c, 128);
30002c9c:	e1a01004 	mov	r1, r4
30002ca0:	e1a00005 	mov	r0, r5
30002ca4:	ebffff56 	bl	30002a04 <crc16>
30002ca8:	e1a0b000 	mov	fp, r0
	clast = c;
30002cac:	e1a09005 	mov	r9, r5
	while(i--){
30002cb0:	e3a0407f 	mov	r4, #127	; 0x7f
		tmpchar = *c++;
30002cb4:	e4d53001 	ldrb	r3, [r5], #1
30002cb8:	e5cd3007 	strb	r3, [sp, #7]
		con_send(tmpchar);
30002cbc:	e5dd0007 	ldrb	r0, [sp, #7]
30002cc0:	ebfffbfe 	bl	30001cc0 <s3c2440_serial_send_byte>
		check_sum += tmpchar;
30002cc4:	e5dd3007 	ldrb	r3, [sp, #7]
30002cc8:	e2444001 	sub	r4, r4, #1	; 0x1
30002ccc:	e0863003 	add	r3, r6, r3
30002cd0:	e3740001 	cmn	r4, #1	; 0x1
30002cd4:	e20360ff 	and	r6, r3, #255	; 0xff
30002cd8:	1afffff5 	bne	30002cb4 <xmodem_1k_send+0x94>
	}
	if(check_way)
30002cdc:	e35a0000 	cmp	sl, #0	; 0x0
30002ce0:	11a00006 	movne	r0, r6
30002ce4:	1a000003 	bne	30002cf8 <xmodem_1k_send+0xd8>
		con_send(check_sum);
	else{
		//con_send(0xb1);
		//con_send(0x47);
		con_send((check_crc16>>8) & 0xff);
30002ce8:	e1a0042b 	mov	r0, fp, lsr #8
30002cec:	e20000ff 	and	r0, r0, #255	; 0xff
30002cf0:	ebfffbf2 	bl	30001cc0 <s3c2440_serial_send_byte>
		con_send(check_crc16 & 0xff);
30002cf4:	e20b00ff 	and	r0, fp, #255	; 0xff
30002cf8:	ebfffbf0 	bl	30001cc0 <s3c2440_serial_send_byte>
	}	
	tmpchar = con_recv();
30002cfc:	ebfffbf9 	bl	30001ce8 <s3c2440_serial_recv_byte>
30002d00:	e5cd0007 	strb	r0, [sp, #7]
	if(tmpchar == ACK)
30002d04:	e5dd3007 	ldrb	r3, [sp, #7]
30002d08:	e3530006 	cmp	r3, #6	; 0x6
30002d0c:	02873001 	addeq	r3, r7, #1	; 0x1
30002d10:	020370ff 	andeq	r7, r3, #255	; 0xff
30002d14:	0affffd2 	beq	30002c64 <xmodem_1k_send+0x44>
		index++;
	else if(tmpchar == NACK)
30002d18:	e3530015 	cmp	r3, #21	; 0x15
30002d1c:	01a05009 	moveq	r5, r9
30002d20:	0affffcf 	beq	30002c64 <xmodem_1k_send+0x44>
		c = clast;
	else
		while(1);
30002d24:	eafffffe 	b	30002d24 <xmodem_1k_send+0x104>
	goto start_send_package;
}
30002d28:	e3a00004 	mov	r0, #4	; 0x4
30002d2c:	ebfffbe3 	bl	30001cc0 <s3c2440_serial_send_byte>
30002d30:	ebfffbec 	bl	30001ce8 <s3c2440_serial_recv_byte>
30002d34:	e28d1007 	add	r1, sp, #7	; 0x7
30002d38:	e3a00802 	mov	r0, #131072	; 0x20000
30002d3c:	ebffff49 	bl	30002a68 <time_limit_recv_byte>
30002d40:	e3a00000 	mov	r0, #0	; 0x0
30002d44:	e28dd008 	add	sp, sp, #8	; 0x8
30002d48:	e8bd8ef0 	ldmia	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}
30002d4c:	30003df4 	strccd	r3, [r0], -r4
